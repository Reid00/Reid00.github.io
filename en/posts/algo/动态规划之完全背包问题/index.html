<!doctype html><html lang=en dir=auto><head><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/algo/>algorithm 数据结果算法相关的记录</a></div><h1 class=post-title>动态规划之完全背包问题</h1><div class=post-description>动态规划之完全背包问题</div><div class=post-meta><span title='2024-04-19 16:55:23 +0800 +0800'>2024-04-19 16:55</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;1261 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%ae%8c%e5%85%a8%e8%83%8c%e5%8c%85 aria-label=完全背包>完全背包</a><ul><li><a href=#%e9%a2%98%e5%b9%b2%e8%a7%a3%e6%9e%90 aria-label=题干解析>题干解析</a></li></ul></li><li><a href=#%e5%ba%94%e7%94%a8 aria-label=应用>应用</a></li><li><a href=#%e8%83%8c%e5%8c%85%e6%80%bb%e7%bb%93 aria-label=背包总结>背包总结</a></li></ul></div></details></div><div class=post-content><h1 id=完全背包>完全背包<a hidden class=anchor aria-hidden=true href=#完全背包>#</a></h1><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。</p><p>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。</p><h2 id=题干解析>题干解析<a hidden class=anchor aria-hidden=true href=#题干解析>#</a></h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
<img loading=lazy src=https://Reid00.github.io/picx-images-hosting/20240422/image.sv3vc0se31s.webp alt=bag>
比如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>weight</span> <span class=p>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>  <span class=c1>// 三个物品
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span> <span class=p>=</span> <span class=p>[</span><span class=mi>15</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>]</span> <span class=c1>// 对应该的价值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>bagweight</span> <span class=p>=</span> <span class=mi>4</span> <span class=c1>// 背包的容量为4
</span></span></span></code></pre></td></tr></table></div></div><p>问背包能背的物品最大价值是多少？</p><p>01背包和完全背包唯一不同就是体现在遍历顺序上，我们直接分析。</p><p>首先再回顾一下01背包的核心代码:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span> <span class=c1>//遍历物品
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 需要注意的是，j 一定要从大到小，防止物品0 被重复计算
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>bagWeight</span><span class=p>;</span> <span class=nx>j</span> <span class=o>&gt;=</span> <span class=nx>weight</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span> <span class=nx>j</span><span class=o>--</span> <span class=p>{</span> <span class=c1>//遍历背包容量
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>dp</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nb>max</span><span class=p>(</span><span class=nx>dp</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>j</span><span class=o>-</span><span class=nx>weight</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span><span class=o>+</span><span class=nx>value</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p><p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>	<span class=c1>//遍历物品
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 完全背包，i 可以重复添加，要从小到大遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=nx>j</span> <span class=o>:=</span> <span class=nx>weight</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span> <span class=nx>j</span> <span class=o>&lt;=</span> <span class=nx>bagWeight</span><span class=p>;</span> <span class=nx>j</span> <span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>dp</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=nb>max</span><span class=p>(</span><span class=nx>dp</span><span class=p>[</span><span class=nx>j</span><span class=p>],</span> <span class=nx>dp</span><span class=p>[</span><span class=nx>j</span><span class=o>-</span><span class=nx>weight</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span> <span class=o>+</span> <span class=nx>value</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？
难道就不能遍历背包容量在外层，遍历物品在内层？
01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。
在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</p><p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p><p>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！
因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p><h1 id=应用>应用<a hidden class=anchor aria-hidden=true href=#应用>#</a></h1><p>讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p><p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p><p><code>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</code>
<code>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</code></p><ul><li><p>求组合数
<a href=https://leetcode.cn/problems/coin-change-ii/>518.零钱兑换II</a></p></li><li><p>求排列数
<a href=https://leetcode.cn/problems/combination-sum-iv/description/>377. 组合总和 Ⅳ</a>
<a href=https://leetcode.cn/problems/climbing-stairs/description/>70. 爬楼梯</a></p></li><li><p>最小数
那么两层for循环的先后顺序就无所谓了
<a href=https://leetcode.cn/problems/coin-change/>322. 零钱兑换</a>
<a href=https://leetcode.cn/problems/perfect-squares/description/>279. 完全平方数</a></p></li></ul><h1 id=背包总结>背包总结<a hidden class=anchor aria-hidden=true href=#背包总结>#</a></h1><p>问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); 对应题目如下：
<a href=https://leetcode.cn/problems/partition-equal-subset-sum>416.分割等和子集</a>
<a href=https://leetcode.cn/problems/last-stone-weight-ii>1049.最后一块石头的重量 II</a></p><p>问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：
494.目标和
<a href=https://leetcode.cn/problems/coin-change-ii/>518.零钱兑换II</a>
<a href=https://leetcode.cn/problems/combination-sum-iv/description/>377. 组合总和 Ⅳ</a>
<a href=https://leetcode.cn/problems/climbing-stairs/description/>70. 爬楼梯</a></p><p>问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 对应题目如下：
<a href=https://leetcode.cn/problems/ones-and-zeroes>474.一和零</a></p><p>问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); 对应题目如下：
<a href=https://leetcode.cn/problems/coin-change/>322. 零钱兑换</a>
<a href=https://leetcode.cn/problems/perfect-squares/description/>279. 完全平方数</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/dp/>DP</a></li><li><a href=https://reid00.github.io/en/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/>完全背包问题</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/><span class=title>« Prev</span><br><span>动态规划之01背包问题</span>
</a><a class=next href=https://reid00.github.io/en/posts/langs_linux/rust-leetcode%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/><span class=title>Next »</span><br><span>Rust Leetcode链表实现</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><span id=busuanzi_container_site_pv>访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>访客数<span id=busuanzi_value_site_uv></span>人次</span></body></html>