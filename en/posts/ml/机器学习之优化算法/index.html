<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>机器学习之优化算法 | Reid's Blog</title>
<meta name=keywords content="优化"><meta name=description content="机器学习之优化算法"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="机器学习之优化算法"><meta property="og:description" content="机器学习之优化算法"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:35:22+08:00"><meta property="article:modified_time" content="2023-03-16T19:35:22+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="机器学习之优化算法"><meta name=twitter:description content="机器学习之优化算法"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"机器学习，深度学习，知识图谱相关","item":"https://reid00.github.io/en/posts/ml/"},{"@type":"ListItem","position":3,"name":"机器学习之优化算法","item":"https://reid00.github.io/en/posts/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"机器学习之优化算法","name":"机器学习之优化算法","description":"机器学习之优化算法","keywords":["优化"],"articleBody":"在调整模型更新权重和偏差参数的方式时，你是否考虑过哪种优化算法能使模型产生更好且更快的效果？应该用梯度下降，随机梯度下降，还是Adam方法？\n这篇文章介绍了不同优化算法之间的主要区别，以及如何选择最佳的优化方法。\n梯度: 是多元函数对当前给定点，上升最快的方向。梯度是一组向量，所以带有方向;\n梯度下降流程: https://zhuanlan.zhihu.com/p/68468520 w, b 每轮是每个样本的权重梯度向量和偏差梯度向量的平均值；\n梯度下降本质是沿着负梯度值方向寻找损失函数Loss的最小值解 时的参数w,b , 从而得出对样本数据拟合最好的参数w,b。 https://www.jianshu.com/p/c7e642877b0e\n什么是优化算法？ 优化算法的功能，是通过改善训练方式，来最小化(或最大化)损失函数E(x)。\n模型内部有些参数，是用来计算测试集中目标值Y的真实值和预测值的偏差程度的，基于这些参数，就形成了损失函数E(x)。\n比如说，权重(W)和偏差(b)就是这样的内部参数，一般用于计算输出值，在训练神经网络模型时起到主要作用。\n**在有效地训练模型并产生准确结果时，模型的内部参数起到了非常重要的作用。**这也是为什么我们应该用各种优化策略和算法，来更新和计算影响模型训练和模型输出的网络参数，使其逼近或达到最优值。\n优化算法分为两大类：\n1. 一阶优化算法\n这种算法使用各参数的梯度值来最小化或最大化损失函数E(x)。最常用的一阶优化算法是梯度下降。\n函数梯度：导数dy/dx的多变量表达式，用来表示y相对于x的瞬时变化率。往往为了计算多变量函数的导数时，会用梯度取代导数，并使用偏导数来计算梯度。梯度和导数之间的一个主要区别是函数的梯度形成了一个向量场。\n因此，对单变量函数，使用导数来分析；而梯度是基于多变量函数而产生的。更多理论细节在这里不再进行详细解释。\n2. 二阶优化算法\n二阶优化算法使用了二阶导数(也叫做Hessian方法)来最小化或最大化损失函数。由于二阶导数的计算成本很高，所以这种方法并没有广泛使用。\n详解各种神经网络优化算法 梯度下降 在训练和优化智能系统时，梯度下降是一种最重要的技术和基础。梯度下降的功能是：\n通过寻找最小值，控制方差，更新模型参数，最终使模型收敛。\n网络更新参数的公式为：θ=θ−η×∇(θ).J(θ) ，其中η是学习率，∇(θ).J(θ)是损失函数J(θ)的梯度。\n这是在神经网络中最常用的优化算法。\n如今，梯度下降主要用于在神经网络模型中进行权重更新，即在一个方向上更新和调整模型的参数，来最小化损失函数。\n2006年引入的反向传播技术，使得训练深层神经网络成为可能。反向传播技术是先在前向传播中计算输入信号的乘积及其对应的权重，然后将激活函数作用于这些乘积的总和。这种将输入信号转换为输出信号的方式，是一种对复杂非线性函数进行建模的重要手段，并引入了非线性激活函数，使得模型能够学习到几乎任意形式的函数映射。然后，在网络的反向传播过程中回传相关误差，使用梯度下降更新权重值，通过计算误差函数E相对于权重参数W的梯度，在损失函数梯度的相反方向上更新权重参数。\n**图1：**权重更新方向与梯度方向相反 图1显示了权重更新过程与梯度矢量误差的方向相反，其中U形曲线为梯度。要注意到，当权重值W太小或太大时，会存在较大的误差，需要更新和优化权重，使其转化为合适值，所以我们试图在与梯度相反的方向找到一个局部最优值。\n梯度下降的变体 传统的批量梯度下降将计算整个数据集梯度，但只会进行一次更新，因此在处理大型数据集时速度很慢且难以控制，甚至导致内存溢出。\n权重更新的快慢是由学习率η决定的，并且可以在凸面误差曲面中收敛到全局最优值，在非凸曲面中可能趋于局部最优值。\n使用标准形式的批量梯度下降还有一个问题，就是在训练大型数据集时存在冗余的权重更新。\n标准梯度下降的上述问题在随机梯度下降方法中得到了解决。\n1. 随机梯度下降(SDG)\n随机梯度下降（Stochastic gradient descent，SGD）对每个训练样本进行参数更新，每次执行都进行一次更新，且执行速度更快。\nθ=θ−η⋅∇(θ) × J(θ;x(i);y(i))，其中x(i)和y(i)为训练样本。\n频繁的更新使得参数间具有高方差，损失函数会以不同的强度波动。这实际上是一件好事，因为它有助于我们发现新的和可能更优的局部最小值，而标准梯度下降将只会收敛到某个局部最优值。\n但SGD的问题是，由于频繁的更新和波动，最终将收敛到最小限度，并会因波动频繁存在超调量。\n虽然已经表明，当缓慢降低学习率η时，标准梯度下降的收敛模式与SGD的模式相同。\n**图2：**每个训练样本中高方差的参数更新会导致损失函数大幅波动，因此我们可能无法获得给出损失函数的最小值。 另一种称为“小批量梯度下降”的变体，则可以解决高方差的参数更新和不稳定收敛的问题。\n2. 小批量梯度下降\n为了避免SGD和标准梯度下降中存在的问题，一个改进方法为小批量梯度下降（Mini Batch Gradient Descent），因为对每个批次中的n个训练样本，这种方法只执行一次更新。\n使用小批量梯度下降的优点是：\n1) 可以减少参数更新的波动，最终得到效果更好和更稳定的收敛。\n2) 还可以使用最新的深层学习库中通用的矩阵优化方法，使计算小批量数据的梯度更加高效。\n3) 通常来说，小批量样本的大小范围是从50到256，可以根据实际问题而有所不同。\n4) 在训练神经网络时，通常都会选择小批量梯度下降算法。\n这种方法有时候还是被成为SGD。\n使用梯度下降及其变体时面临的挑战 1. 很难选择出合适的学习率。太小的学习率会导致网络收敛过于缓慢，而学习率太大可能会影响收敛，并导致损失函数在最小值上波动，甚至出现梯度发散。\n2. 此外，相同的学习率并不适用于所有的参数更新。如果训练集数据很稀疏，且特征频率非常不同，则不应该将其全部更新到相同的程度，但是对于很少出现的特征，应使用更大的更新率。\n3. 在神经网络中，最小化非凸误差函数的另一个关键挑战是避免陷于多个其他局部最小值中。实际上，问题并非源于局部极小值，而是来自鞍点，即一个维度向上倾斜且另一维度向下倾斜的点。这些鞍点通常被相同误差值的平面所包围，这使得SGD算法很难脱离出来，因为梯度在所有维度上接近于零。\n进一步优化梯度下降 现在我们要讨论用于进一步优化梯度下降的各种算法。\n1. 动量\nSGD方法中的高方差振荡使得网络很难稳定收敛，所以有研究者提出了一种称为动量（Momentum）的技术，通过优化相关方向的训练和弱化无关方向的振荡，来加速SGD训练。换句话说，这种新方法将上个步骤中更新向量的分量’γ’添加到当前更新向量。\nV(t)=γV(t−1)+η∇(θ).J(θ)\n最后通过θ=θ−V(t)来更新参数。\n动量项γ通常设定为0.9，或相近的某个值。\n这里的动量与经典物理学中的动量是一致的，就像从山上投出一个球，在下落过程中收集动量，小球的速度不断增加。\n在参数更新过程中，其原理类似：\n1) 使网络能更优和更稳定的收敛；\n2) 减少振荡过程。\n当其梯度指向实际移动方向时，动量项γ增大；当梯度与实际移动方向相反时，γ减小。这种方式意味着动量项只对相关样本进行参数更新，减少了不必要的参数更新，从而得到更快且稳定的收敛，也减少了振荡过程。\n2. Nesterov梯度加速法\n一位名叫Yurii Nesterov研究员，认为动量方法存在一个问题：\n如果一个滚下山坡的球，盲目沿着斜坡下滑，这是非常不合适的。一个更聪明的球应该要注意到它将要去哪，因此在上坡再次向上倾斜时小球应该进行减速。\n实际上，当小球达到曲线上的最低点时，动量相当高。由于高动量可能会导致其完全地错过最小值，因此小球不知道何时进行减速，故继续向上移动。\nYurii Nesterov在1983年发表了一篇关于解决动量问题的论文，因此，我们把这种方法叫做Nestrov梯度加速法。\n在该方法中，他提出先根据之前的动量进行大步跳跃，然后计算梯度进行校正，从而实现参数更新。这种预更新方法能防止大幅振荡，不会错过最小值，并对参数更新更加敏感。\nNesterov梯度加速法（NAG）是一种赋予了动量项预知能力的方法，通过使用动量项γV(t−1)来更改参数θ。通过计算θ−γV(t−1)，得到下一位置的参数近似值，这里的参数是一个粗略的概念。因此，我们不是通过计算当前参数θ的梯度值，而是通过相关参数的大致未来位置，来有效地预知未来：\nV(t)=γV(t−1)+η∇(θ)J( θ−γV(t−1) )，然后使用θ=θ−V(t)来更新参数。\n现在，我们通过使网络更新与误差函数的斜率相适应，并依次加速SGD，也可根据每个参数的重要性来调整和更新对应参数，以执行更大或更小的更新幅度。\n3. Adagrad方法\nAdagrad方法是通过参数来调整合适的学习率η，对稀疏参数进行大幅更新和对频繁参数进行小幅更新。因此，Adagrad方法非常适合处理稀疏数据。\n在时间步长中，Adagrad方法基于每个参数计算的过往梯度，为不同参数θ设置不同的学习率。\n先前，每个参数θ(i)使用相同的学习率，每次会对所有参数θ进行更新。在每个时间步t中，Adagrad方法为每个参数θ选取不同的学习率，更新对应参数，然后进行向量化。为了简单起见，我们把在t时刻参数θ(i)的损失函数梯度设为g(t,i)。\n**图3：**参数更新公式 Adagrad方法是在每个时间步中，根据过往已计算的参数梯度，来为每个参数θ(i)修改对应的学习率η。\nAdagrad方法的主要好处是，不需要手工来调整学习率。大多数参数使用了默认值0.01，且保持不变。\nAdagrad方法的主要缺点是，学习率η总是在降低和衰减。\n因为每个附加项都是正的，在分母中累积了多个平方梯度值，故累积的总和在训练期间保持增长。这反过来又导致学习率下降，变为很小数量级的数字，该模型完全停止学习，停止获取新的额外知识。\n因为随着学习速度的越来越小，模型的学习能力迅速降低，而且收敛速度非常慢，需要很长的训练和学习，即学习速度降低。\n另一个叫做Adadelta的算法改善了这个学习率不断衰减的问题。\n4. AdaDelta方法\n这是一个AdaGrad的延伸方法，它倾向于解决其学习率衰减的问题。Adadelta不是累积所有之前的平方梯度，而是将累积之前梯度的窗口限制到某个固定大小w。\n与之前无效地存储w先前的平方梯度不同，梯度的和被递归地定义为所有先前平方梯度的衰减平均值。作为与动量项相似的分数γ，在t时刻的滑动平均值Eg²仅仅取决于先前的平均值和当前梯度值。\nEg²=γ.Eg²+(1−γ).g²(t)，其中γ设置为与动量项相近的值，约为0.9。\nΔθ(t)=−η⋅g(t,i).\nθ(t+1)=θ(t)+Δθ(t)\n**图4：**参数更新的最终公式 AdaDelta方法的另一个优点是，已经不需要设置一个默认的学习率。\n目前已完成的改进 1) 为每个参数计算出不同学习率；\n2) 也计算了动量项momentum；\n3) 防止学习率衰减或梯度消失等问题的出现。\n还可以做什么改进？ 在之前的方法中计算了每个参数的对应学习率，但是为什么不计算每个参数的对应动量变化并独立存储呢？这就是Adam算法提出的改良点。\nAdam算法\nAdam算法即自适应时刻估计方法（Adaptive Moment Estimation），能计算每个参数的自适应学习率。这个方法不仅存储了AdaDelta先前平方梯度的指数衰减平均值，而且保持了先前梯度M(t)的指数衰减平均值，这一点与动量类似：\nM(t)为梯度的第一时刻平均值，V(t)为梯度的第二时刻非中心方差值。\n**图5：**两个公式分别为梯度的第一个时刻平均值和第二个时刻方差 则参数更新的最终公式为：\n**图6：**参数更新的最终公式 其中，β1设为0.9，β2设为0.9999，ϵ设为10-8。\n在实际应用中，Adam方法效果良好。与其他自适应学习率算法相比，其收敛速度更快，学习效果更为有效，而且可以纠正其他优化技术中存在的问题，如学习率消失、收敛过慢或是高方差的参数更新导致损失函数波动较大等问题。\n对优化算法进行可视化\n**图8：**对鞍点进行SGD优化 从上面的动画可以看出，自适应算法能很快收敛，并快速找到参数更新中正确的目标方向；而标准的SGD、NAG和动量项等方法收敛缓慢，且很难找到正确的方向。\n结论 我们应该使用哪种优化器？\n在构建神经网络模型时，选择出最佳的优化器，以便快速收敛并正确学习，同时调整内部参数，最大程度地最小化损失函数。\nAdam在实际应用中效果良好，超过了其他的自适应技术。\n**如果输入数据集比较稀疏，SGD、NAG和动量项等方法可能效果不好。**因此对于稀疏数据集，应该使用某种自适应学习率的方法，且另一好处为不需要人为调整学习率，使用默认参数就可能获得最优值。\n如果想使训练深层网络模型快速收敛或所构建的神经网络较为复杂，则应该使用Adam或其他自适应学习速率的方法，因为这些方法的实际效果更优。\n希望你能通过这篇文章，很好地理解不同优化算法间的特性差异。\n相关链接： 二阶优化算法： https://web.stanford.edu/class/msande311/lecture13.pdf\nNesterov梯度加速法：http://cs231n.github.io/neural-networks-3/\n","wordCount":"5252","inLanguage":"en","datePublished":"2023-03-16T19:35:22+08:00","dateModified":"2023-03-16T19:35:22+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/ml/>机器学习，深度学习，知识图谱相关</a></div><h1 class=post-title>机器学习之优化算法</h1><div class=post-description>机器学习之优化算法</div><div class=post-meta></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e4%bc%98%e5%8c%96%e7%ae%97%e6%b3%95 aria-label=什么是优化算法？>什么是优化算法？</a></li><li><a href=#%e8%af%a6%e8%a7%a3%e5%90%84%e7%a7%8d%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e4%bc%98%e5%8c%96%e7%ae%97%e6%b3%95 aria-label=详解各种神经网络优化算法>详解各种神经网络优化算法</a><ul><li><a href=#%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8d aria-label=梯度下降>梯度下降</a><ul><ul><ul><ul><li><a href=#%e5%9b%be1%e6%9d%83%e9%87%8d%e6%9b%b4%e6%96%b0%e6%96%b9%e5%90%91%e4%b8%8e%e6%a2%af%e5%ba%a6%e6%96%b9%e5%90%91%e7%9b%b8%e5%8f%8d aria-label=**图1：**权重更新方向与梯度方向相反>**图1：**权重更新方向与梯度方向相反</a></li></ul></ul></ul></ul></li><li><a href=#%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8d%e7%9a%84%e5%8f%98%e4%bd%93 aria-label=梯度下降的变体>梯度下降的变体</a><ul><ul><ul><ul><li><a href=#%e5%9b%be2%e6%af%8f%e4%b8%aa%e8%ae%ad%e7%bb%83%e6%a0%b7%e6%9c%ac%e4%b8%ad%e9%ab%98%e6%96%b9%e5%b7%ae%e7%9a%84%e5%8f%82%e6%95%b0%e6%9b%b4%e6%96%b0%e4%bc%9a%e5%af%bc%e8%87%b4%e6%8d%9f%e5%a4%b1%e5%87%bd%e6%95%b0%e5%a4%a7%e5%b9%85%e6%b3%a2%e5%8a%a8%e5%9b%a0%e6%ad%a4%e6%88%91%e4%bb%ac%e5%8f%af%e8%83%bd%e6%97%a0%e6%b3%95%e8%8e%b7%e5%be%97%e7%bb%99%e5%87%ba%e6%8d%9f%e5%a4%b1%e5%87%bd%e6%95%b0%e7%9a%84%e6%9c%80%e5%b0%8f%e5%80%bc aria-label=**图2：**每个训练样本中高方差的参数更新会导致损失函数大幅波动，因此我们可能无法获得给出损失函数的最小值。>**图2：**每个训练样本中高方差的参数更新会导致损失函数大幅波动，因此我们可能无法获得给出损失函数的最小值。</a></li></ul></ul></ul></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8d%e5%8f%8a%e5%85%b6%e5%8f%98%e4%bd%93%e6%97%b6%e9%9d%a2%e4%b8%b4%e7%9a%84%e6%8c%91%e6%88%98 aria-label=使用梯度下降及其变体时面临的挑战>使用梯度下降及其变体时面临的挑战</a></li><li><a href=#%e8%bf%9b%e4%b8%80%e6%ad%a5%e4%bc%98%e5%8c%96%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8d aria-label=进一步优化梯度下降>进一步优化梯度下降</a><ul><ul><ul><ul><li><a href=#%e5%9b%be3%e5%8f%82%e6%95%b0%e6%9b%b4%e6%96%b0%e5%85%ac%e5%bc%8f aria-label=**图3：**参数更新公式>**图3：**参数更新公式</a></li><li><a href=#%e5%9b%be4%e5%8f%82%e6%95%b0%e6%9b%b4%e6%96%b0%e7%9a%84%e6%9c%80%e7%bb%88%e5%85%ac%e5%bc%8f aria-label=**图4：**参数更新的最终公式>**图4：**参数更新的最终公式</a></li></ul></ul></ul></ul></li><li><a href=#%e7%9b%ae%e5%89%8d%e5%b7%b2%e5%ae%8c%e6%88%90%e7%9a%84%e6%94%b9%e8%bf%9b aria-label=目前已完成的改进>目前已完成的改进</a></li><li><a href=#%e8%bf%98%e5%8f%af%e4%bb%a5%e5%81%9a%e4%bb%80%e4%b9%88%e6%94%b9%e8%bf%9b aria-label=还可以做什么改进？>还可以做什么改进？</a><ul><ul><ul><ul><li><a href=#%e5%9b%be5%e4%b8%a4%e4%b8%aa%e5%85%ac%e5%bc%8f%e5%88%86%e5%88%ab%e4%b8%ba%e6%a2%af%e5%ba%a6%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e6%97%b6%e5%88%bb%e5%b9%b3%e5%9d%87%e5%80%bc%e5%92%8c%e7%ac%ac%e4%ba%8c%e4%b8%aa%e6%97%b6%e5%88%bb%e6%96%b9%e5%b7%ae aria-label=**图5：**两个公式分别为梯度的第一个时刻平均值和第二个时刻方差>**图5：**两个公式分别为梯度的第一个时刻平均值和第二个时刻方差</a></li><li><a href=#%e5%9b%be6%e5%8f%82%e6%95%b0%e6%9b%b4%e6%96%b0%e7%9a%84%e6%9c%80%e7%bb%88%e5%85%ac%e5%bc%8f aria-label=**图6：**参数更新的最终公式>**图6：**参数更新的最终公式</a></li><li><a href=#%e5%9b%be8%e5%af%b9%e9%9e%8d%e7%82%b9%e8%bf%9b%e8%a1%8csgd%e4%bc%98%e5%8c%96 aria-label=**图8：**对鞍点进行SGD优化>**图8：**对鞍点进行SGD优化</a></li></ul></ul></ul></ul></li></ul></li><li><a href=#%e7%bb%93%e8%ae%ba aria-label=结论>结论</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e9%93%be%e6%8e%a5 aria-label=相关链接：>相关链接：</a></li></ul></div></details></div><div class=post-content><p>在调整模型更新权重和偏差参数的方式时，你是否考虑过哪种优化算法能使模型产生更好且更快的效果？应该用梯度下降，随机梯度下降，还是Adam方法？</p><p>这篇文章介绍了不同优化算法之间的主要区别，以及如何选择最佳的优化方法。</p><blockquote><p>梯度: 是多元函数对当前给定点，上升最快的方向。梯度是一组向量，所以带有方向;</p><p>梯度下降流程: <a href=https://zhuanlan.zhihu.com/p/68468520>https://zhuanlan.zhihu.com/p/68468520</a> w, b 每轮是每个样本的权重梯度向量和偏差梯度向量的平均值；</p><p>梯度下降本质是沿着负梯度值方向寻找损失函数Loss的最小值解 时的参数w,b , 从而得出对样本数据拟合最好的参数w,b。 <a href=https://www.jianshu.com/p/c7e642877b0e>https://www.jianshu.com/p/c7e642877b0e</a></p></blockquote><h1 id=什么是优化算法>什么是优化算法？<a hidden class=anchor aria-hidden=true href=#什么是优化算法>#</a></h1><p>优化算法的功能，是通过改善训练方式，来最小化(或最大化)损失函数E(x)。</p><p>模型内部有些参数，是用来计算测试集中目标值Y的真实值和预测值的偏差程度的，基于这些参数，就形成了损失函数E(x)。</p><p>比如说，权重(W)和偏差(b)就是这样的内部参数，一般用于计算输出值，在训练神经网络模型时起到主要作用。</p><p>**在有效地训练模型并产生准确结果时，模型的内部参数起到了非常重要的作用。**这也是为什么我们应该用各种优化策略和算法，来更新和计算影响模型训练和模型输出的网络参数，使其逼近或达到最优值。</p><p><strong>优化算法分为两大类：</strong></p><p><strong>1. 一阶优化算法</strong></p><p>这种算法使用各参数的梯度值来最小化或最大化损失函数E(x)。<strong>最常用的一阶优化算法是梯度下降。</strong></p><p>函数梯度：导数dy/dx的多变量表达式，用来表示y相对于x的瞬时变化率。往往为了计算多变量函数的导数时，会用梯度取代导数，并使用偏导数来计算梯度。梯度和导数之间的一个主要区别是函数的梯度形成了一个向量场。</p><p>因此，对单变量函数，使用导数来分析；而梯度是基于多变量函数而产生的。更多理论细节在这里不再进行详细解释。</p><p><strong>2. 二阶优化算法</strong></p><p>二阶优化算法使用了二阶导数(也叫做<strong>Hessian方法</strong>)来最小化或最大化损失函数。由于二阶导数的计算成本很高，所以这种方法并没有广泛使用。</p><h1 id=详解各种神经网络优化算法>详解各种神经网络优化算法<a hidden class=anchor aria-hidden=true href=#详解各种神经网络优化算法>#</a></h1><h2 id=梯度下降>梯度下降<a hidden class=anchor aria-hidden=true href=#梯度下降>#</a></h2><p>在训练和优化智能系统时，梯度下降是一种最重要的技术和基础。梯度下降的功能是：</p><blockquote><p>通过寻找最小值，控制方差，更新模型参数，最终使模型收敛。</p></blockquote><p>网络更新参数的公式为：θ=θ−η×∇(θ).J(θ) ，其中η是学习率，∇(θ).J(θ)是损失函数J(θ)的梯度。</p><p>这是在神经网络中最常用的优化算法。</p><p>如今，梯度下降主要用于在神经网络模型中进行权重更新，即在一个方向上更新和调整模型的参数，来最小化损失函数。</p><p>2006年引入的反向传播技术，使得训练深层神经网络成为可能。反向传播技术是先在前向传播中计算输入信号的乘积及其对应的权重，然后将激活函数作用于这些乘积的总和。这种将输入信号转换为输出信号的方式，是一种对复杂非线性函数进行建模的重要手段，并引入了非线性激活函数，使得模型能够学习到几乎任意形式的函数映射。然后，在网络的反向传播过程中回传相关误差，使用梯度下降更新权重值，通过计算误差函数E相对于权重参数W的梯度，在损失函数梯度的相反方向上更新权重参数。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtB6zUnEhyibO3XJk6N5DqrmaVSGibibBx12WcumRgxJz95rrXHpmtFJoTjL5GRUFmTfKfMHT4zWL9wPw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><h6 id=图1权重更新方向与梯度方向相反>**图1：**权重更新方向与梯度方向相反<a hidden class=anchor aria-hidden=true href=#图1权重更新方向与梯度方向相反>#</a></h6><p>图1显示了权重更新过程与梯度矢量误差的方向相反，其中U形曲线为梯度。要注意到，当权重值W太小或太大时，会存在较大的误差，需要更新和优化权重，使其转化为合适值，所以我们试图在与梯度相反的方向找到一个局部最优值。</p><h2 id=梯度下降的变体>梯度下降的变体<a hidden class=anchor aria-hidden=true href=#梯度下降的变体>#</a></h2><p>传统的批量梯度下降将计算整个数据集梯度，但只会进行一次更新，因此在处理大型数据集时速度很慢且难以控制，甚至导致内存溢出。</p><p>权重更新的快慢是由学习率η决定的，并且可以在凸面误差曲面中收敛到全局最优值，在非凸曲面中可能趋于局部最优值。</p><p>使用标准形式的批量梯度下降还有一个问题，就是在训练大型数据集时存在冗余的权重更新。</p><p>标准梯度下降的上述问题在随机梯度下降方法中得到了解决。</p><p><strong>1. 随机梯度下降(SDG)</strong></p><p>随机梯度下降（Stochastic gradient descent，SGD）对每个训练样本进行参数更新，每次执行都进行一次更新，且执行速度更快。</p><p>θ=θ−η⋅∇(θ) × J(θ;x(i);y(i))，其中x(i)和y(i)为训练样本。</p><p>频繁的更新使得参数间具有高方差，损失函数会以不同的强度波动。这实际上是一件好事，因为它有助于我们发现新的和可能更优的局部最小值，而标准梯度下降将只会收敛到某个局部最优值。</p><p>但SGD的问题是，由于频繁的更新和波动，最终将收敛到最小限度，并会因波动频繁存在超调量。</p><p>虽然已经表明，当缓慢降低学习率η时，标准梯度下降的收敛模式与SGD的模式相同。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtB6zUnEhyibO3XJk6N5DqrmahcNYXib4j1Cn7HI5nR6xriar5Rb7LdN9xdKzYId5ob1Sdr7YZkST0Mjw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><h6 id=图2每个训练样本中高方差的参数更新会导致损失函数大幅波动因此我们可能无法获得给出损失函数的最小值>**图2：**每个训练样本中高方差的参数更新会导致损失函数大幅波动，因此我们可能无法获得给出损失函数的最小值。<a hidden class=anchor aria-hidden=true href=#图2每个训练样本中高方差的参数更新会导致损失函数大幅波动因此我们可能无法获得给出损失函数的最小值>#</a></h6><p>另一种称为“小批量梯度下降”的变体，则可以解决高方差的参数更新和不稳定收敛的问题。</p><p><strong>2. 小批量梯度下降</strong></p><p>为了避免SGD和标准梯度下降中存在的问题，一个改进方法为小批量梯度下降（Mini Batch Gradient Descent），因为对每个批次中的n个训练样本，这种方法只执行一次更新。</p><p><strong>使用小批量梯度下降的优点是：</strong></p><p><strong>1)</strong> 可以减少参数更新的波动，最终得到效果更好和更稳定的收敛。</p><p><strong>2)</strong> 还可以使用最新的深层学习库中通用的矩阵优化方法，使计算小批量数据的梯度更加高效。</p><p><strong>3)</strong> 通常来说，小批量样本的大小范围是从50到256，可以根据实际问题而有所不同。</p><p><strong>4)</strong> 在训练神经网络时，通常都会选择小批量梯度下降算法。</p><p>这种方法有时候还是被成为SGD。</p><h2 id=使用梯度下降及其变体时面临的挑战>使用梯度下降及其变体时面临的挑战<a hidden class=anchor aria-hidden=true href=#使用梯度下降及其变体时面临的挑战>#</a></h2><p><strong>1.</strong> 很难选择出合适的学习率。太小的学习率会导致网络收敛过于缓慢，而学习率太大可能会影响收敛，并导致损失函数在最小值上波动，甚至出现梯度发散。</p><p><strong>2.</strong> 此外，相同的学习率并不适用于所有的参数更新。如果训练集数据很稀疏，且特征频率非常不同，则不应该将其全部更新到相同的程度，但是对于很少出现的特征，应使用更大的更新率。</p><p><strong>3.</strong> 在神经网络中，最小化非凸误差函数的另一个关键挑战是避免陷于多个其他局部最小值中。实际上，问题并非源于局部极小值，而是来自鞍点，即一个维度向上倾斜且另一维度向下倾斜的点。这些鞍点通常被相同误差值的平面所包围，这使得SGD算法很难脱离出来，因为梯度在所有维度上接近于零。</p><h2 id=进一步优化梯度下降>进一步优化梯度下降<a hidden class=anchor aria-hidden=true href=#进一步优化梯度下降>#</a></h2><p>现在我们要讨论用于进一步优化梯度下降的各种算法。</p><p><strong>1. 动量</strong></p><p>SGD方法中的高方差振荡使得网络很难稳定收敛，所以有研究者提出了一种称为动量（Momentum）的技术，<strong>通过优化相关方向的训练和弱化无关方向的振荡，来加速SGD训练</strong>。换句话说，这种新方法将上个步骤中更新向量的分量’γ’添加到当前更新向量。</p><p>V(t)=γV(t−1)+η∇(θ).J(θ)</p><p>最后通过θ=θ−V(t)来更新参数。</p><p>动量项γ通常设定为0.9，或相近的某个值。</p><p>这里的动量与经典物理学中的动量是一致的，就像从山上投出一个球，在下落过程中收集动量，小球的速度不断增加。</p><p>在参数更新过程中，其原理类似：</p><p><strong>1)</strong> 使网络能更优和更稳定的收敛；</p><p><strong>2)</strong> 减少振荡过程。</p><p>当其梯度指向实际移动方向时，动量项γ增大；当梯度与实际移动方向相反时，γ减小。这种方式意味着动量项只对相关样本进行参数更新，减少了不必要的参数更新，从而得到更快且稳定的收敛，也减少了振荡过程。</p><p><strong>2. Nesterov梯度加速法</strong></p><p>一位名叫Yurii Nesterov研究员，认为动量方法存在一个问题：</p><p>如果一个滚下山坡的球，盲目沿着斜坡下滑，这是非常不合适的。一个更聪明的球应该要注意到它将要去哪，因此在上坡再次向上倾斜时小球应该进行减速。</p><p>实际上，当小球达到曲线上的最低点时，动量相当高。由于高动量可能会导致其完全地错过最小值，因此小球不知道何时进行减速，故继续向上移动。</p><p>Yurii Nesterov在1983年发表了一篇关于解决动量问题的论文，因此，我们把这种方法叫做Nestrov梯度加速法。</p><p><strong>在该方法中，他提出先根据之前的动量进行大步跳跃，然后计算梯度进行校正，从而实现参数更新。这种预更新方法能防止大幅振荡，不会错过最小值，并对参数更新更加敏感。</strong></p><p>Nesterov梯度加速法（NAG）是一种赋予了动量项预知能力的方法，通过使用动量项γV(t−1)来更改参数θ。通过计算θ−γV(t−1)，得到下一位置的参数近似值，这里的参数是一个粗略的概念。因此，<strong>我们不是通过计算当前参数θ的梯度值，而是通过相关参数的大致未来位置，来有效地预知未来</strong>：</p><p>V(t)=γV(t−1)+η∇(θ)J( θ−γV(t−1) )，然后使用θ=θ−V(t)来更新参数。</p><p>现在，我们通过使网络更新与误差函数的斜率相适应，并依次加速SGD，也可根据每个参数的重要性来调整和更新对应参数，以执行更大或更小的更新幅度。</p><p><strong>3. Adagrad方法</strong></p><p>Adagrad方法是通过参数来调整合适的学习率η，对稀疏参数进行大幅更新和对频繁参数进行小幅更新。因此，Adagrad方法非常适合处理稀疏数据。</p><p><strong>在时间步长中，Adagrad方法基于每个参数计算的过往梯度，为不同参数θ设置不同的学习率。</strong></p><p>先前，每个参数θ(i)使用相同的学习率，每次会对所有参数θ进行更新。在每个时间步t中，Adagrad方法为每个参数θ选取不同的学习率，更新对应参数，然后进行向量化。为了简单起见，我们把在t时刻参数θ(i)的损失函数梯度设为g(t,i)。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtB6zUnEhyibO3XJk6N5Dqrma2lwfpeJdic6hfaY0vJzEWap9VE9rXT9fe5dVE0W1G58gXvO3HrZQdjg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><h6 id=图3参数更新公式>**图3：**参数更新公式<a hidden class=anchor aria-hidden=true href=#图3参数更新公式>#</a></h6><p>Adagrad方法是在每个时间步中，根据过往已计算的参数梯度，来为每个参数θ(i)修改对应的学习率η。</p><p>Adagrad方法的主要好处是，不需要手工来调整学习率。大多数参数使用了默认值0.01，且保持不变。</p><p>Adagrad方法的主要缺点是，学习率η总是在降低和衰减。</p><p>因为每个附加项都是正的，在分母中累积了多个平方梯度值，故累积的总和在训练期间保持增长。这反过来又导致学习率下降，变为很小数量级的数字，该模型完全停止学习，停止获取新的额外知识。</p><p>因为随着学习速度的越来越小，模型的学习能力迅速降低，而且收敛速度非常慢，需要很长的训练和学习，即<strong>学习速度降低</strong>。</p><p>另一个叫做Adadelta的算法改善了这个学习率不断衰减的问题。</p><p><strong>4. AdaDelta方法</strong></p><p>这是一个AdaGrad的延伸方法，它倾向于解决其学习率衰减的问题。Adadelta不是累积所有之前的平方梯度，而是将累积之前梯度的窗口限制到某个固定大小w。</p><p>与之前无效地存储w先前的平方梯度不同，梯度的和被递归地定义为所有先前平方梯度的衰减平均值。作为与动量项相似的分数γ，在t时刻的滑动平均值Eg²仅仅取决于先前的平均值和当前梯度值。</p><p>Eg²=γ.Eg²+(1−γ).g²(t)，其中γ设置为与动量项相近的值，约为0.9。</p><p>Δθ(t)=−η⋅g(t,i).</p><p>θ(t+1)=θ(t)+Δθ(t)</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtB6zUnEhyibO3XJk6N5Dqrma9fTFlURibKPA4REq9iafVwzrvOoytb0xmntLH3JSFUn2t6zPrXQjsU0A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><h6 id=图4参数更新的最终公式>**图4：**参数更新的最终公式<a hidden class=anchor aria-hidden=true href=#图4参数更新的最终公式>#</a></h6><p>AdaDelta方法的另一个优点是，已经不需要设置一个默认的学习率。</p><h2 id=目前已完成的改进>目前已完成的改进<a hidden class=anchor aria-hidden=true href=#目前已完成的改进>#</a></h2><p><strong>1)</strong> 为每个参数计算出不同学习率；</p><p><strong>2)</strong> 也计算了动量项momentum；</p><p><strong>3)</strong> 防止<strong>学习率衰减或梯度消失</strong>等问题的出现。</p><h2 id=还可以做什么改进>还可以做什么改进？<a hidden class=anchor aria-hidden=true href=#还可以做什么改进>#</a></h2><p>在之前的方法中计算了每个参数的对应学习率，但是为什么不计算每个参数的对应动量变化并独立存储呢？这就是Adam算法提出的改良点。</p><p><strong>Adam算法</strong></p><p>Adam算法<strong>即自适应时刻估计方法（Adaptive Moment Estimation）</strong>，能计算每个参数的自适应学习率。这个方法不仅存储了AdaDelta先前平方梯度的指数衰减平均值，而且保持了先前梯度M(t)的指数衰减平均值，这一点与动量类似：</p><p>M(t)为梯度的第一时刻平均值，V(t)为梯度的第二时刻非中心方差值。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtB6zUnEhyibO3XJk6N5Dqrmadicibibvp3ejofTiconQ4k2Jefxho1KscYw2jt6qShibDXapiaUfYibcCE3hw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><h6 id=图5两个公式分别为梯度的第一个时刻平均值和第二个时刻方差>**图5：**两个公式分别为梯度的第一个时刻平均值和第二个时刻方差<a hidden class=anchor aria-hidden=true href=#图5两个公式分别为梯度的第一个时刻平均值和第二个时刻方差>#</a></h6><p>则参数更新的最终公式为：</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtB6zUnEhyibO3XJk6N5DqrmaKdWCB5iaAO7W97PjB6XUkeNMTY4uI76qehH0icKxdlicjmXIgj4bjv2fg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><h6 id=图6参数更新的最终公式>**图6：**参数更新的最终公式<a hidden class=anchor aria-hidden=true href=#图6参数更新的最终公式>#</a></h6><p>其中，β1设为0.9，β2设为0.9999，ϵ设为10-8。</p><p>在实际应用中，Adam方法效果良好。与其他自适应学习率算法相比，其收敛速度更快，学习效果更为有效，而且可以纠正其他优化技术中存在的问题，如学习率消失、收敛过慢或是高方差的参数更新导致损失函数波动较大等问题。</p><p><strong>对优化算法进行可视化</strong></p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_gif/YicUhk5aAGtB6zUnEhyibO3XJk6N5DqrmaqvK2Pl9ds2GG1EwGt2jiciaPCoLgl1oNaPJCGFtia9OR2iaalIpnMQuVSQ/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=img></p><h6 id=图8对鞍点进行sgd优化>**图8：**对鞍点进行SGD优化<a hidden class=anchor aria-hidden=true href=#图8对鞍点进行sgd优化>#</a></h6><p>从上面的动画可以看出，自适应算法能很快收敛，并快速找到参数更新中正确的目标方向；而标准的SGD、NAG和动量项等方法收敛缓慢，且很难找到正确的方向。</p><h1 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h1><p>我们应该使用哪种优化器？</p><p>在构建神经网络模型时，选择出最佳的优化器，以便快速收敛并正确学习，同时调整内部参数，最大程度地最小化损失函数。</p><p>Adam在实际应用中效果良好，超过了其他的自适应技术。</p><p>**如果输入数据集比较稀疏，SGD、NAG和动量项等方法可能效果不好。**因此对于稀疏数据集，应该使用某种自适应学习率的方法，且另一好处为不需要人为调整学习率，使用默认参数就可能获得最优值。</p><p><strong>如果想使训练深层网络模型快速收敛或所构建的神经网络较为复杂，则应该使用Adam或其他自适应学习速率的方法</strong>，因为这些方法的实际效果更优。</p><p>希望你能通过这篇文章，很好地理解不同优化算法间的特性差异。</p><h1 id=相关链接>相关链接：<a hidden class=anchor aria-hidden=true href=#相关链接>#</a></h1><p>二阶优化算法：
<a href=https://web.stanford.edu/class/msande311/lecture13.pdf>https://web.stanford.edu/class/msande311/lecture13.pdf</a></p><p>Nesterov梯度加速法：http://cs231n.github.io/neural-networks-3/</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/%E4%BC%98%E5%8C%96/>优化</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/ml/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/><span class=title>« Prev</span><br><span>朴素贝叶斯</span>
</a><a class=next href=https://reid00.github.io/en/posts/ml/%E5%B8%B8%E8%A7%81%E8%B7%9D%E7%A6%BB%E7%9A%84%E4%BB%8B%E7%BB%8D/><span class=title>Next »</span><br><span>常见距离的介绍</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>