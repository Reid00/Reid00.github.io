<!doctype html><html lang=en dir=auto><head><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/computation/>计算相关的记录，如Spark Flink 等</a></div><h1 class=post-title>Spark 广播变量</h1><div class=post-description>Spark 广播变量</div><div class=post-meta><span title='2023-03-16 19:34:50 +0800 +0800'>2023-03-16 19:34</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;105 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%b9%bf%e6%92%ad%e5%8f%98%e9%87%8f aria-label=为什么需要广播变量>为什么需要广播变量</a><ul><li><a href=#%e5%9b%be%e8%a7%a3%e5%b9%bf%e6%92%ad%e5%8f%98%e9%87%8f aria-label=图解广播变量>图解广播变量</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e5%b9%bf%e6%92%ad%e5%8f%98%e9%87%8f aria-label=如何定义广播变量>如何定义广播变量</a></li><li><a href=#%e6%b3%a8%e6%84%8f%e7%82%b9 aria-label=注意点>注意点</a></li></ul></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%b4%af%e5%8a%a0%e5%99%a8 aria-label=为什么需要累加器>为什么需要累加器</a><ul><li><a href=#%e5%9b%be%e8%a7%a3%e7%b4%af%e5%8a%a0%e5%99%a8 aria-label=图解累加器>图解累加器</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e7%b4%af%e5%8a%a0%e5%99%a8 aria-label=如何定义一个累加器？>如何定义一个累加器？</a></li><li><a href=#%e6%b3%a8%e6%84%8f%e7%82%b9-1 aria-label=注意点>注意点</a></li></ul></li><li><a href=#%e5%93%aa%e4%ba%9b%e5%8f%98%e9%87%8f%e5%9c%a8drive-%e7%ab%af%e5%93%aa%e4%ba%9b%e5%9c%a8executor-%e7%ab%af aria-label="哪些变量在Drive 端，哪些在Executor 端">哪些变量在Drive 端，哪些在Executor 端</a><ul><li><a href=#driver--executor aria-label="driver &amp;amp; executor">driver & executor</a></li><li><a href=#%e9%82%a3%e4%b9%88%e7%bc%96%e5%86%99%e7%9a%84spark%e7%a8%8b%e5%ba%8f%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e5%9c%a8driver%e7%ab%af%e8%bf%98%e6%98%afexecutor%e7%ab%af%e5%91%a2 aria-label=那么，编写的Spark程序代码，运行在driver端还是executor端呢？>那么，编写的Spark程序代码，运行在driver端还是executor端呢？</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h1><p>在spark程序中，当一个传递给Spark操作(例如map和reduce)的函数在远程节点上面运行时，Spark操作实际上操作的是这个函数所用变量的一个独立副本。这些变量会被复制到每台机器上，并且这些变量在远程机器上的所有更新都不会传递回驱动程序。通常跨任务的读写变量是低效的，但是，Spark还是为两种常见的使用模式提供了两种有限的共享变量：广播变（broadcast variable）和累加器（accumulator）</p><h1 id=为什么需要广播变量>为什么需要广播变量<a hidden class=anchor aria-hidden=true href=#为什么需要广播变量>#</a></h1><p>如果我们要在分布式计算里面分发大对象，例如：字典，集合，黑白名单等，这个都会由Driver端进行分发，一般来讲，如果这个变量不是广播变量，那么每个task就会分发一份，这在task数目十分多的情况下Driver的带宽会成为系统的瓶颈，而且会大量消耗task服务器上的资源，如果将这个变量声明为广播变量，那么知识每个executor拥有一份，这个executor启动的task会共享这个变量，节省了通信的成本和服务器的资源。</p><h2 id=图解广播变量>图解广播变量<a hidden class=anchor aria-hidden=true href=#图解广播变量>#</a></h2><p>不使用广播变量
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.3oek64ejio20.webp alt=not-use>
使用广播变量
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.5nmd6d2n5cg0.webp alt=use>
可知: 如果使用广播变量，一个executor 只有一个driver 变量的副本，节省资源，而不是用的话，同一个executor 的不同task 都会有这个变量的副本，网络IO就会成为瓶颈。</p><h2 id=如何定义广播变量>如何定义广播变量<a hidden class=anchor aria-hidden=true href=#如何定义广播变量>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>val <span class=nv>data</span> <span class=o>=</span> List<span class=o>(</span>1, 2, 3, 4, 5, 6<span class=o>)</span>
</span></span><span class=line><span class=cl>val <span class=nv>bdata</span> <span class=o>=</span> sc.broadcast<span class=o>(</span>data<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val <span class=nv>rdd</span> <span class=o>=</span> sc.parallelize<span class=o>(</span><span class=m>1</span> to 6, 2<span class=o>)</span>
</span></span><span class=line><span class=cl>val <span class=nv>observedSizes</span> <span class=o>=</span> rdd.map<span class=o>(</span><span class=nv>_</span> <span class=o>=</span>&gt; bdata.value.size<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>取 value
</span></span><span class=line><span class=cl>val <span class=nv>c</span> <span class=o>=</span> broadcast.value
</span></span></code></pre></td></tr></table></div></div><h2 id=注意点>注意点<a hidden class=anchor aria-hidden=true href=#注意点>#</a></h2><p>变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改</p><p>1、能不能将一个RDD使用广播变量广播出去？</p><ul><li>不能，因为RDD是不存储数据的。可以将RDD的结果广播出去。</li></ul><p>2、 广播变量只能在Driver端定义，不能在Executor端定义。</p><p>3、 在Driver端可以修改广播变量的值，在Executor端无法修改广播变量的值。</p><p>4、如果executor端用到了Driver的变量，如果不使用广播变量在Executor有多少task就有多少Driver端的变量副本。</p><p>5、如果Executor端用到了Driver的变量，如果使用广播变量在每个Executor中只有一份Driver端的变量副本。</p><h1 id=为什么需要累加器>为什么需要累加器<a hidden class=anchor aria-hidden=true href=#为什么需要累加器>#</a></h1><p>在spark应用程序中，我们经常会有这样的需求，如异常监控，调试，记录符合某特性的数据的数目，这种需求都需要用到计数器，如果一个变量不被声明为一个累加器，那么它将在被改变时不会再driver端进行全局汇总，即在分布式运行时每个task运行的只是原始变量的一个副本，并不能改变原始变量的值，但是当这个变量被声明为累加器后，该变量就会有分布式计数的功能。</p><h2 id=图解累加器>图解累加器<a hidden class=anchor aria-hidden=true href=#图解累加器>#</a></h2><p>不使用累加器
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.23g59129ajds.webp alt></p><p>使用累加器
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.3gn7uebrisu0.webp alt></p><h2 id=如何定义一个累加器>如何定义一个累加器？<a hidden class=anchor aria-hidden=true href=#如何定义一个累加器>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>val <span class=nv>a</span> <span class=o>=</span> sc.accumulator<span class=o>(</span>0<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>取值
</span></span><span class=line><span class=cl>val <span class=nv>b</span> <span class=o>=</span> a.value
</span></span></code></pre></td></tr></table></div></div><h2 id=注意点-1>注意点<a hidden class=anchor aria-hidden=true href=#注意点-1>#</a></h2><p>1、 累加器在Driver端定义赋初始值，累加器只能在Driver端读取最后的值，在Excutor端更新。</p><p>2、累加器不是一个调优的操作，因为如果不这样做，结果是错的</p><h1 id=哪些变量在drive-端哪些在executor-端>哪些变量在Drive 端，哪些在Executor 端<a hidden class=anchor aria-hidden=true href=#哪些变量在drive-端哪些在executor-端>#</a></h1><h2 id=driver--executor>driver & executor<a hidden class=anchor aria-hidden=true href=#driver--executor>#</a></h2><p>driver是运行用户编写Application 的main()函数的地方，具体负责DAG的构建、任务的划分、task的生成与调度等。job，stage，task生成都离不开rdd自身，rdd的相关的操作不能缺少driver端的sparksession/sparkcontext。</p><p>executor是真正执行task地方，而task执行离不开具体的数据，这些task运行的结果可以是shuffle中间结果，也可以持久化到外部存储系统。一般都是将结果、状态等汇集到driver。但是，目前executor之间不能互相通信，只能借助第三方来实现数据的共享或者通信。</p><h2 id=那么编写的spark程序代码运行在driver端还是executor端呢>那么，编写的Spark程序代码，运行在driver端还是executor端呢？<a hidden class=anchor aria-hidden=true href=#那么编写的spark程序代码运行在driver端还是executor端呢>#</a></h2><p>通常我们在本地测试程序的时候，要打印RDD中的数据。</p><p>在本地模式下，直接使用rdd.foreach(println)或rdd.map(println)在单台机器上，能够按照预期打印并输出所有RDD的元素。</p><p>但是，在集群模式下，由executor执行输出写入的是executor的stdout，而不是driver上的stdout，所以driver的stdout不会显示这些！</p><p>要想在driver端打印所有元素，可以使用collect()方法先将RDD数据带到driver节点，然后在调用foreach(println)（但需要注意一点，由于会把RDD中所有元素都加载到driver端，可能引起driver端内存不足导致OOM。如果你只是想获取RDD中的部分元素，可以考虑使用take或者top方法）</p><p>总之，在这里RDD中的元素即为具体的数据，对这些数据的操作都是由负责task执行的executor处理的，所以想在driver端输出这些数据就必须先将数据加载到driver端进行处理。</p><p>最后做个总结：所有对RDD具体数据的操作都是在executor上执行的，所有对rdd自身的操作都是在driver上执行的。比如foreach、foreachPartition都是针对rdd内部数据进行处理的，所以我们传递给这些算子的函数都是执行于executor端的。但是像foreachRDD、transform则是对RDD本身进行一列操作，所以它的参数函数是执行在driver端的，那么它内部是可以使用外部变量，比如在Spark Streaming程序中操作offset、动态更新广播变量等。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/spark/>Spark</a></li><li><a href=https://reid00.github.io/en/tags/%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/>广播变量</a></li><li><a href=https://reid00.github.io/en/tags/%E7%B4%AF%E5%8A%A0%E5%99%A8/>累加器</a></li><li><a href=https://reid00.github.io/en/tags/driver/>Driver</a></li><li><a href=https://reid00.github.io/en/tags/executor/>Executor</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/computation/spark-on-yarn-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/><span class=title>« Prev</span><br><span>Spark on Yarn 执行流程解析</span>
</a><a class=next href=https://reid00.github.io/en/posts/other/slidev-markdown-%E8%BD%ACppt/><span class=title>Next »</span><br><span>Slidev Markdown 转PPT</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><span id=busuanzi_container_site_pv>访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>访客数<span id=busuanzi_value_site_uv></span>人次</span></body></html>