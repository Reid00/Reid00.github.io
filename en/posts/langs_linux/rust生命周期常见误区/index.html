<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust生命周期常见误区 | Reid's Blog</title>
<meta name=keywords content="Rust"><meta name=description content="Rust生命周期常见误区"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/langs_linux/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK",{anonymize_ip:!1})}</script><meta property="og:title" content="Rust生命周期常见误区"><meta property="og:description" content="Rust生命周期常见误区"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/langs_linux/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-05T17:35:54+08:00"><meta property="article:modified_time" content="2023-09-05T17:35:54+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="Rust生命周期常见误区"><meta name=twitter:description content="Rust生命周期常见误区"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"学习的编程语言Golang，Python，Rust 和Linux 相关的记录 ","item":"https://reid00.github.io/en/posts/langs_linux/"},{"@type":"ListItem","position":3,"name":"Rust生命周期常见误区","item":"https://reid00.github.io/en/posts/langs_linux/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust生命周期常见误区","name":"Rust生命周期常见误区","description":"Rust生命周期常见误区","keywords":["Rust"],"articleBody":"介绍 我曾经有过的所有这些对生命周期的误解，现在有很多初学者也深陷于此。 我用到的术语可能不是标准的，所以下面列了一个表格来解释它们的用意。\n短语 意为 T 包含了所有可能类型的集合 或 这个集合中的类型 所有权类型 不含引用的类型, 例如 i32, String, Vec, 等 借用类型 或 引用类型 不考虑可变性的引用类型, 例如 \u0026i32, \u0026mut i32 等 可变引用 或 独占引用 独占的可变引用, 即 \u0026mut T 不可变引用 或 共享引用 共享的不可变引用, 即 \u0026T 误解项 简而言之：变量的生命周期指的是这个变量所指的数据可以被编译器静态验证的、在当前内存地址有效期的长度。\n误解1: T 只包含所有权类型 这个误解比起说生命周期，它和泛型更相关，但在Rust中泛型和生命周期是紧密联系在一起的，不可只谈其一。\n当我刚开始学习Rust的时候，我理解i32，\u0026i32，和\u0026mut i32是不同的类型，也明白泛型变量T代表着所有可能类型的集合。 但尽管这二者分开都懂，当它们结合在一起的时候我却陷入困惑。在我这个Rust初学者的眼中，泛型是这样的运作的：\n类型变量 T \u0026T \u0026mut T 例子 i32 \u0026i32 \u0026mut i32 T 包含一切所有权类型； \u0026T 包含一切不可变借用类型； \u0026mut T 包含一切可变借用类型。 T， \u0026T， 和 \u0026mut T 是不相交的有限集。 简洁明了，符合直觉，但却完全错误。 下面这才是泛型真正的运作方式： 类型变量 T \u0026T \u0026mut T 例子 i32, \u0026i32, \u0026mut i32, \u0026\u0026i32, \u0026mut \u0026mut i32, … \u0026i32, \u0026\u0026i32, \u0026\u0026mut i32, … \u0026mut i32, \u0026mut \u0026mut i32, \u0026mut \u0026i32, … T, \u0026T, 和 \u0026mut T 都是无限集, 因为你可以无限借用一个类型。 T 是 \u0026T 和 \u0026mut T的超集. \u0026T 和 \u0026mut T 是不相交的集合。 让我们用几个例子来检验一下这些概念:\n1 2 3 4 5 6 7 trait Trait {} impl\u003cT\u003e Trait for T {} impl\u003cT\u003e Trait for \u0026T {} // 编译错误 impl\u003cT\u003e Trait for \u0026mut T {} // 编译错误 上面的代码并不能如愿编译:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 error[E0119]: conflicting implementations of trait `Trait` for type `\u0026_`: --\u003e src/lib.rs:5:1 | 3 | impl\u003cT\u003e Trait for T {} | ------------------- first implementation here 4 | 5 | impl\u003cT\u003e Trait for \u0026T {} | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `\u0026_` error[E0119]: conflicting implementations of trait `Trait` for type `\u0026mut _`: --\u003e src/lib.rs:7:1 | 3 | impl\u003cT\u003e Trait for T {} | ------------------- first implementation here ... 7 | impl\u003cT\u003e Trait for \u0026mut T {} | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `\u0026mut _ 编译器不允许我们为\u0026T和\u0026mut T实现Trait，因为这样会与为T实现的Trait冲突， T本身已经包含了所有\u0026T和\u0026mut T。下面的代码能够如愿编译，因为\u0026T和\u0026mut T是不相交的：\n1 2 3 4 5 trait Trait {} impl\u003cT\u003e Trait for \u0026T {} // 编译通过 impl\u003cT\u003e Trait for \u0026mut T {} // 编译通过 要点:\nT 是 \u0026T 和 \u0026mut T的超集 \u0026T 和 \u0026mut T 是不相交的集合 误解2: 如果 T: ‘static 那么 T 必须在整个程序运行中都是有效的 误解推论\nT: ‘static 应该被看作 \" T 拥有 ‘static 生命周期 \" \u0026‘static T 和 T: ‘static 没有区别 如果 T: ‘static 那么 T 必须为不可变的 如果 T: ‘static 那么 T 只能在编译期创建 大部分Rust初学者是从类似下面这个代码示例中接触到 ‘static 生命周期的：\n1 2 3 fn main() { let str_literal: \u0026'static str = \"str literal\"; } 他们被告知 “str literal” 是硬编码在编译出来的二进制文件中的， 并会在运行时被加载到只读内存，所以必须是不可变的且在整个程序的运行中都是有效的， 这就是它成为 ‘static 的原因。 而这些观念又进一步被用 static 关键字来定义静态变量的规则所加强。\n1 2 3 4 5 6 7 8 9 10 11 static BYTES: [u8; 3] = [1, 2, 3]; static mut MUT_BYTES: [u8; 3] = [1, 2, 3]; fn main() { MUT_BYTES[0] = 99; // 编译错误，修改静态变量是unsafe的 unsafe { MUT_BYTES[0] = 99; assert_eq!(99, MUT_BYTES[0]); } } 认为静态变量\n只可以在编译期创建 必须是不可变的，修改它们是unsafe的 在整个程序的运行过程中都是有效的 ‘static 生命周期大概是以静态变量的默认生命周期命名的，对吧？ 那么有理由认为’static生命周期也应该遵守相同的规则，不是吗？\n是的，但拥有'static生命周期的类型与'static约束的类型是不同的。 后者能在运行时动态分配，可以安全地、自由地修改，可以被drop， 还可以有任意长度的生命周期。\n在这个点，很重要的是要区分 \u0026'static T 和 T: 'static。\n\u0026'static T 是对某个T的不可变引用，这个引用可以被无限期地持有直到程序结束。 这只可能发生在T本身不可变且不会在引用被创建后移动的情况下。 T并不需要在编译期就被创建，因为我们可以在运行时动态生成随机数据， 然后以内存泄漏为代价返回’static引用，例如：\n1 2 3 4 5 6 7 use rand; // 在运行时生成随机\u0026'static str fn rand_str_generator() -\u003e \u0026'static str { let rand_string = rand::random::\u003cu64\u003e().to_string(); Box::leak(rand_string.into_boxed_str()) } T: 'static 是指T可以被无限期安全地持有直到程序结束。 T: ‘static包括所有\u0026‘static T，此外还包括所有的所有权类型，比如String, Vec等。 数据的所有者能够保证数据只要还被持有就不会失效，因此所有者可以无限期安全地持有该数据直到程序结束。 T: 'static应该被看作T受'static生命周期 \"约束\" 而非 T有着'static生命周期。 这段代码能帮我们阐释这些概念：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 use rand; fn drop_static\u003cT: 'static\u003e(t: T) { std::mem::drop(t); } fn main() { let mut strings: Vec\u003cString\u003e = Vec::new(); for _ in 0..10 { if rand::random() { // 所有字符串都是随机生成的 // 并且是在运行时动态申请的 let string = rand::random::\u003cu64\u003e().to_string(); strings.push(string); } } // 这些字符串都是所有权类型，所以它们满足'static约束 for mut string in strings { // 这些字符串都是可以修改的 string.push_str(\"a mutation\"); // 这些字符串都是可以被drop的 drop_static(string); // 编译通过 } // 这些字符串都在程序结束之前失效 println!(\"i am the end of the program\"); } 要点:\nT: ‘static 应该被看作 “T受’static生命周期约束” 如果 T: ‘static 那么T可以是有着’static生命周期的借用类型 由于 T: ‘static 包括了所有权类型，这意味着T 可以在运行时动态分配 不一定要在整个程序的运行过程中都有效 可以被安全地、自由地修改 可以在运行时被动态drop掉 可以有不同长度的生命周期 误解3: \u0026‘a T 和 T: ‘a 是相同的 这个误解是上一个的泛化版本。\n\u0026‘a T 不光要求，同时也隐含着 T: ‘a， 因为如果T本身都不能在'a内有效， 那对T的有'a生命周期的引用也不可能是有效的。 例如，Rust编译器从来不会允许创建\u0026‘static Ref\u003c‘a, T\u003e这个类型，因为如果Ref只在’a内有效，我们不可能弄出一个对它的’static的引用。\nT: 'a包括了所有\u0026'a T，但反过来不对。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 只接受以'a约束的引用类型 fn t_ref\u003c'a, T: 'a\u003e(t: \u0026'a T) {} // 接受所有以'a约束的类型 fn t_bound\u003c'a, T: 'a\u003e(t: T) {} // 包含引用的所有权类型 struct Ref\u003c'a, T: 'a\u003e(\u0026'a T); fn main() { let string = String::from(\"string\"); t_bound(\u0026string); // 编译通过 t_bound(Ref(\u0026string)); // 编译通过 t_bound(\u0026Ref(\u0026string)); // 编译通过 t_ref(\u0026string); // 编译通过 t_ref(Ref(\u0026string)); // 编译错误, 期待接收一个引用，但收到一个结构体 t_ref(\u0026Ref(\u0026string)); // 编译通过 // string变量是以'static约束的，也满足'a约束 t_bound(string); // 编译通过 } 要点:\nT: ‘a 比起 \u0026‘a T更泛化也更灵活 T: ‘a 接受所有权类型、包含引用的所有权类型以及引用 \u0026‘a T 只接受引用 如果 T: ‘static 那么 T: ‘a, 因为对于所有’a都有’static \u003e= ‘a 误解4: 我的代码没用到泛型，也不含生命周期 误解推论:\n避免使用泛型和生命周期是可能的 这种安慰性的误解的存在是由于Rust的生命周期省略规则， 这些规则让你能够在函数中省略掉生命周期记号， 因为Rust的借用检查器能根据以下规则将它们推导出来：\n每个传入的引用都会有一个单独的生命周期 如果只有一个传入的生命周期，那么它将被应用到所有输出的引用上 如果有多个传入的生命周期，但其中一个是\u0026self或者\u0026mut self，那么这个生命周期将会被应用到所有输出的引用上 除此之外的输出的生命周期都必须显示标注出来 如果一时间难以想明白这么多东西，那让我们来看一些例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 省略 fn print(s: \u0026str); // 展开 fn print\u003c'a\u003e(s: \u0026'a str); // 省略 fn trim(s: \u0026str) -\u003e \u0026str; // 展开 fn trim\u003c'a\u003e(s: \u0026'a str) -\u003e \u0026'a str; // 不合法，无法确定输出的生命周期，因为没有输入的 fn get_str() -\u003e \u0026str; // 显式的写法包括 fn get_str\u003c'a\u003e() -\u003e \u0026'a str; // 泛型版本 fn get_str() -\u003e \u0026'static str; // 'static 版本 // 不合法，无法确定输出的生命周期，因为有多个输入 fn overlap(s: \u0026str, t: \u0026str) -\u003e \u0026str; // 显式(但仍有部分省略)的写法包括 fn overlap\u003c'a\u003e(s: \u0026'a str, t: \u0026str) -\u003e \u0026'a str; // 输出生命周期不能长于s fn overlap\u003c'a\u003e(s: \u0026str, t: \u0026'a str) -\u003e \u0026'a str; // 输出生命周期不能长于t fn overlap\u003c'a\u003e(s: \u0026'a str, t: \u0026'a str) -\u003e \u0026'a str; // 输出生命周期不能长于s和t fn overlap(s: \u0026str, t: \u0026str) -\u003e \u0026'static str; // 输出生命周期可以长于s和t fn overlap\u003c'a\u003e(s: \u0026str, t: \u0026str) -\u003e \u0026'a str; // 输入和输出的生命周期无关 // 展开 fn overlap\u003c'a, 'b\u003e(s: \u0026'a str, t: \u0026'b str) -\u003e \u0026'a str; fn overlap\u003c'a, 'b\u003e(s: \u0026'a str, t: \u0026'b str) -\u003e \u0026'b str; fn overlap\u003c'a\u003e(s: \u0026'a str, t: \u0026'a str) -\u003e \u0026'a str; fn overlap\u003c'a, 'b\u003e(s: \u0026'a str, t: \u0026'b str) -\u003e \u0026'static str; fn overlap\u003c'a, 'b, 'c\u003e(s: \u0026'a str, t: \u0026'b str) -\u003e \u0026'c str; // 省略 fn compare(\u0026self, s: \u0026str) -\u003e \u0026str; // 展开 fn compare\u003c'a, 'b\u003e(\u0026'a self, \u0026'b str) -\u003e \u0026'a str; 如果你曾写过\n结构体方法 接收引用的函数 返回引用的函数 泛型函数 trait object(后面会有更详细的讨论) 闭包(后面会有更详细的讨论) 那么你的代码就有被省略的泛型生命周期记号。 要点:\n几乎所有Rust代码都是泛型代码，到处都有被省略的生命周期记号 误解5: 如果编译能通过，那么我的生命周期标注就是正确的 误解推论\nRust对函数的的生命周期省略规则总是正确的 Rust的借用检查器在技术上和语义上总是正确的 Rust比我更了解我的程序的语义 Rust程序是有可能在技术上能通过编译，但语义上仍然是错的。来看一下这个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct ByteIter\u003c'a\u003e { remainder: \u0026'a [u8] } impl\u003c'a\u003e ByteIter\u003c'a\u003e { fn next(\u0026mut self) -\u003e Option\u003c\u0026u8\u003e { if self.remainder.is_empty() { None } else { let byte = \u0026self.remainder[0]; self.remainder = \u0026self.remainder[1..]; Some(byte) } } } fn main() { let mut bytes = ByteIter { remainder: b\"1\" }; assert_eq!(Some(\u0026b'1'), bytes.next()); assert_eq!(None, bytes.next()); } ByteIter 是在字节切片上迭代的迭代器，为了简洁我们跳过对 Iterator trait的实现。 这看起来没什么问题，但如果我们想同时检查多个字节呢？\n1 2 3 4 5 6 7 8 fn main() { let mut bytes = ByteIter { remainder: b\"1123\" }; let byte_1 = bytes.next(); let byte_2 = bytes.next(); if byte_1 == byte_2 { // 做点什么 } } 啊哦！编译错误：\n1 2 3 4 5 6 7 8 9 10 error[E0499]: cannot borrow `bytes` as mutable more than once at a time --\u003e src/main.rs:20:18 | 19 | let byte_1 = bytes.next(); | ----- first mutable borrow occurs here 20 | let byte_2 = bytes.next(); | ^^^^^ second mutable borrow occurs here 21 | if byte_1 == byte_2 { | ------ first borrow later used here 我觉得我们可以拷贝每一个字节。拷贝在我们处理字节的时候是可行的， 但当我们从 ByteIter 转向泛型切片迭代器用来迭代任意 \u0026'a [T] 的时候 我们也会想到将来可能它会被应用到那些拷贝/克隆的代价很昂贵或根本不可能的类型上。 噢，我想我们对这没什么办法，代码能过编译，那么生命周期标记必然是对的不是吗？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct ByteIter\u003c'a\u003e { remainder: \u0026'a [u8] } impl\u003c'a\u003e ByteIter\u003c'a\u003e { fn next\u003c'b\u003e(\u0026'b mut self) -\u003e Option\u003c\u0026'b u8\u003e { if self.remainder.is_empty() { None } else { let byte = \u0026self.remainder[0]; self.remainder = \u0026self.remainder[1..]; Some(byte) } } } 这一点帮助都没有，我仍然搞不明白。这里有个只有Rust专家才知道的小窍门： 给你的生命周期标记取个有描述性的名字。我们再试一次：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct ByteIter\u003c'remainder\u003e { remainder: \u0026'remainder [u8] } impl\u003c'remainder\u003e ByteIter\u003c'remainder\u003e { fn next\u003c'mut_self\u003e(\u0026'mut_self mut self) -\u003e Option\u003c\u0026'mut_self u8\u003e { if self.remainder.is_empty() { None } else { let byte = \u0026self.remainder[0]; self.remainder = \u0026self.remainder[1..]; Some(byte) } } } 每个返回的字节都被用'mut_self标记了，但这些字节显然是来自于'remainder的， 让我们来改一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct ByteIter\u003c'remainder\u003e { remainder: \u0026'remainder [u8] } impl\u003c'remainder\u003e ByteIter\u003c'remainder\u003e { fn next(\u0026mut self) -\u003e Option\u003c\u0026'remainder u8\u003e { if self.remainder.is_empty() { None } else { let byte = \u0026self.remainder[0]; self.remainder = \u0026self.remainder[1..]; Some(byte) } } } fn main() { let mut bytes = ByteIter { remainder: b\"1123\" }; let byte_1 = bytes.next(); let byte_2 = bytes.next(); std::mem::drop(bytes); // 我们甚至可以在这里把迭代器drop掉！ if byte_1 == byte_2 { // 编译通过 // 做点什么 } } 现在让我们回顾一下，我们前一版的程序显然是错误的，但为什么Rust仍然允许它通过编译呢？ 答案很简单：这么做是内存安全的。\nRust的借用检查器对程序的生命周期标记只要求到能够以静态的方式验证程序的内存安全。 Rust会爽快地编译一个程序，即使它的生命周期标记有语义上的错误， 这带来的结果就是程序会变得过于受限。\n来看一个与前一个相反的例子：Rust的生命周期省略规则恰好在这个例子上语义是正确的， 但我们却无意中用了一些多余的显式生命周期标记写了个非常受限的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #[derive(Debug)] struct NumRef\u003c'a\u003e(\u0026'a i32); impl\u003c'a\u003e NumRef\u003c'a\u003e { // 我的结构体是在'a上泛型的，所以我同样也要 // 标记一下我的self参数，对吗？（答案是：不，不对） fn some_method(\u0026'a mut self) {} } fn main() { let mut num_ref = NumRef(\u00265); num_ref.some_method(); // 可变借用num_ref直到它剩余的生命周期结束 num_ref.some_method(); // 编译错误 println!(\"{:?}\", num_ref); // 同样编译错误 } 如果我们有一个在 ‘a 上的泛型，我们几乎永远不会想要写一个接收\u0026'a mut self的方法。 因为这意味着我们告诉Rust，这个方法会可变借用这个结构体直到整个结构体生命周期结束。 这也就告诉Rust的借用检查器最多只允许 some_method 被调用一次， 在这之后这个结构体将会被永久性地可变借用走，也就变得不可用了。 这样的用例非常非常少，但处于困惑中的初学者非常容易写出这种代码，并能通过编译。 正确的做法是不要添加这些多余的显式生命周期标记，让Rust的生命周期省略规则来处理它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #[derive(Debug)] struct NumRef\u003c'a\u003e(\u0026'a i32); impl\u003c'a\u003e NumRef\u003c'a\u003e { // 去掉mut self前面的'a fn some_method(\u0026mut self) {} // 上一段代码脱掉语法糖后变为 fn some_method_desugared\u003c'b\u003e(\u0026'b mut self){} } fn main() { let mut num_ref = NumRef(\u00265); num_ref.some_method(); num_ref.some_method(); // 编译通过 println!(\"{:?}\", num_ref); // 编译通过 } 要点:\nRust的函数生命周期省略规则并不总是对所有情况都正确的 Rust对你的程序的语义了解并不比你多 给你的生命周期标记起一个更有描述性的名字 在你使用显式生命周期标记的时候要想清楚它们应该被用在哪以及为什么要这么用 误解6: 装箱的trait对象没有生命周期 早前我们讨论了Rust对函数的生命周期省略规则。Rust同样有着对于trait对象的生命周期省略规则，它们是：\n如果一个trait对象作为一个类型参数传递到泛型中，那么它的生命约束会从它包含的类型中推断 如果包含的类型中有唯一的约束，那么就使用这个约束。 如果包含的类型中有超过一个约束，那么必须显式指定约束。 如果以上都不适用，那么：\n如果trait是以单个生命周期约束定义的，那么就使用这个约束 如果所有生命周期约束都是 ‘static 的，那么就使用 ‘static 作为约束 如果trait没有生命周期约束，那么它的生命周期将会从表达式中推断，如果不在表达式中，那么就是 ‘static 的 这么多东西听起来超级复杂，但我们可以简单地总结为 “trait对象的生命周期约束是从上下文中推断出来的。” 在我们看过几个例子后，我们会发现生命周期约束推断其实是很符合直觉的，我们不需要去记这些很正式的规则。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 use std::cell::Ref; trait Trait {} // 省略 type T1 = Box\u003cdyn Trait\u003e; // 展开，Box对T没有生命周期约束，所以被推断为'static type T2 = Box\u003cdyn Trait + 'static\u003e; // 省略 impl dyn Trait {} // 展开 impl dyn Trait + 'static {} // 省略 type T3\u003c'a\u003e = \u0026'a dyn Trait; // 展开, 因为\u0026'a T 要求 T: 'a, 所以推断为 'a type T4\u003c'a\u003e = \u0026'a (dyn Trait + 'a); // 省略 type T5\u003c'a\u003e = Ref\u003c'a, dyn Trait\u003e; // 展开, 因为Ref\u003c'a, T\u003e 要求 T: 'a, 所以推断为 'a type T6\u003c'a\u003e = Ref\u003c'a, dyn Trait + 'a\u003e; trait GenericTrait\u003c'a\u003e: 'a {} // 省略 type T7\u003c'a\u003e = Box\u003cdyn GenericTrait\u003c'a\u003e\u003e; // 展开 type T8\u003c'a\u003e = Box\u003cdyn GenericTrait\u003c'a\u003e + 'a\u003e; // 省略 impl\u003c'a\u003e dyn GenericTrait\u003c'a\u003e {} // 展开 impl\u003c'a\u003e dyn GenericTrait\u003c'a\u003e + 'a {} 实现了某个trait的具体的类型可以包含引用，因此它们同样拥有生命周期约束，且对应的trait对象也有生命周期约束。 你也可以直接为引用实现trait，而引用显然有生命周期约束。\n1 2 3 4 5 6 7 8 trait Trait {} struct Struct {} struct Ref\u003c'a, T\u003e(\u0026'a T); impl Trait for Struct {} impl Trait for \u0026Struct {} // 直接在引用类型上实现Trait impl\u003c'a, T\u003e Trait for Ref\u003c'a, T\u003e {} // 在包含引用的类型上实现Trait 不管怎样，这都值得我们仔细研究，因为新手们经常在将一个使用trait对象的函数重构成使用泛型的函数（或者反过来）的时候感到困惑。 我们来看看这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 use std::fmt::Display; fn dynamic_thread_print(t: Box\u003cdyn Display + Send\u003e) { std::thread::spawn(move || { println!(\"{}\", t); }).join(); } fn static_thread_print\u003cT: Display + Send\u003e(t: T) { std::thread::spawn(move || { println!(\"{}\", t); }).join(); } 这会抛出下面的编译错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 error[E0310]: the parameter type `T` may not live long enough --\u003e src/lib.rs:10:5 | 9 | fn static_thread_print\u003cT: Display + Send\u003e(t: T) { | -- help: consider adding an explicit lifetime bound...: `T: 'static +` 10 | std::thread::spawn(move || { | ^^^^^^^^^^^^^^^^^^ | note: ...so that the type `[closure@src/lib.rs:10:24: 12:6 t:T]` will meet its required lifetime bounds --\u003e src/lib.rs:10:5 | 10 | std::thread::spawn(move || { | ^^^^^^^^^^^^^^^^^^ 很好，编译器告诉了我们怎么解决这个问题，我们来试试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 use std::fmt::Display; fn dynamic_thread_print(t: Box\u003cdyn Display + Send\u003e) { std::thread::spawn(move || { println!(\"{}\", t); }).join(); } fn static_thread_print\u003cT: Display + Send + 'static\u003e(t: T) { std::thread::spawn(move || { println!(\"{}\", t); }).join(); } 编译通过，但这两个函数放在一块儿看起来有点怪，为什么第二个函数对 T 有 ‘static 约束，而第一个没有？ 这个问题很刁钻。根据生命周期省略规则，Rust自动为第一个函数推断出 ‘static 约束，所以两个函数实际上都有 ‘static 约束。 在Rust编译器的眼中是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 use std::fmt::Display; fn dynamic_thread_print(t: Box\u003cdyn Display + Send + 'static\u003e) { std::thread::spawn(move || { println!(\"{}\", t); }).join(); } fn static_thread_print\u003cT: Display + Send + 'static\u003e(t: T) { std::thread::spawn(move || { println!(\"{}\", t); }).join(); } 要点:\n所有trait对象都有着默认推断的生命周期约束 误解7: 编译器报错信息会告诉我怎么修改我的代码 误解推论\nRust编译器对于trait objects的生命周期省略规则总是对的 Rust编译器比我更懂我代码的语义 这个误解是前两个误解的合二为一的例子：\n1 2 3 4 5 use std::fmt::Display; fn box_displayable\u003cT: Display\u003e(t: T) -\u003e Box\u003cdyn Display\u003e { Box::new(t) } 抛出如下错误：\n1 2 3 4 5 6 7 8 9 10 11 12 13 error[E0310]: the parameter type `T` may not live long enough --\u003e src/lib.rs:4:5 | 3 | fn box_displayable\u003cT: Display\u003e(t: T) -\u003e Box\u003cdyn Display\u003e { | -- help: consider adding an explicit lifetime bound...: `T: 'static +` 4 | Box::new(t) | ^^^^^^^^^^^ | note: ...so that the type `T` will meet its required lifetime bounds --\u003e src/lib.rs:4:5 | 4 | Box::new(t) | ^^^^^^^^^^^ 好吧，让我们照着编译器告诉我们的方式修改它，别在意这种改法基于了一个没有告知的事实： 编译器自动为我们的boxed trait object推断了一个’static的生命周期约束。\n1 2 3 4 5 use std::fmt::Display; fn box_displayable\u003cT: Display + 'static\u003e(t: T) -\u003e Box\u003cdyn Display\u003e { Box::new(t) } 现在编译通过了，但这真的是我们想要的吗？可能是，也可能不是，编译去并没有告诉我们其它解决方法 但这个也许合适。\n1 2 3 4 5 use std::fmt::Display; fn box_displayable\u003c'a, T: Display + 'a\u003e(t: T) -\u003e Box\u003cdyn Display + 'a\u003e { Box::new(t) } 这个函数接收的参数和前一个版本一样，但多了不少东西。这样写能让它更好吗？不一定， 这取决于我们的程序的要求和约束。这个例子有些抽象，让我们来看看更简单明了的情况。\n1 2 3 fn return_first(a: \u0026str, b: \u0026str) -\u003e \u0026str { a } 报错:\n1 2 3 4 5 6 7 8 9 10 11 error[E0106]: missing lifetime specifier --\u003e src/lib.rs:1:38 | 1 | fn return_first(a: \u0026str, b: \u0026str) -\u003e \u0026str { | ---- ---- ^ expected named lifetime parameter | = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b` help: consider introducing a named lifetime parameter | 1 | fn return_first\u003c'a\u003e(a: \u0026'a str, b: \u0026'a str) -\u003e \u0026'a str { | ^^^^ ^^^^^^^ ^^^^^^^ ^^^ 这个错误信息建议我们给输入和输出打上相同的生命周期标记。 这么做虽然能使得编译通过，但却过度限制了返回类型。 我们真正想要的是这个：\n1 2 3 fn return_first\u003c'a\u003e(a: \u0026'a str, b: \u0026str) -\u003e \u0026'a str { a } 要点:\nRust对trait object的生命周期省略规则并不是在所有情况下都正确。 Rust不见得比你更懂你代码的语义。 Rust编译错误信息给出的修改建议可能能让你的代码编译通过，但这不一定是最符合你的要求的。 误解8: 生命周期可以在运行时变长缩短 误解推论\n容器类型可以通过更换引用在运行时更改自己的生命周期 Rust的借用检查会进行深入的控制流分析 这过不了编译：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 struct Has\u003c'lifetime\u003e { lifetime: \u0026'lifetime str, } fn main() { let long = String::from(\"long\"); let mut has = Has { lifetime: \u0026long }; assert_eq!(has.lifetime, \"long\"); { let short = String::from(\"short\"); // 换成短生命周期 has.lifetime = \u0026short; assert_eq!(has.lifetime, \"short\"); // 换回长生命周期（并不行） has.lifetime = \u0026long; assert_eq!(has.lifetime, \"long\"); // `short`在这里析构 } // 编译错误，`short`在析构后仍处于借用状态 assert_eq!(has.lifetime, \"long\"); } 报错：\n1 2 3 4 5 6 7 8 9 10 error[E0597]: `short` does not live long enough --\u003e src/main.rs:11:24 | 11 | has.lifetime = \u0026short; | ^^^^^^ borrowed value does not live long enough ... 15 | } | - `short` dropped here while still borrowed 16 | assert_eq!(has.lifetime, \"long\"); | --------------------------------- borrow later used here 下面这个代码同样过不了编译，报的错和上面一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 struct Has\u003c'lifetime\u003e { lifetime: \u0026'lifetime str, } fn main() { let long = String::from(\"long\"); let mut has = Has { lifetime: \u0026long }; assert_eq!(has.lifetime, \"long\"); // 这个代码块不会被执行 if false { let short = String::from(\"short\"); // 换成短生命周期 has.lifetime = \u0026short; assert_eq!(has.lifetime, \"short\"); // 换回长生命周期（并不行） has.lifetime = \u0026long; assert_eq!(has.lifetime, \"long\"); // `short`在这里析构 } // 仍旧编译错误，`short`在析构后仍处于借用状态 assert_eq!(has.lifetime, \"long\"); } 生命周期只会在编译期被静态验证，并且Rust的借用检查只能做到基本的控制流分析， 它假设每个if-else中的代码块和match的每个分支都会被执行， 并且其中的每一个变量都能被指定一个最短的生命周期。 一旦变量被指定了一个生命周期，它就一直受到这个生命周期约束。变量的生命周期只能缩短， 并且所有缩短都会在编译器被确定。\n要点:\n生命周期是在编译期静态验证的 生命周期不能在运行时变长、缩短或者改变 Rust的借用检查总是会为所有变量指定一个最短可能的生命周期，并且假定所有代码路径都会被执行 误解9: 将可变引用降级为共享引用是安全的 误解推论\n重新借用一个引用会终止它的生命周期并且开始一个新的 你可以向一个接收共享引用的函数传递一个可变引用，因为Rust会隐式将可变引用重新借用为不可变引用：\n1 2 3 4 5 6 7 fn takes_shared_ref(n: \u0026i32) {} fn main() { let mut a = 10; takes_shared_ref(\u0026mut a); // 编译通过 takes_shared_ref(\u0026*(\u0026mut a)); // 上一行的显式写法 } 直觉上这没问题，将一个可变引用重新借用为不可变引用，应该不会有什么害处不是吗？ 然而并非如此，下面的代码过不了编译。\n1 2 3 4 5 6 fn main() { let mut a = 10; let b: \u0026i32 = \u0026*(\u0026mut a); // 重新借用为不可变 let c: \u0026i32 = \u0026a; dbg!(b, c); // 编译错误 } 报错：\n1 2 3 4 5 6 7 8 9 error[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable --\u003e src/main.rs:4:19 | 3 | let b: \u0026i32 = \u0026*(\u0026mut a); | -------- mutable borrow occurs here 4 | let c: \u0026i32 = \u0026a; | ^^ immutable borrow occurs here 5 | dbg!(b, c); | - mutable borrow later used here 可变借用出现后立即重新借用为不可变引用，然后可变引用自身析构。 为什么Rust会认为这个不可变的重新借用仍具有可变引用的独占生命周期？ 虽然上面这个例子没什么问题，但允许将可变引用降级为共享引用实际上引入了潜在的内存安全问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 use std::sync::Mutex; struct Struct { mutex: Mutex\u003cString\u003e } impl Struct { // 将self的可变引用降级为str的共享引用 fn get_string(\u0026mut self) -\u003e \u0026str { self.mutex.get_mut().unwrap() } fn mutate_string(\u0026self) { // 如果Rust允许将可变引用降级为共享引用， // 那么下面这行代码会使得所有从get_string中得到的共享引用失效 *self.mutex.lock().unwrap() = \"surprise!\".to_owned(); } } fn main() { let mut s = Struct { mutex: Mutex::new(\"string\".to_owned()) }; let str_ref = s.get_string(); // 可变引用降级为共享引用 s.mutate_string(); // str_ref失效，变为悬空指针 dbg!(str_ref); // 编译错误，和我们预期的一样 } 这里的问题在于，当你将一个可变引用重新借用为共享引用，你会遇到一点麻烦： 即使可变引用已经析构，重新借用出来的共享引用还是会将可变引用的生命周期延长到和自己一样长。 这种重新借用出来的共享引用非常难用，因为它不能与其它共享引用共存。 它有着可变引用和不可变引用的所有缺点，却没有它们各自的优点。 我认为将可变引用重新借用为共享引用应该被认为是Rust的反模式（anti-pattern)。 对这种反模式保持警惕很重要，这可以让你在看到下面这样的代码的时候更容易发现它：\n1 2 3 4 5 6 7 8 9 10 11 12 // 将T的可变引用降级为共享引用 fn some_function\u003cT\u003e(some_arg: \u0026mut T) -\u003e \u0026T; struct Struct; impl Struct { // 将self的可变引用降级为self共享引用 fn some_method(\u0026mut self) -\u003e \u0026self; // 将self的可变引用降级为T的共享引用 fn other_method(\u0026mut self) -\u003e \u0026T; } 即使你避免了函数和方法签名中的重新借用，Rust仍然会自动隐式重新借用， 所以很容易无意中遇到这样的问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 use std::collections::HashMap; type PlayerID = i32; #[derive(Debug, Default)] struct Player { score: i32, } fn start_game(player_a: PlayerID, player_b: PlayerID, server: \u0026mut HashMap\u003cPlayerID, Player\u003e) { // 从服务器中获取player，如果不存在则创建并插入一个新的 let player_a: \u0026Player = server.entry(player_a).or_default(); let player_b: \u0026Player = server.entry(player_b).or_default(); // 用player做点什么 dbg!(player_a, player_b); // 编译错误 } 上面的代码编译失败。因为 or_default() 返回一个 \u0026mut Player， 而我们的显式类型标注 \u0026Player 使得这个 \u0026mut Player 被隐式重新借用为 \u0026Player 。 为了通过编译，我们不得不这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use std::collections::HashMap; type PlayerID = i32; #[derive(Debug, Default)] struct Player { score: i32, } fn start_game(player_a: PlayerID, player_b: PlayerID, server: \u0026mut HashMap\u003cPlayerID, Player\u003e) { // 因为我们不能把它们放在一起用，所以这里把返回的Player可变引用析构掉 server.entry(player_a).or_default(); server.entry(player_b).or_default(); // 再次获取这些Player，这次以不可变的方式，避免出现隐式重新借用 let player_a = server.get(\u0026player_a); let player_b = server.get(\u0026player_b); // 用Player做点什么 dbg!(player_a, player_b); // 编译通过 } 虽然有点尴尬和笨重，但这也算是为内存安全做出的牺牲。\n要点:\n尽量不要把可变引用重新借用为共享引用，不然你会遇到不少麻烦 重新借用一个可变引用不会使得它的生命周期终结，即使这个可变引用已经析构 误解10: 闭包遵循和函数相同的生命周期省略规则 比起误解，这更像是Rust的一个小陷阱。\n闭包，虽然也是个函数，但是它并不遵循和函数相同的生命周期省略规则。\n1 2 3 4 5 6 7 fn function(x: \u0026i32) -\u003e \u0026i32 { x } fn main() { let closure = |x: \u0026i32| x; } 报错：\n1 2 3 4 5 6 7 8 error: lifetime may not live long enough --\u003e src/main.rs:6:29 | 6 | let closure = |x: \u0026i32| x; | - - ^ returning this value requires that `'1` must outlive `'2` | | | | | return type of closure is \u0026'2 i32 | let's call the lifetime of this reference `'1` 去掉语法糖后：\n1 2 3 4 5 6 7 8 9 10 // 输入的生命周期应用到输出上 fn function\u003c'a\u003e(x: \u0026'a i32) -\u003e \u0026'a i32 { x } fn main() { // 输入和输出有它们自己独有的生命周期 let closure = for\u003c'a, 'b\u003e |x: \u0026'a i32| -\u003e \u0026'b i32 { x }; // 注意：上面这行代码不是合法的语法，但可以表达出我们的意思 } 出现这种差异并没有一个好的理由。闭包最早的实现用的类型推断语义和函数不同， 现在变得没法改了，因为将它们统一起来会造成一个不兼容的改动。 那么我们要怎么样显式标注闭包的类型呢？我们可选的办法有：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 fn main() { // 转成trait object，变成不定长类型，编译错误 let identity: dyn Fn(\u0026i32) -\u003e \u0026i32 = |x: \u0026i32| x; // 可以通过将它分配在堆上来绕过这个错误，但这样很笨重 let identity: Box\u003cdyn Fn(\u0026i32) -\u003e \u0026i32\u003e = Box::new(|x: \u0026i32| x); // 也可以跳过分配，直接创建一个静态的引用 let identity: \u0026dyn Fn(\u0026i32) -\u003e \u0026i32 = \u0026|x: \u0026i32| x; // 上一行去掉语法糖之后:) let identity: \u0026'static (dyn for\u003c'a\u003e Fn(\u0026'a i32) -\u003e \u0026'a i32 + 'static) = \u0026|x: \u0026i32| -\u003e \u0026i32 { x }; // 理想中的写法是这样的，但这不是有效的语法 let identity: impl Fn(\u0026i32) -\u003e \u0026i32 = |x: \u0026i32| x; // 这样也不错，但也不是有效的语法 let identity = for\u003c'a\u003e |x: \u0026'a i32| -\u003e \u0026'a i32 { x }; // \"impl trait\"可以写在函数返回的位置，我们也可以这样写 fn return_identity() -\u003e impl Fn(\u0026i32) -\u003e \u0026i32 { |x| x } let identity = return_identity(); // 前一种解决方案更泛化的写法 fn annotate\u003cT, F\u003e(f: F) -\u003e F where F: Fn(\u0026T) -\u003e \u0026T { f } let identity = annotate(|x: \u0026i32| x); } 相信你已经注意到，在上面的例子中，当闭包类型使用trait约束的时候会遵循一般函数的生命周期省略规则。\n这里没有什么真正的教训和洞察，只是它就是这样的而已。\n要点:\n每一门语言都有自己的小陷阱 🤷 误解11: ‘static 引用总能强制转换为 ‘a 引用 我前面给出了这个例子：\n1 2 fn get_str\u003c'a\u003e() -\u003e \u0026'a str; // 泛型版本 fn get_str() -\u003e \u0026'static str; // 'static版本 有的读者问我这两个在实践中是否有区别。一开始我也不太确定，但不幸的是， 在经过一段时间的研究之后我发现它们在实践中确实存在着区别。\n所以一般来说，在操作值得时候我们可以使用 ‘static 引用来替换 ‘a 引用， 因为Rust会自动将 ‘static 引用强制转换到 ‘a 引用。 直觉上来讲，这没毛病，在一个要求较短生命周期引用的地方使用一个有着更长的生命周期的引用不会造成内存安全问题。 下面的代码和我们想的一样编译通过：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 use rand; fn generic_str_fn\u003c'a\u003e() -\u003e \u0026'a str { \"str\" } fn static_str_fn() -\u003e \u0026'static str { \"str\" } fn a_or_b\u003cT\u003e(a: T, b: T) -\u003e T { if rand::random() { a } else { b } } fn main() { let some_string = \"string\".to_owned(); let some_str = \u0026some_string[..]; let str_ref = a_or_b(some_str, generic_str_fn()); // 编译通过 let str_ref = a_or_b(some_str, static_str_fn()); // 编译通过 } 然而，这种强制转换并不会在引用作为函数的类型签名的一部分的时候出现，所以下面这段代码无法通过编译：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 use rand; fn generic_str_fn\u003c'a\u003e() -\u003e \u0026'a str { \"str\" } fn static_str_fn() -\u003e \u0026'static str { \"str\" } fn a_or_b_fn\u003cT, F\u003e(a: T, b_fn: F) -\u003e T where F: Fn() -\u003e T { if rand::random() { a } else { b_fn() } } fn main() { let some_string = \"string\".to_owned(); let some_str = \u0026some_string[..]; let str_ref = a_or_b_fn(some_str, generic_str_fn); // 编译通过 let str_ref = a_or_b_fn(some_str, static_str_fn); // 编译错误 } 报错：\n1 2 3 4 5 6 7 8 9 10 error[E0597]: `some_string` does not live long enough --\u003e src/main.rs:23:21 | 23 | let some_str = \u0026some_string[..]; | ^^^^^^^^^^^ borrowed value does not live long enough ... 25 | let str_ref = a_or_b_fn(some_str, static_str_fn); | ---------------------------------- argument requires that `some_string` is borrowed for `'static` 26 | } | - `some_string` dropped here while still borrowed 这算不算Rust的小陷阱还有待商榷，因为这不是 \u0026‘static str 到 \u0026‘a str 简单直接的强制转换， 而是 for Fn() -\u003e \u0026‘static T 到 for\u003c‘a, T\u003e Fn() -\u003e \u0026‘a T 这种更复杂的情况。 前者是值之间的强制转换，后者是类型之间的强制转换。\n要点:\n签名为 for\u003c‘a, T\u003e Fn() -\u003e \u0026‘a T 的函数要比签名为 for fn() -\u003e \u0026‘static T 的函数更为灵活，并且能用在更多场景下 总结: T 是 \u0026T 和 \u0026mut T 的超集 \u0026T 和 \u0026mut T 是不相交的集合 T: ‘static 应该被读作 “T 受 ‘static 生命周期约束” 如果 T: ‘static 那么 T 可以是一个有着 ‘static 生命周期的借用类型，或是一个所有权类型 既然 T: ‘static 包含了所有权类型，那么意味着 T 可以在运行时动态分配 不必在整个程序中都是有效的 可以被安全地任意修改 可以在运行时动态析构 可以有不同长度的生命周期 T: ‘a 比 \u0026‘a T 更泛化、灵活 T: ‘a 接收所有权类型、带引用的所有权类型，以及引用 \u0026‘a T 只接收引用 如果 T: ‘static 那么 T: ‘a，因为对于所有 ‘a 都有 ‘static \u003e= ‘a 几乎所有Rust代码都是泛型的，到处都有省略的生命周期 Rust的生命周期省略规则并不是在任何情况下都对 Rust并不比你更了解你程序的语义 给生命周期标记起一个有描述性的名字 考虑清楚哪里需要显式写出生命周期标记，以及为什么要这么写 所有trait object都有默认推断的生命周期约束 Rust的编译错误信息可以让你的代码通过编译，但不一定是最符合你代码要求的 生命周期是在编译期静态验证的 生命周期不会以任何方式在运行时变长缩短 Rust的借用检查总会为每个变量选择一个最短可能的生命周期，并且假定每条代码路径都会被执行 尽量避免将可变引用重新借用为不可变引用，不然你会遇到不少麻烦 重新借用一个可变引用不会终止它的生命周期，即使这个可变引用已经析构 每个语言都有自己的小陷阱 ","wordCount":"11138","inLanguage":"en","datePublished":"2023-09-05T17:35:54+08:00","dateModified":"2023-09-05T17:35:54+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/langs_linux/rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/langs_linux/>学习的编程语言Golang，Python，Rust 和Linux 相关的记录</a></div><h1 class=post-title>Rust生命周期常见误区</h1><div class=post-description>Rust生命周期常见误区</div><div class=post-meta><span title='2023-09-05 17:35:54 +0800 +0800'>2023-09-05 17:35</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;11138 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a><ul><li><a href=#%e8%af%af%e8%a7%a3%e9%a1%b9 aria-label=误解项>误解项</a><ul><li><a href=#%e8%af%af%e8%a7%a31-t-%e5%8f%aa%e5%8c%85%e5%90%ab%e6%89%80%e6%9c%89%e6%9d%83%e7%b1%bb%e5%9e%8b aria-label="误解1: T 只包含所有权类型">误解1: T 只包含所有权类型</a></li><li><a href=#%e8%af%af%e8%a7%a32-%e5%a6%82%e6%9e%9c-t-static-%e9%82%a3%e4%b9%88-t-%e5%bf%85%e9%a1%bb%e5%9c%a8%e6%95%b4%e4%b8%aa%e7%a8%8b%e5%ba%8f%e8%bf%90%e8%a1%8c%e4%b8%ad%e9%83%bd%e6%98%af%e6%9c%89%e6%95%88%e7%9a%84 aria-label="误解2: 如果 T: &amp;lsquo;static 那么 T 必须在整个程序运行中都是有效的">误解2: 如果 T: &lsquo;static 那么 T 必须在整个程序运行中都是有效的</a></li><li><a href=#%e8%af%af%e8%a7%a33-a-t-%e5%92%8c-t-a-%e6%98%af%e7%9b%b8%e5%90%8c%e7%9a%84 aria-label="误解3: &amp;amp;&amp;lsquo;a T 和 T: &amp;lsquo;a 是相同的">误解3: &&lsquo;a T 和 T: &lsquo;a 是相同的</a></li><li><a href=#%e8%af%af%e8%a7%a34-%e6%88%91%e7%9a%84%e4%bb%a3%e7%a0%81%e6%b2%a1%e7%94%a8%e5%88%b0%e6%b3%9b%e5%9e%8b%e4%b9%9f%e4%b8%8d%e5%90%ab%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f aria-label="误解4: 我的代码没用到泛型，也不含生命周期">误解4: 我的代码没用到泛型，也不含生命周期</a></li><li><a href=#%e8%af%af%e8%a7%a35-%e5%a6%82%e6%9e%9c%e7%bc%96%e8%af%91%e8%83%bd%e9%80%9a%e8%bf%87%e9%82%a3%e4%b9%88%e6%88%91%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%a0%87%e6%b3%a8%e5%b0%b1%e6%98%af%e6%ad%a3%e7%a1%ae%e7%9a%84 aria-label="误解5: 如果编译能通过，那么我的生命周期标注就是正确的">误解5: 如果编译能通过，那么我的生命周期标注就是正确的</a></li><li><a href=#%e8%af%af%e8%a7%a36-%e8%a3%85%e7%ae%b1%e7%9a%84trait%e5%af%b9%e8%b1%a1%e6%b2%a1%e6%9c%89%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f aria-label="误解6: 装箱的trait对象没有生命周期">误解6: 装箱的trait对象没有生命周期</a></li><li><a href=#%e8%af%af%e8%a7%a37-%e7%bc%96%e8%af%91%e5%99%a8%e6%8a%a5%e9%94%99%e4%bf%a1%e6%81%af%e4%bc%9a%e5%91%8a%e8%af%89%e6%88%91%e6%80%8e%e4%b9%88%e4%bf%ae%e6%94%b9%e6%88%91%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label="误解7: 编译器报错信息会告诉我怎么修改我的代码">误解7: 编译器报错信息会告诉我怎么修改我的代码</a></li><li><a href=#%e8%af%af%e8%a7%a38-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e5%8f%af%e4%bb%a5%e5%9c%a8%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8f%98%e9%95%bf%e7%bc%a9%e7%9f%ad aria-label="误解8: 生命周期可以在运行时变长缩短">误解8: 生命周期可以在运行时变长缩短</a></li><li><a href=#%e8%af%af%e8%a7%a39-%e5%b0%86%e5%8f%af%e5%8f%98%e5%bc%95%e7%94%a8%e9%99%8d%e7%ba%a7%e4%b8%ba%e5%85%b1%e4%ba%ab%e5%bc%95%e7%94%a8%e6%98%af%e5%ae%89%e5%85%a8%e7%9a%84 aria-label="误解9: 将可变引用降级为共享引用是安全的">误解9: 将可变引用降级为共享引用是安全的</a></li><li><a href=#%e8%af%af%e8%a7%a310-%e9%97%ad%e5%8c%85%e9%81%b5%e5%be%aa%e5%92%8c%e5%87%bd%e6%95%b0%e7%9b%b8%e5%90%8c%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e7%9c%81%e7%95%a5%e8%a7%84%e5%88%99 aria-label="误解10: 闭包遵循和函数相同的生命周期省略规则">误解10: 闭包遵循和函数相同的生命周期省略规则</a></li><li><a href=#%e8%af%af%e8%a7%a311-static-%e5%bc%95%e7%94%a8%e6%80%bb%e8%83%bd%e5%bc%ba%e5%88%b6%e8%bd%ac%e6%8d%a2%e4%b8%ba-a-%e5%bc%95%e7%94%a8 aria-label="误解11: &amp;lsquo;static 引用总能强制转换为 &amp;lsquo;a 引用">误解11: &lsquo;static 引用总能强制转换为 &lsquo;a 引用</a></li></ul></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结:>总结:</a></li></ul></div></details></div><div class=post-content><h1 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h1><p>我曾经有过的所有这些对生命周期的误解，现在有很多初学者也深陷于此。 我用到的术语可能不是标准的，所以下面列了一个表格来解释它们的用意。</p><table><thead><tr><th style=text-align:left>短语</th><th style=text-align:left>意为</th></tr></thead><tbody><tr><td style=text-align:left>T</td><td style=text-align:left>包含了所有可能类型的集合 或 这个集合中的类型</td></tr><tr><td style=text-align:left>所有权类型</td><td style=text-align:left>不含引用的类型, 例如 i32, String, Vec, 等</td></tr><tr><td style=text-align:left>借用类型 或 引用类型</td><td style=text-align:left>不考虑可变性的引用类型, 例如 &amp;i32, &amp;mut i32 等</td></tr><tr><td style=text-align:left>可变引用 或 独占引用</td><td style=text-align:left>独占的可变引用, 即 &amp;mut T</td></tr><tr><td style=text-align:left>不可变引用 或 共享引用</td><td style=text-align:left>共享的不可变引用, 即 &amp;T</td></tr></tbody></table><h2 id=误解项>误解项<a hidden class=anchor aria-hidden=true href=#误解项>#</a></h2><p>简而言之：变量的生命周期指的是这个变量所指的数据可以被编译器静态验证的、在当前内存地址有效期的长度。</p><h3 id=误解1-t-只包含所有权类型>误解1: T 只包含所有权类型<a hidden class=anchor aria-hidden=true href=#误解1-t-只包含所有权类型>#</a></h3><p>这个误解比起说生命周期，它和泛型更相关，但在Rust中泛型和生命周期是紧密联系在一起的，不可只谈其一。</p><p>当我刚开始学习Rust的时候，我理解i32，&amp;i32，和&amp;mut i32是不同的类型，也明白泛型变量T代表着所有可能类型的集合。 但尽管这二者分开都懂，当它们结合在一起的时候我却陷入困惑。在我这个Rust初学者的眼中，泛型是这样的运作的：</p><table><thead><tr><th style=text-align:left>类型变量</th><th style=text-align:left>T</th><th style=text-align:left>&amp;T</th><th style=text-align:left>&amp;mut T</th></tr></thead><tbody><tr><td style=text-align:left>例子</td><td style=text-align:left>i32</td><td style=text-align:left>&amp;i32</td><td style=text-align:left>&amp;mut i32</td></tr></tbody></table><ul><li>T 包含一切所有权类型；</li><li>&amp;T 包含一切不可变借用类型；</li><li>&amp;mut T 包含一切可变借用类型。</li><li>T， &amp;T， 和 &amp;mut T 是不相交的有限集。
简洁明了，符合直觉，但却完全错误。 下面这才是泛型真正的运作方式：</li></ul><table><thead><tr><th style=text-align:left>类型变量</th><th style=text-align:left>T</th><th style=text-align:left>&amp;T</th><th style=text-align:left>&amp;mut T</th></tr></thead><tbody><tr><td style=text-align:left>例子</td><td style=text-align:left>i32, &amp;i32, &amp;mut i32, &&amp;i32, &amp;mut &amp;mut i32, &mldr;</td><td style=text-align:left>&amp;i32, &&amp;i32, &&amp;mut i32, &mldr;</td><td style=text-align:left>&amp;mut i32, &amp;mut &amp;mut i32, &amp;mut &amp;i32, &mldr;</td></tr></tbody></table><ul><li>T, &amp;T, 和 &amp;mut T 都是无限集, 因为你可以无限借用一个类型。</li><li>T 是 &amp;T 和 &amp;mut T的超集.</li><li>&amp;T 和 &amp;mut T 是不相交的集合。</li></ul><p>让我们用几个例子来检验一下这些概念:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w> </span><span class=c1>// 编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w> </span><span class=c1>// 编译错误
</span></span></span></code></pre></td></tr></table></div></div><p>上面的代码并不能如愿编译:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0119</span><span class=p>]</span>: <span class=nc>conflicting</span><span class=w> </span><span class=n>implementations</span><span class=w> </span><span class=n>of</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=err>`</span><span class=n>Trait</span><span class=err>`</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=k>type</span> <span class=err>`</span><span class=o>&amp;</span><span class=n>_</span><span class=err>`</span>:
</span></span><span class=line><span class=cl> <span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>5</span>:<span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>3</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=o>-------------------</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=n>implementation</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>4</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>5</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=o>^^^^^^^^^^^^^^^^^^^^</span><span class=w> </span><span class=n>conflicting</span><span class=w> </span><span class=n>implementation</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=err>`</span><span class=o>&amp;</span><span class=n>_</span><span class=err>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>error</span><span class=p>[</span><span class=n>E0119</span><span class=p>]</span>: <span class=nc>conflicting</span><span class=w> </span><span class=n>implementations</span><span class=w> </span><span class=n>of</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=err>`</span><span class=n>Trait</span><span class=err>`</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=k>type</span> <span class=err>`</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>_</span><span class=err>`</span>:
</span></span><span class=line><span class=cl> <span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>7</span>:<span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>3</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=o>-------------------</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=n>implementation</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>7</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=o>^^^^^^^^^^^^^^^^^^^^^^^^</span><span class=w> </span><span class=n>conflicting</span><span class=w> </span><span class=n>implementation</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=err>`</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>_</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>编译器不允许我们为&amp;T和&amp;mut T实现Trait，因为这样会与为T实现的Trait冲突， <code>T本身已经包含了所有&amp;T和&amp;mut T</code>。下面的代码能够如愿编译，因为&amp;T和&amp;mut T是不相交的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=p>{}</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span></code></pre></td></tr></table></div></div><p><code>要点:</code></p><ul><li>T 是 &amp;T 和 &amp;mut T的超集</li><li>&amp;T 和 &amp;mut T 是不相交的集合</li></ul><h3 id=误解2-如果-t-static-那么-t-必须在整个程序运行中都是有效的>误解2: 如果 T: &lsquo;static 那么 T 必须在整个程序运行中都是有效的<a hidden class=anchor aria-hidden=true href=#误解2-如果-t-static-那么-t-必须在整个程序运行中都是有效的>#</a></h3><p>误解推论</p><ul><li>T: &lsquo;static 应该被看作 " T 拥有 &lsquo;static 生命周期 "</li><li>&&lsquo;static T 和 T: &lsquo;static 没有区别</li><li>如果 T: &lsquo;static 那么 T 必须为不可变的</li><li>如果 T: &lsquo;static 那么 T 只能在编译期创建</li></ul><p>大部分Rust初学者是从类似下面这个代码示例中接触到 &lsquo;static 生命周期的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>str_literal</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span> <span class=o>=</span><span class=w> </span><span class=s>&#34;str literal&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>他们被告知 &ldquo;str literal&rdquo; 是硬编码在编译出来的二进制文件中的， 并会在运行时被加载到只读内存，所以必须是不可变的且在整个程序的运行中都是有效的， 这就是它成为 &lsquo;static 的原因。 而这些观念又进一步被用 static 关键字来定义静态变量的规则所加强。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>static</span><span class=w> </span><span class=no>BYTES</span>: <span class=p>[</span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>static</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=no>MUT_BYTES</span>: <span class=p>[</span><span class=kt>u8</span><span class=p>;</span><span class=w> </span><span class=mi>3</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=no>MUT_BYTES</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>99</span><span class=p>;</span><span class=w> </span><span class=c1>// 编译错误，修改静态变量是unsafe的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=no>MUT_BYTES</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>99</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mi>99</span><span class=p>,</span><span class=w> </span><span class=no>MUT_BYTES</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>认为静态变量</p><ul><li>只可以在编译期创建</li><li>必须是不可变的，修改它们是unsafe的</li><li>在整个程序的运行过程中都是有效的</li></ul><p>&lsquo;static 生命周期大概是以静态变量的默认生命周期命名的，对吧？ 那么有理由认为&rsquo;static生命周期也应该遵守相同的规则，不是吗？</p><p>是的，<code>但拥有'static生命周期的类型与'static约束的类型是不同的</code>。 <code>后者能在运行时动态分配，可以安全地、自由地修改，可以被drop， 还可以有任意长度的生命周期</code>。</p><p>在这个点，很重要的是要区分 <code>&'static T 和 T: 'static。</code></p><p><code>&'static T 是对某个T的不可变引用，这个引用可以被无限期地持有直到程序结束</code>。 这只可能发生在<code>T本身不可变且不会在引用被创建后移动的情况下</code>。 <strong>T并不需要在编译期就被创建</strong>，因为我们可以在运行时动态生成随机数据， 然后以内存泄漏为代价返回&rsquo;static引用，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rand</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 在运行时生成随机&amp;&#39;static str
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>rand_str_generator</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>rand_string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rand</span>::<span class=n>random</span>::<span class=o>&lt;</span><span class=kt>u64</span><span class=o>&gt;</span><span class=p>().</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Box</span>::<span class=n>leak</span><span class=p>(</span><span class=n>rand_string</span><span class=p>.</span><span class=n>into_boxed_str</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>T: 'static 是指T可以被无限期安全地持有直到程序结束</code>。 T: &lsquo;static包括所有&&lsquo;static T，此外还包括所有的所有权类型，比如String, Vec等。 数据的所有者能够保证数据只要还被持有就不会失效，因此所有者可以无限期安全地持有该数据直到程序结束。 <code>T: 'static应该被看作T受'static生命周期 "约束" 而非 T有着'static生命周期。</code> 这段代码能帮我们阐释这些概念：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rand</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>drop_static</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>mem</span>::<span class=nb>drop</span><span class=p>(</span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>strings</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=mi>10</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>rand</span>::<span class=n>random</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 所有字符串都是随机生成的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=c1>// 并且是在运行时动态申请的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rand</span>::<span class=n>random</span>::<span class=o>&lt;</span><span class=kt>u64</span><span class=o>&gt;</span><span class=p>().</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>strings</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>string</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 这些字符串都是所有权类型，所以它们满足&#39;static约束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>strings</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 这些字符串都是可以修改的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>string</span><span class=p>.</span><span class=n>push_str</span><span class=p>(</span><span class=s>&#34;a mutation&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 这些字符串都是可以被drop的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>drop_static</span><span class=p>(</span><span class=n>string</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 这些字符串都在程序结束之前失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;i am the end of the program&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>要点:</code></p><ul><li>T: &lsquo;static 应该被看作 “T受&rsquo;static生命周期约束”</li><li>如果 T: &lsquo;static 那么T可以是有着&rsquo;static生命周期的借用类型</li><li>由于 T: &lsquo;static 包括了所有权类型，这意味着T<ul><li>可以在运行时动态分配</li><li>不一定要在整个程序的运行过程中都有效</li><li>可以被安全地、自由地修改</li><li>可以在运行时被动态drop掉</li><li>可以有不同长度的生命周期</li></ul></li></ul><h3 id=误解3-a-t-和-t-a-是相同的>误解3: &&lsquo;a T 和 T: &lsquo;a 是相同的<a hidden class=anchor aria-hidden=true href=#误解3-a-t-和-t-a-是相同的>#</a></h3><p>这个误解是上一个的泛化版本。</p><p>&&lsquo;a T 不光要求，同时也隐含着 T: &lsquo;a， 因为<code>如果T本身都不能在'a内有效， 那对T的有'a生命周期的引用也不可能是有效</code>的。 例如，Rust编译器从来不会允许创建&&lsquo;static Ref&lt;&lsquo;a, T>这个类型，因为如果Ref只在&rsquo;a内有效，我们不可能弄出一个对它的&rsquo;static的引用。</p><p><code>T: 'a包括了所有&'a T，但反过来不对。</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 只接受以&#39;a约束的引用类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>t_ref</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 接受所有以&#39;a约束的类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>t_bound</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 包含引用的所有权类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Ref</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>T</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;string&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>t_bound</span><span class=p>(</span><span class=o>&amp;</span><span class=n>string</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>t_bound</span><span class=p>(</span><span class=n>Ref</span><span class=p>(</span><span class=o>&amp;</span><span class=n>string</span><span class=p>));</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>t_bound</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Ref</span><span class=p>(</span><span class=o>&amp;</span><span class=n>string</span><span class=p>));</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>t_ref</span><span class=p>(</span><span class=o>&amp;</span><span class=n>string</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>t_ref</span><span class=p>(</span><span class=n>Ref</span><span class=p>(</span><span class=o>&amp;</span><span class=n>string</span><span class=p>));</span><span class=w> </span><span class=c1>// 编译错误, 期待接收一个引用，但收到一个结构体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>t_ref</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Ref</span><span class=p>(</span><span class=o>&amp;</span><span class=n>string</span><span class=p>));</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// string变量是以&#39;static约束的，也满足&#39;a约束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>t_bound</span><span class=p>(</span><span class=n>string</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>要点:</code></p><ul><li>T: &lsquo;a 比起 &&lsquo;a T更泛化也更灵活</li><li>T: &lsquo;a 接受所有权类型、包含引用的所有权类型以及引用</li><li>&&lsquo;a T 只接受引用</li><li>如果 T: &lsquo;static 那么 T: &lsquo;a, 因为对于所有&rsquo;a都有&rsquo;static >= &lsquo;a</li></ul><h3 id=误解4-我的代码没用到泛型也不含生命周期>误解4: 我的代码没用到泛型，也不含生命周期<a hidden class=anchor aria-hidden=true href=#误解4-我的代码没用到泛型也不含生命周期>#</a></h3><p>误解推论:</p><ul><li>避免使用泛型和生命周期是可能的</li></ul><p>这种安慰性的误解的存在是由于<code>Rust的生命周期省略规则</code>， 这些规则让你能够在函数中省略掉生命周期记号， 因为Rust的借用检查器能根据以下规则将它们推导出来：</p><ul><li>每个传入的引用都会有一个单独的生命周期</li><li>如果只有一个传入的生命周期，那么它将被应用到所有输出的引用上</li><li>如果有多个传入的生命周期，但其中一个是&amp;self或者&amp;mut self，那么这个生命周期将会被应用到所有输出的引用上</li><li>除此之外的输出的生命周期都必须显示标注出来</li></ul><p>如果一时间难以想明白这么多东西，那让我们来看一些例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>print</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>print</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>trim</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>trim</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 不合法，无法确定输出的生命周期，因为没有输入的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>get_str</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 显式的写法包括
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>get_str</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// 泛型版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>get_str</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// &#39;static 版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 不合法，无法确定输出的生命周期，因为有多个输入
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>overlap</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 显式(但仍有部分省略)的写法包括
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// 输出生命周期不能长于s
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// 输出生命周期不能长于t
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// 输出生命周期不能长于s和t
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>overlap</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// 输出生命周期可以长于s和t
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// 输入和输出的生命周期无关
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;b</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;b</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;b</span> <span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;b</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>overlap</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=p>,</span><span class=w> </span><span class=na>&#39;c</span><span class=o>&gt;</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>t</span>: <span class=kp>&amp;</span><span class=na>&#39;b</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;c</span> <span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>compare</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>compare</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果你曾写过</p><ul><li>结构体方法</li><li>接收引用的函数</li><li>返回引用的函数</li><li>泛型函数</li><li>trait object(后面会有更详细的讨论)</li><li>闭包(后面会有更详细的讨论)</li></ul><p>那么你的代码就有被省略的泛型生命周期记号。
<code>要点:</code></p><ul><li>几乎所有Rust代码都是泛型代码，到处都有被省略的生命周期记号</li></ul><h3 id=误解5-如果编译能通过那么我的生命周期标注就是正确的>误解5: 如果编译能通过，那么我的生命周期标注就是正确的<a hidden class=anchor aria-hidden=true href=#误解5-如果编译能通过那么我的生命周期标注就是正确的>#</a></h3><p>误解推论</p><ul><li>Rust对函数的的生命周期省略规则总是正确的</li><li>Rust的借用检查器在技术上和语义上总是正确的</li><li>Rust比我更了解我的程序的语义</li><li>Rust程序是有可能在技术上能通过编译，但语义上仍然是错的。来看一下这个例子：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>remainder</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=p>[</span><span class=kt>u8</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>byte</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>byte</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteIter</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>remainder</span>: <span class=nc>b</span><span class=s>&#34;1&#34;</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=sa>b</span><span class=sc>&#39;1&#39;</span><span class=p>),</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=nb>None</span><span class=p>,</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>ByteIter 是在字节切片上迭代的迭代器，为了简洁我们跳过对 Iterator trait的实现。 这看起来没什么问题，但如果我们想同时检查多个字节呢？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteIter</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>remainder</span>: <span class=nc>b</span><span class=s>&#34;1123&#34;</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>byte_1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>byte_2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>byte_1</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>byte_2</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 做点什么
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>啊哦！编译错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0499</span><span class=p>]</span>: <span class=nc>cannot</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=err>`</span><span class=n>bytes</span><span class=err>`</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>mutable</span><span class=w> </span><span class=n>more</span><span class=w> </span><span class=n>than</span><span class=w> </span><span class=n>once</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>time</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>main</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>20</span>:<span class=mi>18</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>19</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=kd>let</span><span class=w> </span><span class=n>byte_1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>                  </span><span class=o>-----</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=n>mutable</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=n>occurs</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>20</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=kd>let</span><span class=w> </span><span class=n>byte_2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>                  </span><span class=o>^^^^^</span><span class=w> </span><span class=n>second</span><span class=w> </span><span class=n>mutable</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=n>occurs</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>21</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=k>if</span><span class=w> </span><span class=n>byte_1</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>byte_2</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>        </span><span class=o>------</span><span class=w> </span><span class=n>first</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=n>later</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   
</span></span></span></code></pre></td></tr></table></div></div><p>我觉得我们可以拷贝每一个字节。拷贝在我们处理字节的时候是可行的， 但当我们从 ByteIter 转向泛型切片迭代器用来迭代任意 <code>&'a [T] </code>的时候 我们也会想到将来可能它会被应用到那些拷贝/克隆的代价很昂贵或根本不可能的类型上。 噢，我想我们对这没什么办法，代码能过编译，那么生命周期标记必然是对的不是吗？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>remainder</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=p>[</span><span class=kt>u8</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=o>&lt;</span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>byte</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>byte</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这一点帮助都没有，我仍然搞不明白。这里有个只有Rust专家才知道的小窍门： <code>给你的生命周期标记取个有描述性的名字。我们再试一次</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;remainder</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>remainder</span>: <span class=kp>&amp;</span><span class=na>&#39;remainder</span> <span class=p>[</span><span class=kt>u8</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;remainder</span><span class=o>&gt;</span><span class=w> </span><span class=n>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;remainder</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=o>&lt;</span><span class=na>&#39;mut_self</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;mut_self</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=na>&#39;mut_self</span><span class=w> </span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>byte</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>byte</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>每个返回的字节都被用<code>'mut_self</code>标记了，但这些字节显然是来自于<code>'remainder</code>的， 让我们来改一下。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;remainder</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>remainder</span>: <span class=kp>&amp;</span><span class=na>&#39;remainder</span> <span class=p>[</span><span class=kt>u8</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;remainder</span><span class=o>&gt;</span><span class=w> </span><span class=n>ByteIter</span><span class=o>&lt;</span><span class=na>&#39;remainder</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;&amp;</span><span class=na>&#39;remainder</span><span class=w> </span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>byte</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>remainder</span><span class=p>[</span><span class=mi>1</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>byte</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>bytes</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteIter</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>remainder</span>: <span class=nc>b</span><span class=s>&#34;1123&#34;</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>byte_1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>byte_2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>bytes</span><span class=p>.</span><span class=n>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>mem</span>::<span class=nb>drop</span><span class=p>(</span><span class=n>bytes</span><span class=p>);</span><span class=w> </span><span class=c1>// 我们甚至可以在这里把迭代器drop掉！
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>byte_1</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>byte_2</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// 做点什么
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>现在让我们回顾一下，我们前一版的程序显然是错误的，但为什么Rust仍然允许它通过编译呢？ 答案很简单：这么做是内存安全的。</p><p><code>Rust的借用检查器对程序的生命周期标记只要求到能够以静态的方式验证程序的内存安全</code>。 Rust会爽快地编译一个程序，即使它的生命周期标记有语义上的错误， 这带来的结果就是程序会变得过于受限。</p><p>来看一个与前一个相反的例子：Rust的生命周期省略规则恰好在这个例子上语义是正确的， 但我们却无意中用了一些多余的显式生命周期标记写了个非常受限的方法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>NumRef</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>i32</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>NumRef</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 我的结构体是在&#39;a上泛型的，所以我同样也要
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// 标记一下我的self参数，对吗？（答案是：不，不对）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>some_method</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>num_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>NumRef</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>num_ref</span><span class=p>.</span><span class=n>some_method</span><span class=p>();</span><span class=w> </span><span class=c1>// 可变借用num_ref直到它剩余的生命周期结束
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>num_ref</span><span class=p>.</span><span class=n>some_method</span><span class=p>();</span><span class=w> </span><span class=c1>// 编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>num_ref</span><span class=p>);</span><span class=w> </span><span class=c1>// 同样编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果我们有一个在 &lsquo;a 上的泛型，我们几乎永远不会想要写一个接收<code>&'a mut self</code>的方法。 因为这意味着我们告诉Rust，<code>这个方法会可变借用这个结构体直到整个结构体生命周期结束</code>。 这也就告诉Rust的借用检查器最<code>多只允许 some_method 被调用一次</code>， 在这之后这个结构体将会被永久性地可变借用走，也就变得不可用了。 这样的用例非常非常少，但处于困惑中的初学者非常容易写出这种代码，并能通过编译。 正确的做法是不要添加这些多余的显式生命周期标记，让Rust的生命周期省略规则来处理它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>NumRef</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>i32</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=n>NumRef</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 去掉mut self前面的&#39;a
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>some_method</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 上一段代码脱掉语法糖后变为
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>some_method_desugared</span><span class=o>&lt;</span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;b</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>num_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>NumRef</span><span class=p>(</span><span class=o>&amp;</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>num_ref</span><span class=p>.</span><span class=n>some_method</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>num_ref</span><span class=p>.</span><span class=n>some_method</span><span class=p>();</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>num_ref</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>要点:</code></p><ul><li>Rust的函数生命周期省略规则并不总是对所有情况都正确的</li><li>Rust对你的程序的语义了解并不比你多</li><li>给你的生命周期标记起一个更有描述性的名字</li><li>在你使用显式生命周期标记的时候要想清楚它们应该被用在哪以及为什么要这么用</li></ul><h3 id=误解6-装箱的trait对象没有生命周期>误解6: 装箱的trait对象没有生命周期<a hidden class=anchor aria-hidden=true href=#误解6-装箱的trait对象没有生命周期>#</a></h3><p>早前我们讨论了Rust对函数的生命周期省略规则。Rust同样有着对于trait对象的生命周期省略规则，它们是：</p><ul><li>如果一个trait对象作为一个类型参数传递到泛型中，那么它的生命约束会从它包含的类型中推断</li><li>如果包含的类型中有唯一的约束，那么就使用这个约束。</li><li>如果包含的类型中有超过一个约束，那么必须显式指定约束。</li></ul><p>如果以上都不适用，那么：</p><ul><li>如果trait是以单个生命周期约束定义的，那么就使用这个约束</li><li>如果所有生命周期约束都是 &lsquo;static 的，那么就使用 &lsquo;static 作为约束</li><li>如果trait没有生命周期约束，那么它的生命周期将会从表达式中推断，如果不在表达式中，那么就是 &lsquo;static 的</li></ul><p>这么多东西听起来超级复杂，但我们可以简单地总结为 &ldquo;<code>trait对象的生命周期约束是从上下文中推断出来的。</code>&rdquo; 在我们看过几个例子后，我们会发现生命周期约束推断其实是很符合直觉的，我们不需要去记这些很正式的规则。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>cell</span>::<span class=n>Ref</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开，Box&lt;T&gt;对T没有生命周期约束，所以被推断为&#39;static
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T3</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开, 因为&amp;&#39;a T 要求 T: &#39;a, 所以推断为 &#39;a
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T4</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=p>(</span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T5</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Ref</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开, 因为Ref&lt;&#39;a, T&gt; 要求 T: &#39;a, 所以推断为 &#39;a
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T6</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Ref</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>trait</span><span class=w> </span><span class=n>GenericTrait</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span>: <span class=na>&#39;a</span> <span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T7</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>GenericTrait</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>type</span> <span class=nc>T8</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>GenericTrait</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>GenericTrait</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 展开
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=k>dyn</span><span class=w> </span><span class=n>GenericTrait</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>实现了某个trait的具体的类型可以包含引用，因此它们同样拥有生命周期约束，且对应的trait对象也有生命周期约束。 你也可以直接为引用实现trait，而引用显然有生命周期约束。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Struct</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Ref</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>T</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Struct</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>Struct</span><span class=w> </span><span class=p>{}</span><span class=w> </span><span class=c1>// 直接在引用类型上实现Trait
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>impl</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Ref</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{}</span><span class=w> </span><span class=c1>// 在包含引用的类型上实现Trait
</span></span></span></code></pre></td></tr></table></div></div><p>不管怎样，这都值得我们仔细研究，因为新手们经常在将一个使用trait对象的函数重构成使用泛型的函数（或者反过来）的时候感到困惑。 我们来看看这个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dynamic_thread_print</span><span class=p>(</span><span class=n>t</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}).</span><span class=n>join</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>static_thread_print</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}).</span><span class=n>join</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这会抛出下面的编译错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0310</span><span class=p>]</span>: <span class=nc>the</span><span class=w> </span><span class=n>parameter</span><span class=w> </span><span class=k>type</span> <span class=err>`</span><span class=n>T</span><span class=err>`</span><span class=w> </span><span class=n>may</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>live</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>enough</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>10</span>:<span class=mi>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>9</span><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=k>fn</span> <span class=nf>static_thread_print</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>                        </span><span class=o>--</span><span class=w> </span><span class=n>help</span>: <span class=nc>consider</span><span class=w> </span><span class=n>adding</span><span class=w> </span><span class=n>an</span><span class=w> </span><span class=n>explicit</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>bound</span><span class=o>..</span><span class=p>.</span>: <span class=err>`</span><span class=n>T</span>: <span class=nb>&#39;static</span> <span class=o>+</span><span class=err>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>10</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>     </span><span class=o>^^^^^^^^^^^^^^^^^^</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>note</span>: <span class=o>..</span><span class=p>.</span><span class=n>so</span><span class=w> </span><span class=n>that</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=k>type</span> <span class=err>`</span><span class=p>[</span><span class=n>closure</span><span class=o>@</span><span class=n>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>10</span>:<span class=mi>24</span>: <span class=mi>12</span>:<span class=mi>6</span><span class=w> </span><span class=n>t</span>:<span class=nc>T</span><span class=p>]</span><span class=err>`</span><span class=w> </span><span class=n>will</span><span class=w> </span><span class=n>meet</span><span class=w> </span><span class=n>its</span><span class=w> </span><span class=n>required</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>bounds</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>10</span>:<span class=mi>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>10</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>     </span><span class=o>^^^^^^^^^^^^^^^^^^</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>很好，编译器告诉了我们怎么解决这个问题，我们来试试。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dynamic_thread_print</span><span class=p>(</span><span class=n>t</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}).</span><span class=n>join</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>static_thread_print</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}).</span><span class=n>join</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>编译通过，但这两个函数放在一块儿看起来有点怪，为什么第二个函数对 T 有 &lsquo;static 约束，而第一个没有？ 这个问题很刁钻。根据生命周期省略规则，Rust自动为第一个函数推断出 &lsquo;static 约束，所以两个函数实际上都有 &lsquo;static 约束。 在Rust编译器的眼中是这样的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>dynamic_thread_print</span><span class=p>(</span><span class=n>t</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}).</span><span class=n>join</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>static_thread_print</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Send</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>std</span>::<span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}).</span><span class=n>join</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>要点:</code></p><ul><li>所有trait对象都有着默认推断的生命周期约束</li></ul><h3 id=误解7-编译器报错信息会告诉我怎么修改我的代码>误解7: 编译器报错信息会告诉我怎么修改我的代码<a hidden class=anchor aria-hidden=true href=#误解7-编译器报错信息会告诉我怎么修改我的代码>#</a></h3><p>误解推论</p><ul><li>Rust编译器对于trait objects的生命周期省略规则总是对的</li><li>Rust编译器比我更懂我代码的语义</li></ul><p>这个误解是前两个误解的合二为一的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>box_displayable</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Display</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>抛出如下错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0310</span><span class=p>]</span>: <span class=nc>the</span><span class=w> </span><span class=n>parameter</span><span class=w> </span><span class=k>type</span> <span class=err>`</span><span class=n>T</span><span class=err>`</span><span class=w> </span><span class=n>may</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>live</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>enough</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>4</span>:<span class=mi>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>3</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>fn</span> <span class=nf>box_displayable</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Display</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                    </span><span class=o>--</span><span class=w> </span><span class=n>help</span>: <span class=nc>consider</span><span class=w> </span><span class=n>adding</span><span class=w> </span><span class=n>an</span><span class=w> </span><span class=n>explicit</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>bound</span><span class=o>..</span><span class=p>.</span>: <span class=err>`</span><span class=n>T</span>: <span class=nb>&#39;static</span> <span class=o>+</span><span class=err>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>4</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>     </span><span class=o>^^^^^^^^^^^</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>note</span>: <span class=o>..</span><span class=p>.</span><span class=n>so</span><span class=w> </span><span class=n>that</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=k>type</span> <span class=err>`</span><span class=n>T</span><span class=err>`</span><span class=w> </span><span class=n>will</span><span class=w> </span><span class=n>meet</span><span class=w> </span><span class=n>its</span><span class=w> </span><span class=n>required</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>bounds</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>4</span>:<span class=mi>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>4</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>     </span><span class=o>^^^^^^^^^^^</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>好吧，让我们照着编译器告诉我们的方式修改它，别在意这种改法基于了一个没有告知的事实： 编译器自动为我们的boxed trait object推断了一个&rsquo;static的生命周期约束。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>box_displayable</span><span class=o>&lt;</span><span class=n>T</span>: <span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Display</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>现在编译通过了，但这真的是我们想要的吗？可能是，也可能不是，编译去并没有告诉我们其它解决方法 但这个也许合适。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span>::<span class=n>Display</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>box_displayable</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=nc>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>t</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=n>Display</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个函数接收的参数和前一个版本一样，但多了不少东西。这样写能让它更好吗？不一定， 这取决于我们的程序的要求和约束。这个例子有些抽象，让我们来看看更简单明了的情况。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>return_first</span><span class=p>(</span><span class=n>a</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>报错:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0106</span><span class=p>]</span>: <span class=nc>missing</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>specifier</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>lib</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>1</span>:<span class=mi>38</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>1</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>fn</span> <span class=nf>return_first</span><span class=p>(</span><span class=n>a</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                    </span><span class=o>----</span><span class=w>     </span><span class=o>----</span><span class=w>     </span><span class=o>^</span><span class=w> </span><span class=n>expected</span><span class=w> </span><span class=n>named</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>parameter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>=</span><span class=w> </span><span class=n>help</span>: <span class=nc>this</span><span class=w> </span><span class=n>function</span><span class=na>&#39;s</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=k>type</span> <span class=nc>contains</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>borrowed</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>but</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>signature</span><span class=w> </span><span class=n>does</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>say</span><span class=w> </span><span class=n>whether</span><span class=w> </span><span class=n>it</span><span class=w> </span><span class=n>is</span><span class=w> </span><span class=n>borrowed</span><span class=w> </span><span class=n>from</span><span class=w> </span><span class=err>`</span><span class=n>a</span><span class=err>`</span><span class=w> </span><span class=n>or</span><span class=w> </span><span class=err>`</span><span class=n>b</span><span class=err>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>help</span>: <span class=nc>consider</span><span class=w> </span><span class=n>introducing</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>named</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>parameter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>1</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>fn</span> <span class=nf>return_first</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                </span><span class=o>^^^^</span><span class=w>    </span><span class=o>^^^^^^^</span><span class=w>     </span><span class=o>^^^^^^^</span><span class=w>     </span><span class=o>^^^</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个错误信息建议我们给输入和输出打上相同的生命周期标记。 这么做虽然能使得编译通过，但却过度限制了返回类型。 我们真正想要的是这个：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>return_first</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>要点:</code></p><ul><li>Rust对trait object的生命周期省略规则并不是在所有情况下都正确。</li><li>Rust不见得比你更懂你代码的语义。</li><li>Rust编译错误信息给出的修改建议可能能让你的代码编译通过，但这不一定是最符合你的要求的。</li></ul><h3 id=误解8-生命周期可以在运行时变长缩短>误解8: 生命周期可以在运行时变长缩短<a hidden class=anchor aria-hidden=true href=#误解8-生命周期可以在运行时变长缩短>#</a></h3><p>误解推论</p><ul><li>容器类型可以通过更换引用在运行时更改自己的生命周期</li></ul><p>Rust的借用检查会进行深入的控制流分析
这过不了编译：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Has</span><span class=o>&lt;</span><span class=na>&#39;lifetime</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lifetime</span>: <span class=kp>&amp;</span><span class=na>&#39;lifetime</span> <span class=kt>str</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>has</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Has</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lifetime</span>: <span class=kp>&amp;</span><span class=nc>long</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>short</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;short&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 换成短生命周期
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>short</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;short&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 换回长生命周期（并不行）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>long</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// `short`在这里析构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 编译错误，`short`在析构后仍处于借用状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0597</span><span class=p>]</span>: <span class=err>`</span><span class=n>short</span><span class=err>`</span><span class=w> </span><span class=n>does</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>live</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>enough</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>main</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>11</span>:<span class=mi>24</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>11</span><span class=w> </span><span class=o>|</span><span class=w>         </span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>short</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>                        </span><span class=o>^^^^^^</span><span class=w> </span><span class=n>borrowed</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=n>does</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>live</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>enough</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>15</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>     </span><span class=o>-</span><span class=w> </span><span class=err>`</span><span class=n>short</span><span class=err>`</span><span class=w> </span><span class=n>dropped</span><span class=w> </span><span class=n>here</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=n>still</span><span class=w> </span><span class=n>borrowed</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>16</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>     </span><span class=o>---------------------------------</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=n>later</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>下面这个代码同样过不了编译，报的错和上面一样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Has</span><span class=o>&lt;</span><span class=na>&#39;lifetime</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lifetime</span>: <span class=kp>&amp;</span><span class=na>&#39;lifetime</span> <span class=kt>str</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>has</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Has</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>lifetime</span>: <span class=kp>&amp;</span><span class=nc>long</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 这个代码块不会被执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=kc>false</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>short</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;short&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 换成短生命周期
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>short</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;short&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 换回长生命周期（并不行）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>long</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// `short`在这里析构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 仍旧编译错误，`short`在析构后仍处于借用状态
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>has</span><span class=p>.</span><span class=n>lifetime</span><span class=p>,</span><span class=w> </span><span class=s>&#34;long&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>生命周期只会在编译期被静态验证，并且Rust的借用检查只能做到基本的控制流分析， 它假设每个if-else中的代码块和match的每个分支都会被执行， 并且其中的每一个变量都能被指定一个最短的生命周期。<code> 一旦变量被指定了一个生命周期，它就一直受到这个生命周期约束</code>。变量的生命周期只能缩短， 并且所有缩短都会在编译器被确定。</p><p><code>要点:</code></p><ul><li>生命周期是在编译期静态验证的</li><li>生命周期不能在运行时变长、缩短或者改变</li><li>Rust的借用检查总是会为所有变量指定一个最短可能的生命周期，并且假定所有代码路径都会被执行</li></ul><h3 id=误解9-将可变引用降级为共享引用是安全的>误解9: 将可变引用降级为共享引用是安全的<a hidden class=anchor aria-hidden=true href=#误解9-将可变引用降级为共享引用是安全的>#</a></h3><p>误解推论</p><ul><li>重新借用一个引用会终止它的生命周期并且开始一个新的</li></ul><p>你可以向一个接收共享引用的函数传递一个可变引用，因为<code>Rust会隐式将可变引用重新借用为不可变引用</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>takes_shared_ref</span><span class=p>(</span><span class=n>n</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>takes_shared_ref</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>takes_shared_ref</span><span class=p>(</span><span class=o>&amp;*</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>a</span><span class=p>));</span><span class=w> </span><span class=c1>// 上一行的显式写法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>直觉上这没问题，将一个可变引用重新借用为不可变引用，应该不会有什么害处不是吗？ 然而并非如此，下面的代码过不了编译。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>&amp;*</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w> </span><span class=c1>// 重新借用为不可变
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>dbg!</span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0502</span><span class=p>]</span>: <span class=nc>cannot</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=err>`</span><span class=n>a</span><span class=err>`</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>immutable</span><span class=w> </span><span class=n>because</span><span class=w> </span><span class=n>it</span><span class=w> </span><span class=n>is</span><span class=w> </span><span class=n>also</span><span class=w> </span><span class=n>borrowed</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>mutable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>main</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>4</span>:<span class=mi>19</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>3</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=kd>let</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>&amp;*</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                     </span><span class=o>--------</span><span class=w> </span><span class=n>mutable</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=n>occurs</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>4</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=kd>let</span><span class=w> </span><span class=n>c</span>: <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>a</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                   </span><span class=o>^^</span><span class=w> </span><span class=n>immutable</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=n>occurs</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>5</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=fm>dbg!</span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>          </span><span class=o>-</span><span class=w> </span><span class=n>mutable</span><span class=w> </span><span class=n>borrow</span><span class=w> </span><span class=n>later</span><span class=w> </span><span class=n>used</span><span class=w> </span><span class=n>here</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可变借用出现后立即重新借用为不可变引用，然后可变引用自身析构。 为什么Rust会认为这个不可变的重新借用仍具有可变引用的独占生命周期？ 虽然上面这个例子没什么问题，但允许将可变引用降级为共享引用实际上引入了潜在的内存安全问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=n>Mutex</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>mutex</span>: <span class=nc>Mutex</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将self的可变引用降级为str的共享引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>get_string</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>mutex</span><span class=p>.</span><span class=n>get_mut</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>mutate_string</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 如果Rust允许将可变引用降级为共享引用，
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// 那么下面这行代码会使得所有从get_string中得到的共享引用失效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=o>*</span><span class=bp>self</span><span class=p>.</span><span class=n>mutex</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;surprise!&#34;</span><span class=p>.</span><span class=n>to_owned</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>mutex</span>: <span class=nc>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=s>&#34;string&#34;</span><span class=p>.</span><span class=n>to_owned</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>str_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>get_string</span><span class=p>();</span><span class=w> </span><span class=c1>// 可变引用降级为共享引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>s</span><span class=p>.</span><span class=n>mutate_string</span><span class=p>();</span><span class=w> </span><span class=c1>// str_ref失效，变为悬空指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>dbg!</span><span class=p>(</span><span class=n>str_ref</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译错误，和我们预期的一样
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这里的问题在于，当你将一个可变引用重新借用为共享引用，你会遇到一点麻烦： <code>即使可变引用已经析构，重新借用出来的共享引用还是会将可变引用的生命周期延长到和自己一样长</code>。 这种重新借用出来的共享引用非常难用，因为它不能与其它共享引用共存。 它有着可变引用和不可变引用的所有缺点，却没有它们各自的优点。 我认为将可变引用重新借用为共享引用应该被认为是Rust的反模式（anti-pattern)。 对这种反模式保持警惕很重要，这可以让你在看到下面这样的代码的时候更容易发现它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 将T的可变引用降级为共享引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>some_function</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>some_arg</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Struct</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将self的可变引用降级为self共享引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>some_method</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将self的可变引用降级为T的共享引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>other_method</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>T</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>即使你避免了函数和方法签名中的重新借用，Rust仍然会自动隐式重新借用， 所以很容易无意中遇到这样的问题：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>HashMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span> <span class=nc>PlayerID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Default)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Player</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>score</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>start_game</span><span class=p>(</span><span class=n>player_a</span>: <span class=nc>PlayerID</span><span class=p>,</span><span class=w> </span><span class=n>player_b</span>: <span class=nc>PlayerID</span><span class=p>,</span><span class=w> </span><span class=n>server</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>PlayerID</span><span class=p>,</span><span class=w> </span><span class=n>Player</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 从服务器中获取player，如果不存在则创建并插入一个新的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>player_a</span>: <span class=kp>&amp;</span><span class=nc>Player</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>server</span><span class=p>.</span><span class=n>entry</span><span class=p>(</span><span class=n>player_a</span><span class=p>).</span><span class=n>or_default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>player_b</span>: <span class=kp>&amp;</span><span class=nc>Player</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>server</span><span class=p>.</span><span class=n>entry</span><span class=p>(</span><span class=n>player_b</span><span class=p>).</span><span class=n>or_default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 用player做点什么
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>dbg!</span><span class=p>(</span><span class=n>player_a</span><span class=p>,</span><span class=w> </span><span class=n>player_b</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上面的代码编译失败。因为 or_default() 返回一个 &amp;mut Player， 而我们的显式类型标注 &amp;Player 使得这个 &amp;mut Player 被隐式重新借用为 &amp;Player 。 为了通过编译，我们不得不这样写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>collections</span>::<span class=n>HashMap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span> <span class=nc>PlayerID</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Default)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Player</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>score</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>start_game</span><span class=p>(</span><span class=n>player_a</span>: <span class=nc>PlayerID</span><span class=p>,</span><span class=w> </span><span class=n>player_b</span>: <span class=nc>PlayerID</span><span class=p>,</span><span class=w> </span><span class=n>server</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>PlayerID</span><span class=p>,</span><span class=w> </span><span class=n>Player</span><span class=o>&gt;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 因为我们不能把它们放在一起用，所以这里把返回的Player可变引用析构掉
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>server</span><span class=p>.</span><span class=n>entry</span><span class=p>(</span><span class=n>player_a</span><span class=p>).</span><span class=n>or_default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>server</span><span class=p>.</span><span class=n>entry</span><span class=p>(</span><span class=n>player_b</span><span class=p>).</span><span class=n>or_default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 再次获取这些Player，这次以不可变的方式，避免出现隐式重新借用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>player_a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>server</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>player_a</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>player_b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>server</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>player_b</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 用Player做点什么
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>dbg!</span><span class=p>(</span><span class=n>player_a</span><span class=p>,</span><span class=w> </span><span class=n>player_b</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>虽然有点尴尬和笨重，但这也算是为内存安全做出的牺牲。</p><p><code>要点:</code></p><ul><li>尽量不要把可变引用重新借用为共享引用，不然你会遇到不少麻烦</li><li>重新借用一个可变引用不会使得它的生命周期终结，即使这个可变引用已经析构</li></ul><h3 id=误解10-闭包遵循和函数相同的生命周期省略规则>误解10: 闭包遵循和函数相同的生命周期省略规则<a hidden class=anchor aria-hidden=true href=#误解10-闭包遵循和函数相同的生命周期省略规则>#</a></h3><p>比起误解，这更像是Rust的一个小陷阱。</p><p>闭包，虽然也是个函数，但是它并不遵循和函数相同的生命周期省略规则。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>closure</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span>: <span class=nc>lifetime</span><span class=w> </span><span class=n>may</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>live</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>enough</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>main</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>6</span>:<span class=mi>29</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>6</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=kd>let</span><span class=w> </span><span class=n>closure</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                       </span><span class=o>-</span><span class=w>   </span><span class=o>-</span><span class=w> </span><span class=o>^</span><span class=w> </span><span class=n>returning</span><span class=w> </span><span class=n>this</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=n>requires</span><span class=w> </span><span class=n>that</span><span class=w> </span><span class=err>`</span><span class=na>&#39;</span><span class=mi>1</span><span class=err>`</span><span class=w> </span><span class=n>must</span><span class=w> </span><span class=n>outlive</span><span class=w> </span><span class=err>`</span><span class=na>&#39;</span><span class=mi>2</span><span class=err>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                       </span><span class=o>|</span><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                       </span><span class=o>|</span><span class=w>   </span><span class=k>return</span><span class=w> </span><span class=k>type</span> <span class=nc>of</span><span class=w> </span><span class=n>closure</span><span class=w> </span><span class=n>is</span><span class=w> </span><span class=o>&amp;</span><span class=na>&#39;</span><span class=mi>2</span><span class=w> </span><span class=kt>i32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>|</span><span class=w>                       </span><span class=kd>let</span><span class=na>&#39;s</span><span class=w> </span><span class=n>call</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>lifetime</span><span class=w> </span><span class=n>of</span><span class=w> </span><span class=n>this</span><span class=w> </span><span class=n>reference</span><span class=w> </span><span class=err>`</span><span class=na>&#39;</span><span class=mi>1</span><span class=err>`</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>去掉语法糖后：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// 输入的生命周期应用到输出上
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>function</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 输入和输出有它们自己独有的生命周期
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>closure</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>for</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=p>,</span><span class=w> </span><span class=na>&#39;b</span><span class=o>&gt;</span><span class=w> </span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;b</span> <span class=kt>i32</span> <span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 注意：上面这行代码不是合法的语法，但可以表达出我们的意思
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>出现这种差异并没有一个好的理由。闭包最早的实现用的类型推断语义和函数不同， 现在变得没法改了，因为将它们统一起来会造成一个不兼容的改动。 那么我们要怎么样显式标注闭包的类型呢？我们可选的办法有：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 转成trait object，变成不定长类型，编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span>: <span class=nc>dyn</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 可以通过将它分配在堆上来绕过这个错误，但这样很笨重
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=k>dyn</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 也可以跳过分配，直接创建一个静态的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>&amp;|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 上一行去掉语法糖之后:)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=p>(</span><span class=k>dyn</span><span class=w> </span><span class=k>for</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span> <span class=o>+</span><span class=w> </span><span class=nb>&#39;static</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 理想中的写法是这样的，但这不是有效的语法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span>: <span class=nc>impl</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=o>=</span><span class=w> </span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 这样也不错，但也不是有效的语法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>for</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span><span class=o>|</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>i32</span> <span class=p>{</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// &#34;impl trait&#34;可以写在函数返回的位置，我们也可以这样写
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>return_identity</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>i32</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>|</span><span class=n>x</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>return_identity</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 前一种解决方案更泛化的写法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>annotate</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>F</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>identity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>annotate</span><span class=p>(</span><span class=o>|</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>i32</span><span class=o>|</span><span class=w> </span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>相信你已经注意到，在上面的例子中，<code>当闭包类型使用trait约束的时候会遵循一般函数的生命周期省略规则</code>。</p><p>这里没有什么真正的教训和洞察，只是它就是这样的而已。</p><p><code>要点:</code></p><ul><li>每一门语言都有自己的小陷阱 🤷</li></ul><h3 id=误解11-static-引用总能强制转换为-a-引用>误解11: &lsquo;static 引用总能强制转换为 &lsquo;a 引用<a hidden class=anchor aria-hidden=true href=#误解11-static-引用总能强制转换为-a-引用>#</a></h3><p>我前面给出了这个例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>get_str</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// 泛型版本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>get_str</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span><span class=p>;</span><span class=w> </span><span class=c1>// &#39;static版本
</span></span></span></code></pre></td></tr></table></div></div><p>有的读者问我这两个在实践中是否有区别。一开始我也不太确定，但不幸的是， 在经过一段时间的研究之后我发现它们在实践中确实存在着区别。</p><p>所以一般来说，在操作值得时候我们可以使用 &lsquo;static 引用来替换 &lsquo;a 引用， 因为Rust会自动将 &lsquo;static 引用强制转换到 &lsquo;a 引用。 直觉上来讲，这没毛病，在一个要求较短生命周期引用的地方使用一个有着更长的生命周期的引用不会造成内存安全问题。 下面的代码和我们想的一样编译通过：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rand</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>generic_str_fn</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;str&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>static_str_fn</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;str&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>a_or_b</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=nc>T</span><span class=p>,</span><span class=w> </span><span class=n>b</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>rand</span>::<span class=n>random</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>b</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>some_string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;string&#34;</span><span class=p>.</span><span class=n>to_owned</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>some_str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>some_string</span><span class=p>[</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>str_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a_or_b</span><span class=p>(</span><span class=n>some_str</span><span class=p>,</span><span class=w> </span><span class=n>generic_str_fn</span><span class=p>());</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>str_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a_or_b</span><span class=p>(</span><span class=n>some_str</span><span class=p>,</span><span class=w> </span><span class=n>static_str_fn</span><span class=p>());</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>然而，这种强制转换并不会在引用作为函数的类型签名的一部分的时候出现，所以下面这段代码无法通过编译：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rand</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>generic_str_fn</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;str&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>static_str_fn</span><span class=p>()</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nb>&#39;static</span> <span class=kt>str</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s>&#34;str&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>a_or_b_fn</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=p>(</span><span class=n>a</span>: <span class=nc>T</span><span class=p>,</span><span class=w> </span><span class=n>b_fn</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>rand</span>::<span class=n>random</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>b_fn</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>some_string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;string&#34;</span><span class=p>.</span><span class=n>to_owned</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>some_str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>some_string</span><span class=p>[</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>str_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a_or_b_fn</span><span class=p>(</span><span class=n>some_str</span><span class=p>,</span><span class=w> </span><span class=n>generic_str_fn</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译通过
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>str_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a_or_b_fn</span><span class=p>(</span><span class=n>some_str</span><span class=p>,</span><span class=w> </span><span class=n>static_str_fn</span><span class=p>);</span><span class=w> </span><span class=c1>// 编译错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>报错：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>error</span><span class=p>[</span><span class=n>E0597</span><span class=p>]</span>: <span class=err>`</span><span class=n>some_string</span><span class=err>`</span><span class=w> </span><span class=n>does</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>live</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>enough</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>-</span>-&gt; <span class=nc>src</span><span class=o>/</span><span class=n>main</span><span class=p>.</span><span class=n>rs</span>:<span class=mi>23</span>:<span class=mi>21</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>23</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=kd>let</span><span class=w> </span><span class=n>some_str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>some_string</span><span class=p>[</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>                     </span><span class=o>^^^^^^^^^^^</span><span class=w> </span><span class=n>borrowed</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=n>does</span><span class=w> </span><span class=n>not</span><span class=w> </span><span class=n>live</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>enough</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>..</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>25</span><span class=w> </span><span class=o>|</span><span class=w>     </span><span class=kd>let</span><span class=w> </span><span class=n>str_ref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>a_or_b_fn</span><span class=p>(</span><span class=n>some_str</span><span class=p>,</span><span class=w> </span><span class=n>static_str_fn</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w>                   </span><span class=o>----------------------------------</span><span class=w> </span><span class=n>argument</span><span class=w> </span><span class=n>requires</span><span class=w> </span><span class=n>that</span><span class=w> </span><span class=err>`</span><span class=n>some_string</span><span class=err>`</span><span class=w> </span><span class=n>is</span><span class=w> </span><span class=n>borrowed</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=err>`</span><span class=nb>&#39;static</span><span class=err>`</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=mi>26</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=o>|</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=err>`</span><span class=n>some_string</span><span class=err>`</span><span class=w> </span><span class=n>dropped</span><span class=w> </span><span class=n>here</span><span class=w> </span><span class=k>while</span><span class=w> </span><span class=n>still</span><span class=w> </span><span class=n>borrowed</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这算不算Rust的小陷阱还有待商榷，因为这不是 &&lsquo;static str 到 &&lsquo;a str 简单直接的强制转换， 而是 for<t> Fn() -> &&lsquo;static T 到 for&lt;&lsquo;a, T> Fn() -> &&lsquo;a T 这种更复杂的情况。 前者是值之间的强制转换，后者是类型之间的强制转换。</p><p><code>要点:</code></p><ul><li>签名为 for&lt;&lsquo;a, T> Fn() -> &&lsquo;a T 的函数要比签名为 for<t> fn() -> &&lsquo;static T 的函数更为灵活，并且能用在更多场景下</li></ul><h1 id=总结>总结:<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><ul><li>T 是 &amp;T 和 &amp;mut T 的超集</li><li>&amp;T 和 &amp;mut T 是不相交的集合</li><li>T: &lsquo;static 应该被读作 &ldquo;T 受 &lsquo;static 生命周期约束&rdquo;</li><li>如果 T: &lsquo;static 那么 T 可以是一个有着 &lsquo;static 生命周期的借用类型，或是一个所有权类型</li><li>既然 T: &lsquo;static 包含了所有权类型，那么意味着 T<ul><li>可以在运行时动态分配</li><li>不必在整个程序中都是有效的</li><li>可以被安全地任意修改</li><li>可以在运行时动态析构</li><li>可以有不同长度的生命周期</li></ul></li><li>T: &lsquo;a 比 &&lsquo;a T 更泛化、灵活</li><li>T: &lsquo;a 接收所有权类型、带引用的所有权类型，以及引用</li><li>&&lsquo;a T 只接收引用</li><li>如果 T: &lsquo;static 那么 T: &lsquo;a，因为对于所有 &lsquo;a 都有 &lsquo;static >= &lsquo;a</li><li>几乎所有Rust代码都是泛型的，到处都有省略的生命周期</li><li>Rust的生命周期省略规则并不是在任何情况下都对</li><li>Rust并不比你更了解你程序的语义</li><li>给生命周期标记起一个有描述性的名字</li><li>考虑清楚哪里需要显式写出生命周期标记，以及为什么要这么写</li><li>所有trait object都有默认推断的生命周期约束</li><li>Rust的编译错误信息可以让你的代码通过编译，但不一定是最符合你代码要求的</li><li>生命周期是在编译期静态验证的</li><li>生命周期不会以任何方式在运行时变长缩短</li><li>Rust的借用检查总会为每个变量选择一个最短可能的生命周期，并且假定每条代码路径都会被执行</li><li>尽量避免将可变引用重新借用为不可变引用，不然你会遇到不少麻烦</li><li>重新借用一个可变引用不会终止它的生命周期，即使这个可变引用已经析构</li><li>每个语言都有自己的小陷阱</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/rust/>Rust</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/storage/zookeeper%E4%B8%80%E8%87%B4%E4%BF%9D%E8%AF%81/><span class=title>« Prev</span><br><span>Zookeeper一致保证</span>
</a><a class=next href=https://reid00.github.io/en/posts/storage/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/><span class=title>Next »</span><br><span>知识图谱存储技术</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main></body></html>