<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust Leetcode链表实现 | Reid's Blog</title>
<meta name=keywords content="Option,Box"><meta name=description content="Rust Leetcode链表实现"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/langs_linux/rust-leetcode%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/langs_linux/rust-leetcode%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="Rust Leetcode链表实现"><meta property="og:description" content="Rust Leetcode链表实现"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/langs_linux/rust-leetcode%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-01T14:00:40+08:00"><meta property="article:modified_time" content="2024-02-01T14:00:40+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="Rust Leetcode链表实现"><meta name=twitter:description content="Rust Leetcode链表实现"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"学习的编程语言Golang，Python，Rust 和Linux 相关的记录 ","item":"https://reid00.github.io/en/posts/langs_linux/"},{"@type":"ListItem","position":3,"name":"Rust Leetcode链表实现","item":"https://reid00.github.io/en/posts/langs_linux/rust-leetcode%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Leetcode链表实现","name":"Rust Leetcode链表实现","description":"Rust Leetcode链表实现","keywords":["Option","Box"],"articleBody":"Rust LinkedList 定义 Leetcode: rust 如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Definition for singly-linked list. #[derive(PartialEq, Eq, Clone, Debug)] pub struct ListNode { pub val: i32, pub next: Option\u003cBox\u003cListNode\u003e\u003e, } impl ListNode { #[inline] fn new(val: i32) -\u003e Self { ListNode { next: None, val } } } /// 单链表 #[derive(Debug)] struct LinkedList\u003cT\u003e { head: Option\u003cBox\u003cNode\u003cT\u003e\u003e\u003e, } Go 如下:\n1 2 3 4 type ListNode struct { Val int Next *ListNode } 问题 1: 为什么 Rust 有ListNode之后还有LinkedList 定义? 与其他语言不通，Rust 中有所有权概念，在 Option","wordCount":"3111","inLanguage":"en","image":"https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png","datePublished":"2024-02-01T14:00:40+08:00","dateModified":"2024-02-01T14:00:40+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/langs_linux/rust-leetcode%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/langs_linux/>学习的编程语言Golang，Python，Rust 和Linux 相关的记录</a></div><h1 class="post-title entry-hint-parent">Rust Leetcode链表实现</h1><div class=post-description>Rust Leetcode链表实现</div><div class=post-meta><span title='2024-02-01 14:00:40 +0800 +0800'>2024-02-01 14:00</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;3111 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#rust-linkedlist-%e5%ae%9a%e4%b9%89 aria-label="Rust LinkedList 定义">Rust LinkedList 定义</a><ul><li><a href=#box-%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label="Box 的作用">Box 的作用</a></li><li><a href=#%e4%b8%8d%e4%bd%bf%e7%94%a8-box-%e5%8f%af%e8%a1%8c aria-label="不使用 Box 可行？">不使用 Box 可行？</a></li><li><a href=#%e5%92%8c-rcrefcellt-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="和 Rc<RefCell> 的区别">和 Rc&lt;RefCell> 的区别</a></li></ul></li><li><a href=#%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8%e5%ae%9e%e7%8e%b0 aria-label=反转链表实现>反转链表实现</a><ul><li><a href=#as_mutunwrapas_refunwrap-%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label="as_mut().unwrap()，.as_ref().unwrap() 的作用">as_mut().unwrap()，.as_ref().unwrap() 的作用</a></li><li><a href=#unwrap-%e4%b8%8d%e8%83%bd%e8%b0%83%e7%94%a8%e5%a4%9a%e6%ac%a1%e5%85%b6%e5%ae%9e%e6%98%af%e6%89%80%e6%9c%89%e6%9d%83%e9%97%ae%e9%a2%98 aria-label="unwrap() 不能调用多次，其实是所有权问题">unwrap() 不能调用多次，其实是所有权问题</a></li><li><a href=#optionfrom-%e5%92%8c-some-%e6%98%af%e4%b8%80%e6%a0%b7%e7%9a%84 aria-label="Option::from 和 Some 是一样的？">Option::from 和 Some 是一样的？</a></li><li><a href=#take-%e5%87%bd%e6%95%b0 aria-label="take 函数">take 函数</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=rust-linkedlist-定义>Rust LinkedList 定义<a hidden class=anchor aria-hidden=true href=#rust-linkedlist-定义>#</a></h1><p>Leetcode:
rust 如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Definition for singly-linked list.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#[derive(PartialEq, Eq, Clone, Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>ListNode</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>val</span>: <span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>next</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>ListNode</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>val</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ListNode</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>next</span>: <span class=nb>None</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// 单链表
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=cp>#[derive(Debug)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>LinkedList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>head</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Go 如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>ListNode</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=nx>Val</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>     <span class=nx>Next</span> <span class=o>*</span><span class=nx>ListNode</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>问题 1: 为什么 <code>Rust</code> 有<code>ListNode</code>之后还有<code>LinkedList</code> 定义?
与其他语言不通，<code>Rust</code> 中有所有权概念，在 Option&lt;Box<lisnode>>的实现中，next 节点不存在引用类型，暗含的意思就是：链表头是整个链表的拥有者，负责整个链表所占据内存的管理（包括最终销）。进一步说，<code>Rust</code> 中这样实现的链表和用 C++实现的链表是完全不同的：每个节点不再是独立存在的了，而是被先驱节点所管理，同时也管理着它的 next 字段后所有的后驱节点。
问题 2: 为什么 next 是 <code>Option&lt;Box&lt;LisNode>></code> 类型，而不是 ListNode？</p><ul><li>节点的 next 指向下一个节点，可能为空，故类型为 Option；</li><li>避免编译器无法计算节点大小，用 Box 包裹 Node；</li><li>next 实际上是用 Option 包裹的指向下个节点的 Box 指针，并且拥有下个节点的所有权；</li></ul><h2 id=box-的作用>Box 的作用<a hidden class=anchor aria-hidden=true href=#box-的作用>#</a></h2><p>在 <code>Rust</code> 中，<code>Box&lt;T></code> 是一个“箱子”类型，它在堆上存储数据。你可以把它看作是一个智能指针，用来封装和管理堆上的内存。</p><p>在这个 Node 结构体中，Box<node> 是一个指向堆上的 Node 实例的指针。Option&lt;Box<node>> 则意味着这个指针可能有值（即 Some(Box(Node))），也可能没有值（即 None）。</p><p>以下是 <code>Box&lt;T></code> 在这个上下文中的一些主要用途：</p><ul><li>递归数据结构：在定义递归或者链接的数据结构时，比如链表、树等，<code>Box&lt;T></code> 是必要的。在你的例子中，Node 结构体是一个链表节点，它有一个 next 字段指向下一个 Node。这个 next 字段需要使用 Box<node>，因为 Rust 需要知道 Node 结构体的确切大小，而 Box<node> 是一个固定大小的指针。</li><li>转移所有权：当你需要将值的所有权转移到其他函数或变量时，可以使用 <code>Box&lt;T></code>。<code>Box&lt;T></code> 拥有它所指向的值的所有权，当 <code>Box&lt;T></code> 被销毁时，它所指向的值也会被销毁。</li><li>大对象和内存管理：如果你有一个很大的对象或者需要手动管理内存，<code>Box&lt;T></code> 是一个很好的工具。因为 <code>Box&lt;T></code> 在堆上分配内存，当你不再需要这个值时，<code>Box&lt;T></code> 会自动回收它所使用的内存。</li></ul><p>以上就是 <code>Box&lt;T></code> 的一些主要用途。在你的例子中，<code>Box&lt;T></code> 主要用于定义递归的链表数据结构。</p><h2 id=不使用-box-可行>不使用 Box 可行？<a hidden class=anchor aria-hidden=true href=#不使用-box-可行>#</a></h2><p>在定义递归数据结构时，如链表或树，<code>Rust</code> 语言要求必须使用 Box 或者其他形式的间接寻址（如 Rc、Arc 等）。这是由 <code>Rust</code> 的所有权和内存安全性规则决定的。</p><p><code>Rust</code> 编译器需要在编译时就知道每种类型的确切大小。对于递归类型，例如链表节点 Node，如果不使用 Box 或其他形式的指针，Node 类型会有一个无限的大小。这是因为每个 Node 都包含另一个 Node，这形成了一个无限的嵌套。这会导致编译时错误，因为 <code>Rust</code> 无法确定类型的确切大小。</p><p>Box（以及 Rc、Arc 等）是一个固定大小的指针类型，它在堆上存储数据。这意味着，对于 Box<node> 类型，无论 Node 的实际大小如何，Box<node> 类型总是有一个固定的大小。这使得在 <code>Rust</code> 中定义递归类型成为可能。</p><p>所以，对于你的例子，如果你要在 Node 中定义一个指向另一个 Node 的字段，你必须使用 Box 或其他形式的指针。否则，你会得到一个编译错误。</p><h2 id=和-rcrefcellt-的区别>和 Rc&lt;RefCell<t>> 的区别<a hidden class=anchor aria-hidden=true href=#和-rcrefcellt-的区别>#</a></h2><p><code>Box</code> 和 <code>Rc&lt;RefCell&lt;T>></code> 都是 <code>Rust</code> 中的智能指针类型，但是它们的用途和行为不同。</p><p><code>Box&lt;T></code> 提供了在堆上分配一个值的能力，并拥有这个值的所有权。当 <code>Box</code> 被丢弃（drop）时，它包含的值也会被丢弃。<code>Box</code> 只有一个所有者。
Rc<t> 是一个引用计数类型，可以让一个值有多个所有者。每当你克隆一个 Rc 指针，引用计数就会增加。当一个 Rc 指针被丢弃时，引用计数就会减少。只有当引用计数为 0 时，值才会被丢弃。
RefCell<t> 提供了内部可变性。在 Rust 中，我们不能同时拥有一个值的可变引用和不可变引用。然而，有时我们可能需要在运行时改变一个值，即使我们拥有的是一个不可变引用。这就是 RefCell 发挥作用的地方。RefCell 允许我们在运行时借用和改变值，但是如果我们违反了借用规则（例如，同时拥有可变引用和不可变引用），RefCell 就会导致程序 panic。
当你看到 Option&lt;Rc&lt;RefCell<treenode>&#187; 时，这是因为在一些情况下（例如，在树或图结构中），我们需要一个节点有多个所有者，或者我们需要修改一个被多个地方引用的值。在这种情况下，我们就需要使用 Rc 和 RefCell。</p><p>然而，请注意，Rc&lt;RefCell<t>> 在运行时执行借用检查，可能会引发 panic，而且引用计数会增加运行时开销。在可以确定一个值只有一个所有者，并且不需要在运行时修改的情况下，使用 <code>Box&lt;T></code> 会更简单、更安全、更高效。</p><h1 id=反转链表实现>反转链表实现<a hidden class=anchor aria-hidden=true href=#反转链表实现>#</a></h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>reverse_list</span><span class=p>(</span><span class=n>head</span>: <span class=nb>Option</span><span class=o>&lt;</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;&gt;</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=nb>Box</span><span class=o>&lt;</span><span class=n>ListNode</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>prev</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>head</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cur</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>.</span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>node</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prev</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>prev</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>prev</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ListNode</span>::<span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>ListNode</span>::<span class=n>new</span><span class=p>(</span><span class=mi>2</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=n>next</span><span class=p>.</span><span class=n>as_mut</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>ListNode</span>::<span class=n>new</span><span class=p>(</span><span class=mi>3</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=n>next</span><span class=p>.</span><span class=n>as_mut</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>next</span><span class=p>.</span><span class=n>as_mut</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>ListNode</span>::<span class=n>new</span><span class=p>(</span><span class=mi>4</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>list</span><span class=p>.</span><span class=n>next</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>as_mut</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>next</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>as_mut</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>next</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>as_mut</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>ListNode</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>reversed_list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reverse_linked_list</span><span class=p>(</span><span class=nb>Option</span>::<span class=n>from</span><span class=p>(</span><span class=nb>Box</span>::<span class=n>from</span><span class=p>(</span><span class=n>list</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>reversed_list</span><span class=p>.</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>reversed_list</span><span class=p>.</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>next</span><span class=p>.</span><span class=n>as_ref</span><span class=p>().</span><span class=n>unwrap</span><span class=p>().</span><span class=n>value</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=mi>4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=as_mutunwrapas_refunwrap-的作用>as_mut().unwrap()，.as_ref().unwrap() 的作用<a hidden class=anchor aria-hidden=true href=#as_mutunwrapas_refunwrap-的作用>#</a></h2><p>在 Rust 中，.as_mut() 和 .as_ref() 方法通常被用来转换 Option 或 Result 类型。</p><ul><li><p>.as_mut() 是 Option 和 Result 类型的一个方法，用来将 Option<t> 或 Result&lt;T, E> 转换成 Option&lt;&amp;mut T> 或 Result&lt;&amp;mut T, &amp;mut E>。也就是说，它返回一个包含可变引用的新的 Option 或 Result。</p></li><li><p>.unwrap() 是 Option 和 Result 类型的一个方法，用来获取它们包含的值。如果 Option 是 Some(v)，它返回 v，如果 Option 是 None，它会 panic（意味着程序会立即停止，并给出一个错误信息）。对于 Result，如果它是 Ok(v)，它返回 v，如果它是 Err(e)，它也会 panic。</p></li><li><p>.as_ref() 是 Option 和 Result 类型的一个方法，用来将 Option<t> 或 Result&lt;T, E> 转换成 Option&lt;&amp;T> 或 Result&lt;&amp;T, &amp;E>。也就是说，它返回一个包含不可变引用的新的 Option 或 Result。</p></li><li><p>as_mut().unwrap() 和 as_ref().unwrap() 都被用来获取 Option&lt;Box<node>> 中的 Node。这样，你就可以修改或访问 Node 中的 value 和 next。因为 Option&lt;Box<node>> 中可能没有 Node（也就是它可能是 None），所以需要使用 unwrap() 来获取 Node。但是请注意，如果 Option&lt;Box<node>> 是 None，unwrap() 会引发 panic。为了避免这种情况，你需要在调用 unwrap() 之前确保 Option 不是 None。</p></li></ul><h2 id=unwrap-不能调用多次其实是所有权问题>unwrap() 不能调用多次，其实是所有权问题<a hidden class=anchor aria-hidden=true href=#unwrap-不能调用多次其实是所有权问题>#</a></h2><p>你遇到的这个错误是由于在 Rust 中的所有权规则所引起的。当你对 Option 类型的值调用 unwrap() 方法时，它会获取 Option 的所有权，这意味着原来的 Option 值将不能再使用。</p><p>这就是为什么你在 while 循环中多次使用 head.unwrap().next 时会遇到问题。在第一次调用 unwrap() 之后，head 就被移动（move）了，也就是说它的所有权被转移走了，所以你不能再次对 head 调用 unwrap()。</p><h2 id=optionfrom-和-some-是一样的>Option::from 和 Some 是一样的？<a hidden class=anchor aria-hidden=true href=#optionfrom-和-some-是一样的>#</a></h2><p>是的，你完全正确。在 Rust 中，Some(value) 和 Option::from(value) 是等价的。它们都会创建一个包含 value 的 Option 枚举值。</p><p>Some(value) 是更常见的使用方式，它直接创建了一个 Option::Some 枚举变量。例如：3</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>some_number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Option::from(value) 是 From trait 的一部分，这个 trait 用于定义如何将一种类型转换成另一种类型。Option::from 的定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nb>From</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>from</span><span class=p>(</span><span class=n>value</span>: <span class=nc>T</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>因此，Option::from(value) 实际上就是返回 Some(value)。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>some_number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Option</span>::<span class=n>from</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在大多数情况下，直接使用 Some(value) 会更简单和直观。</p><h2 id=take-函数>take 函数<a hidden class=anchor aria-hidden=true href=#take-函数>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=n>take</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=nb>None</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=mi>2</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这段代码中的 x.take() 方法是 Option 类型特有的方法。take() 方法将 Option 置为 None 并返回原来的值。</p><p>当你调用 x.take() 时，它会把 x 里面的值取出并返回，此时 x 的值就变为了 None，因为你已经取走了它的值。所以，在 x.take() 后，x 的值就是 None 了。</p><p>而 y 的值是 x.take() 的返回值，即 x 原来的值 Some(2)，所以 y 的值就是 Some(2)。</p><p>简单地说，x.take() 做了两件事：</p><p>将 x 设为 None。
返回 x 原来的值。
因此，x 在调用 take 之后的值是 None，而 y 的值就是 x 在调用 take 之前的值，即 Some(2)。</p><p>这就是为什么在 assert_eq!(x, None) 和 assert_eq!(y, Some(2)) 的断言语句都能通过，因为它们分别测试的是 x 和 y 的值，这些值都符合预期。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/option/>Option</a></li><li><a href=https://reid00.github.io/en/tags/box/>Box</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/><span class=title>« Prev</span><br><span>动态规划之完全背包问题</span>
</a><a class=next href=https://reid00.github.io/en/posts/os_network/for%E5%BE%AA%E7%8E%AF%E8%80%97%E6%97%B6%E4%BB%8E3.2%E7%A7%92%E9%99%8D%E5%88%B00.3%E7%A7%92/><span class=title>Next »</span><br><span>For循环耗时从3.2秒降到0.3秒</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>