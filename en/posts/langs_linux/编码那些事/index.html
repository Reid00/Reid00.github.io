<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编码那些事 | Reid's Blog</title>
<meta name=keywords content="编码"><meta name=description content="编码那些事"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/langs_linux/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/langs_linux/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="编码那些事"><meta property="og:description" content="编码那些事"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/langs_linux/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:35:14+08:00"><meta property="article:modified_time" content="2023-03-16T19:35:14+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="编码那些事"><meta name=twitter:description content="编码那些事"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"学习的编程语言Golang，Python，Rust 和Linux 相关的记录 ","item":"https://reid00.github.io/en/posts/langs_linux/"},{"@type":"ListItem","position":3,"name":"编码那些事","item":"https://reid00.github.io/en/posts/langs_linux/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"编码那些事","name":"编码那些事","description":"编码那些事","keywords":["编码"],"articleBody":"一直以来，编码问题像幽灵一般，不少开发人员都受过它的困扰。\n试想你请求一个数据，却得到一堆乱码，丈二和尚摸不着头脑。有同事质疑你的数据是乱码，虽然你很确定传了 UTF-8 ，却也无法自证清白，更别说帮同事 debug 了。\n有时，靠着百度和一手瞎调的手艺，乱码也能解决。尽管如此，还是很羡慕那些骨灰级程序员。为什么他们每次都能犀利地指出问题，并快速修复呢？原因在于，他们早就把编码问题背后的各种来龙去脉搞清楚了。\n本文从 ASCII 码说起，带你扒一扒编码背后那些事。相信搞清编码的原理后，你将不再畏惧任何编码问题。\n从 ASCII 码说起 现代计算机技术从英文国家兴起，最先遇到的也是英文文本。英文文本一般由 26 个字母、 10 个数字以及若干符号组成，总数也不过 100 左右。\n计算机中最基本的存储单位为 字节 ( byte )，由 8 个比特位( bit )组成，也叫做 八位字节 ( octet )。8 个比特位可以表示 $ 2^8 = 256 $ 个字符，看上去用字节来存储英文字符即可？\n计算机先驱们也是这么想的。他们为每个英文字符编号，再加上一些控制符，形成了我们所熟知的 ASCII 码表。实际上，由于英文字符不多，他们只用了字节的后 7 位而已。\n根据 ASCII 码表，由 01000001 这 8 个比特位组成的八位字节，代表字母 A 。\n顺便提一下，比特本身没有意义，比特 在 上下文 ( context )中才构成信息。举个例子，对于内存中一个字节 01000001 ，你将它看做一个整数，它就是 65 ；将它作为一个英文字符，它就是字母 A ；你看待比特的方式，就是所谓的上下文。\n所以，猜猜下面这个程序输出啥？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include int main(int argc, char *argv[]) { char value = 0x41; // as a number, value is 65 or 0x41 in hexadecimal printf(\"%d\\n\", value); // as a ASCII character, value is alphabet A printf(\"%c\\n\", value); return 0; } latin1 西欧人民来了，他们主要使用拉丁字母语言。与英语类似，拉丁字母数量并不大，大概也就是几十个。于是，西欧人民打起 ASCII 码表那个未用的比特位( b8 )的主意。\n还记得吗？ASCII 码表总共定义了 128 个字符，范围在 0~127 之间，字节最高位 b8 暂未使用。于是，西欧人民将拉丁字母和一些辅助符号(如欧元符号)定义在 128~255 之间。这就构成了 latin1 ，它是一个 8 位字符集，定义了以下字符：\n图中绿色部分是不可打印的( unprintable )控制字符，左半部分是 ASCII 码。因此，latin1 字符集是 ASCII 码的超集：\n一个字节掰成两半，欧美两兄弟各用一半。至此，欧美人民都玩嗨了，东亚人民呢？\nGB2312、GBK和GB18030 由于受到汉文化的影响，东亚地区主要是汉字圈，我们便以中文为例展开介绍。\n汉字有什么特点呢？—— 光常用汉字就有几千个，这可不是一个字节能胜任的。一个字节不够就两个呗。道理虽然如此，操作起来却未必这么简单。\n首先，将需要编码的汉字和 ASCII 码整理成一个字符集，例如 GB2312 。为什么需要 ASCII 码呢？因为，在计算机世界，不可避免要跟数字、英文字母打交道。至于拉丁字母，重要性就没那么大，也就无所谓了。\nGB2312 字符集总共收录了 6 千多个汉字，用两个字节来表示足矣，但事情远没有这么简单。同样的数字字符，在 GB2312 中占用 2 个字节，在 ASCII 码中占用 1 个字节，这不就不兼容了吗？计算机里太多东西涉及 ASCII 码了，看看一个 http 请求：\n1 2 GET / HTTP/1.1 Host: www.example.com 那么，怎么兼容 GB2312 和 ASCII 码呢？天无绝人之路， 变长 编码方案应运而生。\n变长编码方案，字符由长度不一的字节表示，有些字符只需 1 字节，有些需要 2 字节，甚至有些需要更多字节。GB2312 中的 ASCII 码与原来保持一致，还是用一个字节来表示，这样便解决了兼容问题。\n在 GB2312 中，如果一个字节最高位 b8 为 0 ，该字节便是单字节编码，即 ASCII 码。如果字节最高位 b8 为 1 ，它就是双字节编码的首字节，与其后字节一起表示一个字符。\n变长编码方案目的在于兼容 ASCII 码，但也带来一个问题：由于字节编码长度不一，定位第 N 个字符只能通过遍历实现，时间复杂度从 $ O(1) $ 退化到 $ O(N) $ 。好在这种操作场景并不多见，因此影响可以忽略。\nGB2312 收录的汉字个数只有常用的 6 千多个，遇到生僻字还是无能为力。因此，后来又推出了 GBK 和 GB18030 字符集。GBK 是 GB2312 的超集，完全兼容 GB2312 ；而 GB18030 又是 GBK 的超集，完全兼容 GBK 。\n因此，对中文编码文本进行解码，指定 GB18030 最为健壮：\n1 2 3 \u003e\u003e\u003e raw = b'\\xfd\\x88\\xb5\\xc4\\xb4\\xab\\xc8\\xcb' \u003e\u003e\u003e raw.decode('gb18030') '龍的传人' 指定 GBK 或 GB2312 就只好看运气了，GBK 多半还没事：\n1 2 \u003e\u003e\u003e raw.decode('gbk') '龍的传人' GB2312 经常直接抛锚不商量：\n1 2 3 4 \u003e\u003e\u003e raw.decode('gb2312') Traceback (most recent call last): File \"\", line 1, in \u003cmodule\u003e UnicodeDecodeError: 'gb2312' codec can't decode byte 0xfd in position 0: illegal multibyte sequence chardet 是一个不错的文本编码检测库，用起来很方便，但对中文编码支持不是很好。经常中文编码的文本进去，检测出来的结果是 GB2312 ，但一用 GB2312 解码就跪：\n1 2 3 4 5 6 7 8 \u003e\u003e\u003e import chardet \u003e\u003e\u003e raw = b'\\xd6\\xd0\\xb9\\xfa\\xc8\\xcb\\xca\\xc7\\xfd\\x88\\xb5\\xc4\\xb4\\xab\\xc8\\xcb' \u003e\u003e\u003e chardet.detect(raw) {'encoding': 'GB2312', 'confidence': 0.99, 'language': 'Chinese'} \u003e\u003e\u003e raw.decode('GB2312') Traceback (most recent call last): File \"\", line 1, in \u003cmodule\u003e UnicodeDecodeError: 'gb2312' codec can't decode byte 0xfd in position 8: illegal multibyte sequence 掌握 GB2312 、 GBK 、 GB18030 三者的关系后，我们可以略施小计。如果 chardet 检测出来结果是 GB2312 ，就用 GB18030 去解码，大概率可以成功！\n1 2 \u003e\u003e\u003e raw.decode('GB18030') '中国人是龍的传人' Unicode GB2312 、 GBK 与 GB18030 都是中文编码字符集。虽然 GB18030 也包含日韩表意文字，算是国际字符集，但毕竟是以中文为主，无法适应全球化应用。\n在计算机发展早期，不同国家都推出了自己的字符集和编码方案，互不兼容。中文编码的文本在使用日文编码的系统上是无法显示的，这就给国际交往带来障碍。\n这时，英雄出现了。统一码联盟 站出来说要发展一个通用的字符集，收录世界上所有字符，这就是 Unicode 。经过多年发展， Unicode 已经成为世界上最通用的字符集，也是计算机科学领域的业界标准。\nUnicode 已经收录的字符数量已经超过 13 万个，每个字符需占用超过 2 字节。由于常用编程语言一般没有 24 位数字类型，因此一般用 32 位数字表示一个字符。这样一来，同样的一个英文字母，在 ASCII 中只需占用 1 字节，在 Unicode 则需要占用 4 字节！英美人民都要哭了，试想你磁盘中的文件大小都增大了 4 倍是什么感受！\nUTF-8 为了兼容 ASCII 并优化文本空间占用，我们需要一种变长字节编码方案，这就是著名的 UTF-8 。与 GB2312 等中文编码一样，UTF-8 用不固定的字节数来表示字符：\nASCII 字符 Unicode 码位由 U+0000 至 U+007F ，用 1 个字节编码，最高位为 0 ； 码位由 U+0080 至 U+07FF 的字符，用 2 个字节编码，首字节以 110 开头，其余字节以 10 开头； 码位由 U+0800 至 U+FFFF 的字符，用 3 个字节编码，首字节以 1110 开头，其余字节同样以 10 开头； 4 至 6 字节编码的情况以此类推； 如图，以 0 开头的字节为 单字节 编码，总共 7 个有效编码位，编码范围为 U+0000 至 U+007F ，刚好对应 ASCII 码所有字符。以 110 开头的字节为 双字节 编码，总共 11 个有效编码位，最大值是 0x7FF ，因此编码范围为 U+0080 至 U+07FF ；以 1110 开头的字节为 三字节 编码，总共 16 个有效编码位，最大值是 0xFFFF 因此编码范围为 U+0800 至 U+FFFF 。\n根据开头不同， UTF-8 流中的字节，可以分为以下几类：\n| 字节最高位 | 类别 | 有效位 | |:——– |:—–|:——| | 0 | 单字节编码 | 7 | | 10 | 多字节编码非首字节 | | | 110 | 双字节编码首字节 | 11 | | 1110 | 三字节编码首字节 | 16 | | 11110 | 四字节编码首字节 | 21 | | 111110 | 五字节编码首字节 | 26 | | 1111110 | 六字节编码首字节 | 31 |\n至此，我们已经具备了读懂 UTF-8 编码字节流的能力，不信来看一个例子：\n概念回顾 一直以来，字符集 和 编码 这两个词一直是混着用的。现在，我们总算有能力厘清这两者间的关系了。\n字符集 顾名思义，就是由一定数量字符组成的集合，每个字符在集合中有唯一编号。前文提及的 ASCII 、 latin1 、 GB2312 、GBK 、GB18030 以及 Unicode 等，无一例外，都是字符集。\n计算机存储和网络通讯的基本单位都是 字节 ，因此文本必须以 字节序列 的形式进行存储或传输。那么，字符编号如何转化成字节呢？这就是 编码 要回答的问题。\n在 ASCII 码和 latin 中，字符编号与字节一一对应，这是一种编码方式。GB2312 则采用变长字节，这是另一种编码方式。而 Unicode 则存在多种编码方式，除了 最常用的 UTF-8 编码，还有 UTF-16 等。实际上，UTF-16 编码效率比 UTF-8 更高，但由于无法兼容 ASCII ，应用范围受到很大制约。\n最佳实践 认识文本编码的前世今生之后，应该如何规避编码问题呢？是否存在一些最佳实践呢？答案是肯定的。\n编码选择 项目开始前，需要选择一种适应性广的编码方案，UTF-8 是首选，好处多多：\nUnicode 是业界标准，编码字符数量最多，天然支持国际化； UTF-8 完全兼容 ASCII 码，这是硬性指标； UTF-8 目前应用最广； 如因历史原因，不得不使用中文编码方案，则优先选择 GB18030 。这个标准最新，涵盖字符最多，适应性最强。尽量避免采用 GBK ，特别是 GB2312 等老旧编码标准。\n编程习惯 如果你使用的编程语言，字符串类型支持 Unicode ，那问题就简单了。由于 Unicode 字符串肯定不会导致诸如乱码等编码问题，你只需在输入和输出环节稍加留意。\n举个例子，Python 从 3 以后， str 就是 Unicode 字符串了，而 bytes 则是 字节序列 。因此，在 Python 3 程序中，核心逻辑应该统一用 str 类型，避免使用 bytes 。文本编码、解码操作则统一在程序的输入、输出层中进行。\n假如你正在开发一个 API 服务，数据库数据编码是 GBK ，而用户却使用 UTF-8 编码。那么，在程序 输入层 ， GBK 数据从数据库读出后，解码转换成 Unicode 数据，再进入核心层处理。在程序 核心层 ，数据以 Unicode 形式进行加工处理。由于核心层处理逻辑可能很复杂，统一采用 Unicode 可以减少问题的发生。最后，在程序的 输出层 将数据以 UTF-8 编码，再返回给客户端。\n整个过程伪代码大概如下：\n1 2 3 4 5 6 7 8 9 10 11 # input # read gbk data from database and decode it to unicode data = read_from_database().decode('gbk') # core # process unicode data only result = process(data) # output # encoding unicode data into utf8 response_to_user(result.encode('utf8')) 这样的程序结构看起来跟个三明治一样，非常形象：\n当然了，还有很多编程语言字符串还不支持 Unicode 。Python 2 中的 str 对象，跟 Python 3 中的 bytes 比较像，只是字节序列；C 语言中的字符串甚至更原始。\n这都无关紧要，好的编程习惯是相通的：程序核心层统一使用某种编码，输入输出层则负责编码转换。至于核心层使用何种编码，主要看程序中哪种编码使用最多，一般是跟数据库编码保持一致即可。\n","wordCount":"727","inLanguage":"en","datePublished":"2023-03-16T19:35:14+08:00","dateModified":"2023-03-16T19:35:14+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/langs_linux/%E7%BC%96%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/langs_linux/>学习的编程语言Golang，Python，Rust 和Linux 相关的记录</a></div><h1 class=post-title>编码那些事</h1><div class=post-description>编码那些事</div><div class=post-meta><span title='2023-03-16 19:35:14 +0800 +0800'>2023-03-16</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;727 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%8e-ascii-%e7%a0%81%e8%af%b4%e8%b5%b7 aria-label="从 ASCII 码说起">从 ASCII 码说起</a></li><li><a href=#latin1 aria-label=latin1>latin1</a></li><li><a href=#gb2312gbk%e5%92%8cgb18030 aria-label=GB2312、GBK和GB18030>GB2312、GBK和GB18030</a></li><li><a href=#unicode aria-label=Unicode>Unicode</a></li><li><a href=#utf-8 aria-label=UTF-8>UTF-8</a></li><li><a href=#%e6%a6%82%e5%bf%b5%e5%9b%9e%e9%a1%be aria-label=概念回顾>概念回顾</a></li><li><a href=#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-label=最佳实践>最佳实践</a><ul><li><a href=#%e7%bc%96%e7%a0%81%e9%80%89%e6%8b%a9 aria-label=编码选择>编码选择</a></li><li><a href=#%e7%bc%96%e7%a8%8b%e4%b9%a0%e6%83%af aria-label=编程习惯>编程习惯</a></li></ul></li></ul></div></details></div><div class=post-content><p>一直以来，编码问题像幽灵一般，不少开发人员都受过它的困扰。</p><p>试想你请求一个数据，却得到一堆乱码，丈二和尚摸不着头脑。有同事质疑你的数据是乱码，虽然你很确定传了 <em>UTF-8</em> ，却也无法自证清白，更别说帮同事 <em>debug</em> 了。</p><p>有时，靠着百度和一手瞎调的手艺，乱码也能解决。尽管如此，还是很羡慕那些骨灰级程序员。为什么他们每次都能犀利地指出问题，并快速修复呢？原因在于，他们早就把编码问题背后的各种来龙去脉搞清楚了。</p><p>本文从 <a href=https://en.wikipedia.org/wiki/ASCII>ASCII</a> 码说起，带你扒一扒编码背后那些事。相信搞清编码的原理后，你将不再畏惧任何编码问题。</p><h2 id=从-ascii-码说起>从 ASCII 码说起<a hidden class=anchor aria-hidden=true href=#从-ascii-码说起>#</a></h2><p>现代计算机技术从英文国家兴起，最先遇到的也是英文文本。英文文本一般由 <em>26</em> 个字母、 <em>10</em> 个数字以及若干符号组成，总数也不过 <em>100</em> 左右。</p><p>计算机中最基本的存储单位为 <strong>字节</strong> ( <em>byte</em> )，由 <em>8</em> 个比特位( <em>bit</em> )组成，也叫做 <strong>八位字节</strong> ( <em>octet</em> )。<em>8</em> 个比特位可以表示 $ 2^8 = 256 $ 个字符，看上去用字节来存储英文字符即可？</p><p>计算机先驱们也是这么想的。他们为每个英文字符编号，再加上一些控制符，形成了我们所熟知的 <a href=https://en.wikipedia.org/wiki/ASCII>ASCII</a> 码表。实际上，由于英文字符不多，他们只用了字节的后 <em>7</em> 位而已。</p><p><img loading=lazy src=https://pic2.zhimg.com/v2-34c4ee73f5a263f7507be44ec041f2b5_r.jpg alt=img></p><p>根据 <em>ASCII</em> 码表，由 <em>01000001</em> 这 <em>8</em> 个比特位组成的八位字节，代表字母 <em>A</em> 。</p><p><img loading=lazy src=https://pic4.zhimg.com/v2-8c012682a8e8cd76144f2af118a40f17_r.jpg alt=img></p><p>顺便提一下，比特本身没有意义，<strong>比特</strong> 在 <strong>上下文</strong> ( <em>context</em> )中才构成信息。举个例子，对于内存中一个字节 <em>01000001</em> ，你将它看做一个整数，它就是 <em>65</em> ；将它作为一个英文字符，它就是字母 <em>A</em> ；你看待比特的方式，就是所谓的上下文。</p><p>所以，猜猜下面这个程序输出啥？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>value</span> <span class=o>=</span> <span class=mh>0x41</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// as a number, value is 65 or 0x41 in hexadecimal
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// as a ASCII character, value is alphabet A
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%c</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=latin1>latin1<a hidden class=anchor aria-hidden=true href=#latin1>#</a></h2><p>西欧人民来了，他们主要使用拉丁字母语言。与英语类似，拉丁字母数量并不大，大概也就是几十个。于是，西欧人民打起 <em>ASCII</em> 码表那个未用的比特位( <em>b8</em> )的主意。</p><p>还记得吗？<em>ASCII</em> 码表总共定义了 <em>128</em> 个字符，范围在 <em>0~127</em> 之间，字节最高位 <em>b8</em> 暂未使用。于是，西欧人民将拉丁字母和一些辅助符号(如欧元符号)定义在 <em>128~255</em> 之间。这就构成了 <a href=https://en.wikipedia.org/wiki/ISO/IEC_8859-1>latin1</a> ，它是一个 <em>8</em> 位字符集，定义了以下字符：</p><p><img loading=lazy src=https://pic3.zhimg.com/v2-26071488b77ade56def7624c9acf7676_r.jpg alt=img></p><p>图中绿色部分是不可打印的( <em>unprintable</em> )控制字符，左半部分是 <em>ASCII</em> 码。因此，<em>latin1</em> 字符集是 <em>ASCII</em> 码的超集：</p><p><img loading=lazy src=https://pic3.zhimg.com/80/v2-f1c482cd3f4ebe5efa5a319b3f129976_720w.jpg alt=img></p><p>一个字节掰成两半，欧美两兄弟各用一半。至此，欧美人民都玩嗨了，东亚人民呢？</p><h2 id=gb2312gbk和gb18030>GB2312、GBK和GB18030<a hidden class=anchor aria-hidden=true href=#gb2312gbk和gb18030>#</a></h2><p>由于受到汉文化的影响，东亚地区主要是汉字圈，我们便以中文为例展开介绍。</p><p>汉字有什么特点呢？—— 光常用汉字就有几千个，这可不是一个字节能胜任的。一个字节不够就两个呗。道理虽然如此，操作起来却未必这么简单。</p><p>首先，将需要编码的汉字和 <em>ASCII</em> 码整理成一个字符集，例如 <a href=https://zh.wikipedia.org/wiki/GB_2312>GB2312</a> 。为什么需要 <em>ASCII</em> 码呢？因为，在计算机世界，不可避免要跟数字、英文字母打交道。至于拉丁字母，重要性就没那么大，也就无所谓了。</p><p><img loading=lazy src=https://pic2.zhimg.com/80/v2-81f13318ecd2e0084f35f1c9ad59acbd_720w.jpg alt=img></p><p><em>GB2312</em> 字符集总共收录了 <em>6</em> 千多个汉字，用两个字节来表示足矣，但事情远没有这么简单。同样的数字字符，在 <em>GB2312</em> 中占用 <em>2</em> 个字节，在 <em>ASCII</em> 码中占用 <em>1</em> 个字节，这不就不兼容了吗？计算机里太多东西涉及 <em>ASCII</em> 码了，看看一个 <em>http</em> 请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>www.example.com</span>
</span></span></code></pre></td></tr></table></div></div><p>那么，怎么兼容 <em>GB2312</em> 和 <em>ASCII</em> 码呢？天无绝人之路， <strong>变长</strong> 编码方案应运而生。</p><p>变长编码方案，字符由长度不一的字节表示，有些字符只需 <em>1</em> 字节，有些需要 <em>2</em> 字节，甚至有些需要更多字节。<em>GB2312</em> 中的 <em>ASCII</em> 码与原来保持一致，还是用一个字节来表示，这样便解决了兼容问题。</p><p>在 <em>GB2312</em> 中，如果一个字节最高位 <em>b8</em> 为 <em>0</em> ，该字节便是单字节编码，即 <em>ASCII</em> 码。如果字节最高位 <em>b8</em> 为 <em>1</em> ，它就是双字节编码的首字节，与其后字节一起表示一个字符。</p><p><img loading=lazy src=https://pic1.zhimg.com/v2-a9082ea700d6a7cb9ec73eee1183d98c_r.jpg alt=img></p><p>变长编码方案目的在于兼容 <em>ASCII</em> 码，但也带来一个问题：由于字节编码长度不一，定位第 <em>N</em> 个字符只能通过遍历实现，时间复杂度从 $ O(1) $ 退化到 $ O(N) $ 。好在这种操作场景并不多见，因此影响可以忽略。</p><p><em>GB2312</em> 收录的汉字个数只有常用的 <em>6</em> 千多个，遇到生僻字还是无能为力。因此，后来又推出了 <a href=https://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83>GBK</a> 和 <a href=https://zh.wikipedia.org/wiki/GB_18030>GB18030</a> 字符集。<em>GBK</em> 是 <em>GB2312</em> 的超集，完全兼容 <em>GB2312</em> ；而 <em>GB18030</em> 又是 <em>GBK</em> 的超集，完全兼容 <em>GBK</em> 。</p><p><img loading=lazy src=https://pic1.zhimg.com/80/v2-574dee89f03758cdcd9de1ed91b159a8_720w.jpg alt=img></p><p>因此，对中文编码文本进行解码，指定 <em>GB18030</em> 最为健壮：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>raw</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\xfd\x88\xb5\xc4\xb4\xab\xc8\xcb</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>raw</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;gb18030&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;龍的传人&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>指定 <em>GBK</em> 或 <em>GB2312</em> 就只好看运气了，<em>GBK</em> 多半还没事：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>raw</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;gbk&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;龍的传人&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p><em>GB2312</em> 经常直接抛锚不商量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>raw</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;gb2312&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
</span></span><span class=line><span class=cl><span class=n>File</span> <span class=s2>&#34;&lt;stdin&gt;&#34;</span><span class=p>,</span> <span class=n>line</span> <span class=mi>1</span><span class=p>,</span> <span class=ow>in</span> <span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=ne>UnicodeDecodeError</span><span class=p>:</span> <span class=s1>&#39;gb2312&#39;</span> <span class=n>codec</span> <span class=n>can</span><span class=s1>&#39;t decode byte 0xfd in position 0: illegal multibyte sequence</span>
</span></span></code></pre></td></tr></table></div></div><p><a href=https://chardet.readthedocs.io/en/latest/>chardet</a> 是一个不错的文本编码检测库，用起来很方便，但对中文编码支持不是很好。经常中文编码的文本进去，检测出来的结果是 <em>GB2312</em> ，但一用 <em>GB2312</em> 解码就跪：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=kn>import</span> <span class=nn>chardet</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>raw</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\xd6\xd0\xb9\xfa\xc8\xcb\xca\xc7\xfd\x88\xb5\xc4\xb4\xab\xc8\xcb</span><span class=s1>&#39;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>chardet</span><span class=o>.</span><span class=n>detect</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=s1>&#39;encoding&#39;</span><span class=p>:</span> <span class=s1>&#39;GB2312&#39;</span><span class=p>,</span> <span class=s1>&#39;confidence&#39;</span><span class=p>:</span> <span class=mf>0.99</span><span class=p>,</span> <span class=s1>&#39;language&#39;</span><span class=p>:</span> <span class=s1>&#39;Chinese&#39;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>raw</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;GB2312&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
</span></span><span class=line><span class=cl><span class=n>File</span> <span class=s2>&#34;&lt;stdin&gt;&#34;</span><span class=p>,</span> <span class=n>line</span> <span class=mi>1</span><span class=p>,</span> <span class=ow>in</span> <span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=ne>UnicodeDecodeError</span><span class=p>:</span> <span class=s1>&#39;gb2312&#39;</span> <span class=n>codec</span> <span class=n>can</span><span class=s1>&#39;t decode byte 0xfd in position 8: illegal multibyte sequence</span>
</span></span></code></pre></td></tr></table></div></div><p>掌握 <em>GB2312</em> 、 <em>GBK</em> 、 <em>GB18030</em> 三者的关系后，我们可以略施小计。如果 <em>chardet</em> 检测出来结果是 <em>GB2312</em> ，就用 <em>GB18030</em> 去解码，大概率可以成功！</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>raw</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;GB18030&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=s1>&#39;中国人是龍的传人&#39;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=unicode>Unicode<a hidden class=anchor aria-hidden=true href=#unicode>#</a></h2><p><em>GB2312</em> 、 <em>GBK</em> 与 <em>GB18030</em> 都是中文编码字符集。虽然 <em>GB18030</em> 也包含日韩表意文字，算是国际字符集，但毕竟是以中文为主，无法适应全球化应用。</p><p>在计算机发展早期，不同国家都推出了自己的字符集和编码方案，互不兼容。中文编码的文本在使用日文编码的系统上是无法显示的，这就给国际交往带来障碍。</p><p>这时，英雄出现了。<strong>统一码联盟</strong> 站出来说要发展一个通用的字符集，收录世界上所有字符，这就是 <a href=https://zh.wikipedia.org/wiki/Unicode>Unicode</a> 。经过多年发展， <em>Unicode</em> 已经成为世界上最通用的字符集，也是计算机科学领域的业界标准。</p><p><em>Unicode</em> 已经收录的字符数量已经超过 <em>13</em> 万个，每个字符需占用超过 <em>2</em> 字节。由于常用编程语言一般没有 <em>24</em> 位数字类型，因此一般用 <em>32</em> 位数字表示一个字符。这样一来，同样的一个英文字母，在 <em>ASCII</em> 中只需占用 <em>1</em> 字节，在 <em>Unicode</em> 则需要占用 <em>4</em> 字节！英美人民都要哭了，试想你磁盘中的文件大小都增大了 <em>4</em> 倍是什么感受！</p><h2 id=utf-8>UTF-8<a hidden class=anchor aria-hidden=true href=#utf-8>#</a></h2><p>为了兼容 <em>ASCII</em> 并优化文本空间占用，我们需要一种变长字节编码方案，这就是著名的 <a href=https://zh.wikipedia.org/wiki/UTF-8>UTF-8</a> 。与 <em>GB2312</em> 等中文编码一样，<em>UTF-8</em> 用不固定的字节数来表示字符：</p><ol><li><em>ASCII</em> 字符 <em>Unicode</em> 码位由 <em>U+0000</em> 至 <em>U+007F</em> ，用 <em>1</em> 个字节编码，最高位为 <em>0</em> ；</li><li>码位由 <em>U+0080</em> 至 <em>U+07FF</em> 的字符，用 <em>2</em> 个字节编码，首字节以 <em>110</em> 开头，其余字节以 <em>10</em> 开头；</li><li>码位由 <em>U+0800</em> 至 <em>U+FFFF</em> 的字符，用 <em>3</em> 个字节编码，首字节以 <em>1110</em> 开头，其余字节同样以 <em>10</em> 开头；</li><li><em>4</em> 至 <em>6</em> 字节编码的情况以此类推；</li></ol><p><img loading=lazy src=https://pic2.zhimg.com/v2-5e6ca5df3ff1b2b4fb21896d7ba777d5_r.jpg alt=img></p><p>如图，以 <em>0</em> 开头的字节为 <strong>单字节</strong> 编码，总共 <em>7</em> 个有效编码位，编码范围为 <em>U+0000</em> 至 <em>U+007F</em> ，刚好对应 <em>ASCII</em> 码所有字符。以 <em>110</em> 开头的字节为 <strong>双字节</strong> 编码，总共 <em>11</em> 个有效编码位，最大值是 <em>0x7FF</em> ，因此编码范围为 <em>U+0080</em> 至 <em>U+07FF</em> ；以 <em>1110</em> 开头的字节为 <strong>三字节</strong> 编码，总共 <em>16</em> 个有效编码位，最大值是 <em>0xFFFF</em> 因此编码范围为 <em>U+0800</em> 至 <em>U+FFFF</em> 。</p><p>根据开头不同， <em>UTF-8</em> 流中的字节，可以分为以下几类：</p><p>| 字节最高位 | 类别 | 有效位 | |:&mdash;&mdash;&ndash; |:&mdash;&ndash;|:&mdash;&mdash;| | 0 | 单字节编码 | 7 | | 10 | 多字节编码非首字节 | | | 110 | 双字节编码首字节 | 11 | | 1110 | 三字节编码首字节 | 16 | | 11110 | 四字节编码首字节 | 21 | | 111110 | 五字节编码首字节 | 26 | | 1111110 | 六字节编码首字节 | 31 |</p><p>至此，我们已经具备了读懂 <em>UTF-8</em> 编码字节流的能力，不信来看一个例子：</p><p><img loading=lazy src=https://pic2.zhimg.com/v2-61341d7068a82da48ba6edd136240b99_r.jpg alt=img></p><h2 id=概念回顾>概念回顾<a hidden class=anchor aria-hidden=true href=#概念回顾>#</a></h2><p>一直以来，<strong>字符集</strong> 和 <strong>编码</strong> 这两个词一直是混着用的。现在，我们总算有能力厘清这两者间的关系了。</p><p><strong>字符集</strong> 顾名思义，就是由一定数量字符组成的集合，每个字符在集合中有唯一编号。前文提及的 <em>ASCII</em> 、 <em>latin1</em> 、 <em>GB2312</em> 、<em>GBK</em> 、<em>GB18030</em> 以及 <em>Unicode</em> 等，无一例外，都是字符集。</p><p>计算机存储和网络通讯的基本单位都是 <strong>字节</strong> ，因此文本必须以 <strong>字节序列</strong> 的形式进行存储或传输。那么，字符编号如何转化成字节呢？这就是 <strong>编码</strong> 要回答的问题。</p><p>在 <em>ASCII</em> 码和 <em>latin</em> 中，字符编号与字节一一对应，这是一种编码方式。<em>GB2312</em> 则采用变长字节，这是另一种编码方式。而 <em>Unicode</em> 则存在多种编码方式，除了 最常用的 <em>UTF-8</em> 编码，还有 <em>UTF-16</em> 等。实际上，<em>UTF-16</em> 编码效率比 <em>UTF-8</em> 更高，但由于无法兼容 <em>ASCII</em> ，应用范围受到很大制约。</p><h2 id=最佳实践>最佳实践<a hidden class=anchor aria-hidden=true href=#最佳实践>#</a></h2><p>认识文本编码的前世今生之后，应该如何规避编码问题呢？是否存在一些最佳实践呢？答案是肯定的。</p><h3 id=编码选择>编码选择<a hidden class=anchor aria-hidden=true href=#编码选择>#</a></h3><p>项目开始前，需要选择一种适应性广的编码方案，<em>UTF-8</em> 是首选，好处多多：</p><ul><li><em>Unicode</em> 是业界标准，编码字符数量最多，天然支持国际化；</li><li><em>UTF-8</em> 完全兼容 <em>ASCII</em> 码，这是硬性指标；</li><li><em>UTF-8</em> 目前应用最广；</li></ul><p>如因历史原因，不得不使用中文编码方案，则优先选择 <em>GB18030</em> 。这个标准最新，涵盖字符最多，适应性最强。尽量避免采用 <em>GBK</em> ，特别是 <em>GB2312</em> 等老旧编码标准。</p><h3 id=编程习惯>编程习惯<a hidden class=anchor aria-hidden=true href=#编程习惯>#</a></h3><p>如果你使用的编程语言，字符串类型支持 <em>Unicode</em> ，那问题就简单了。由于 <em>Unicode</em> 字符串肯定不会导致诸如乱码等编码问题，你只需在输入和输出环节稍加留意。</p><p>举个例子，<em>Python</em> 从 <em>3</em> 以后， <em>str</em> 就是 <em>Unicode</em> 字符串了，而 <em>bytes</em> 则是 <strong>字节序列</strong> 。因此，在 <em>Python 3</em> 程序中，核心逻辑应该统一用 <em>str</em> 类型，避免使用 <em>bytes</em> 。文本编码、解码操作则统一在程序的输入、输出层中进行。</p><p>假如你正在开发一个 <em>API</em> 服务，数据库数据编码是 <em>GBK</em> ，而用户却使用 <em>UTF-8</em> 编码。那么，在程序 <strong>输入层</strong> ， <em>GBK</em> 数据从数据库读出后，解码转换成 <em>Unicode</em> 数据，再进入核心层处理。在程序 <strong>核心层</strong> ，数据以 <em>Unicode</em> 形式进行加工处理。由于核心层处理逻辑可能很复杂，统一采用 <em>Unicode</em> 可以减少问题的发生。最后，在程序的 <strong>输出层</strong> 将数据以 <em>UTF-8</em> 编码，再返回给客户端。</p><p>整个过程伪代码大概如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># input</span>
</span></span><span class=line><span class=cl><span class=c1># read gbk data from database and decode it to unicode</span>
</span></span><span class=line><span class=cl><span class=n>data</span> <span class=o>=</span> <span class=n>read_from_database</span><span class=p>()</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;gbk&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># core</span>
</span></span><span class=line><span class=cl><span class=c1># process unicode data only</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>process</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># output</span>
</span></span><span class=line><span class=cl><span class=c1># encoding unicode data into utf8</span>
</span></span><span class=line><span class=cl><span class=n>response_to_user</span><span class=p>(</span><span class=n>result</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf8&#39;</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>这样的程序结构看起来跟个三明治一样，非常形象：</p><p><img loading=lazy src=https://pic3.zhimg.com/v2-aa82169c206fb91d1ee358fbde13bfae_r.jpg alt=img></p><p>当然了，还有很多编程语言字符串还不支持 <em>Unicode</em> 。<em>Python 2</em> 中的 <em>str</em> 对象，跟 <em>Python 3</em> 中的 <em>bytes</em> 比较像，只是字节序列；<em>C</em> 语言中的字符串甚至更原始。</p><p>这都无关紧要，好的编程习惯是相通的：程序核心层统一使用某种编码，输入输出层则负责编码转换。至于核心层使用何种编码，主要看程序中哪种编码使用最多，一般是跟数据库编码保持一致即可。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/%E7%BC%96%E7%A0%81/>编码</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/other/%E6%9D%BF%E7%93%A6%E5%B7%A5%E6%90%AD%E5%BB%BAvps%E6%90%AD%E5%BB%BAvpn/><span class=title>« Prev</span><br><span>板瓦工搭建VPS搭建vpn</span>
</a><a class=next href=https://reid00.github.io/en/posts/algo/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/><span class=title>Next »</span><br><span>搜索引擎背后的经典数据结构和算法</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>