<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySql高频面试问题 | Reid's Blog</title>
<meta name=keywords content="MySql,面试"><meta name=description content="MySql高频面试问题"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/storage/mysql%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/storage/mysql%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="MySql高频面试问题"><meta property="og:description" content="MySql高频面试问题"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/storage/mysql%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:35:07+08:00"><meta property="article:modified_time" content="2023-03-16T19:35:07+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="MySql高频面试问题"><meta name=twitter:description content="MySql高频面试问题"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"存储, 分布式相关的文章","item":"https://reid00.github.io/en/posts/storage/"},{"@type":"ListItem","position":3,"name":"MySql高频面试问题","item":"https://reid00.github.io/en/posts/storage/mysql%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySql高频面试问题","name":"MySql高频面试问题","description":"MySql高频面试问题","keywords":["MySql","面试"],"articleBody":"本文主要受众为开发人员,所以不涉及到MySQL的服务部署等操作,且内容较多,大家准备好耐心和瓜子矿泉水。\n前一阵系统的学习了一下MySQL,也有一些实际操作经验,偶然看到一篇和MySQL相关的面试文章,发现其中的一些问题自己也回答不好,虽然知识点大部分都知道,但是无法将知识串联起来。\n因此决定搞一个MySQL灵魂100问,试着用回答问题的方式,让自己对知识点的理解更加深入一点。\n此文不会事无巨细的从select的用法开始讲解mysql,主要针对的是开发人员需要知道的一些MySQL的知识点\n主要包括索引,事务,优化等方面,以在面试中高频的问句形式给出答案。\nMySQL 重要笔记 三万字、91道MySQL面试题（收藏版）\nhttps://mp.weixin.qq.com/s/KRWyl-zU1Cd6sxbya4dP_g\n书写高质量SQL的30条建议\nhttps://mp.weixin.qq.com/s/nM6fwEyi2VZeRMWtdZGpGQ\n数据分析面试必备SQL语句+语法\nhttps://mp.weixin.qq.com/s/8UZAaDyB38gsZANPLxNKgg\n索引相关 关于MySQL的索引,曾经进行过一次总结,文章链接在这里 Mysql索引原理及其优化.\n1. 什么是索引?\n索引是一种数据结构,可以帮助我们快速的进行数据的查找.\n2. 索引是个什么样的数据结构呢?\n索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.\n3. Hash索引和B+树所有有什么区别或者说优劣呢?\n首先要知道Hash索引和B+树索引的底层实现原理:\nhash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.\n对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.\n那么可以看出他们有以下的不同:\nhash索引进行等值查询更快(一般情况下),但是却无法进行范围查询. 因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.\n而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.\nhash索引不支持使用索引进行排序,原理同上.\nhash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性.\nhash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.\nhash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.\n因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.\n4. 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?\n在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引.\n在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.\n当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.\n5. 非聚簇索引一定会回表查询吗?\n不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.\n举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age \u003c 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.\n6. 在建立索引的时候,都有哪些需要考虑的因素呢?\n建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.\n此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.\n7. 联合索引是什么?为什么需要注意联合索引中的顺序?\nMySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.\n具体原因为:\nMySQL使用索引时需要索引有序,假设现在建立了\"name,age,school\"的联合索引\n那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.\n当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,以此类推.\n因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.\n8. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?\nMySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息.\n可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.\n9. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?\n使用不等于查询\n列参与了数学运算或者函数\n在字符串like时左边是通配符.类似于’%aaa'.\n当mysql分析全表扫描比使用索引快的时候不使用索引.\n当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.\n以上情况,MySQL无法使用索引.\n9. 那MySQL索引使用有哪些注意事项呢？\n索引哪些情况会失效\n查询条件包含or，可能导致索引失效 如何字段类型是字符串，where时一定用引号括起来，否则索引失效 like通配符可能导致索引失效。 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。 在索引列上使用mysql的内置函数，索引失效。 对索引列运算（如，+、-、*、/），索引失效。 索引字段上使用（！= 或者 \u003c \u003e，not in）时，可能会导致索引失效。 索引字段上使用is null， is not null，可能导致索引失效。 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。 mysql估计使用全表扫描要比使用索引快,则不使用索引。 后端程序员必备：索引失效的十大杂症\n索引不适合哪些场景\n数据量少的不适合加索引 更新比较频繁的也不适合加索引 区分度低的字段不适合加索引（如性别） 索引的一些潜规则\n覆盖索引 回表 索引数据结构（B+树） 最左前缀原则 索引下推 MySQL遇到过死锁问题吗，你是如何解决的？\n我排查死锁的一般步骤是酱紫的：\n查看死锁日志show engine innodb status; 找出死锁Sql 分析sql加锁情况 模拟死锁案发 分析死锁日志 分析死锁结果 可以看我这两篇文章哈：\n手把手教你分析Mysql死锁问题 Mysql死锁如何排查：insert on duplicate死锁一次排查分析过程 日常工作中你是怎么优化SQL的？\n可以从这几个维度回答这个问题：\n加索引 避免返回不必要的数据 适当分批量进行 优化sql结构 分库分表 读写分离 可以看我这篇文章哈：后端程序员必备：书写高质量SQL的30条建议\n数据库索引的原理，为什么要用B+树，为什么不用二叉树？\n可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？\n为什么不是一般二叉树？\n如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。\n为什么不是平衡二叉树呢？\n我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。\n那为什么不是B树而是B+树呢？\n1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。\n2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。\n可以看这篇文章哈：再有人问你为什么MySQL用B+树做索引，就把这篇文章发给她\ndetails link : https://mp.weixin.qq.com/s/Ctz6yB2131ZIzCOFrsgfMw\n事务相关 1. 什么是事务?\n理解什么是事务最经典的就是转账的栗子,相信大家也都了解,这里就不再说一边了.\n事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败.但是只是这样还不够的.\n2. ACID是什么?可以详细说一下吗?\nA=Atomicity\n原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.\nC=Consistency\n系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.\nI=Isolation\n隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.\nD=Durability\n持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.\n3. 同时有多个事务在进行会怎么样呢?\n多事务的并发进行一般会造成以下几个问题:\n脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.\n不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.\n幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成\"幻觉\".\n4. 怎么解决这些问题呢?MySQL的事务隔离级别了解吗?\nMySQL的四种隔离级别如下:\n未提交读(READ UNCOMMITTED) 这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).\n这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.\n已提交读(READ COMMITTED) 其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.\nREPEATABLE READ(可重复读) 可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是幻读\n当你读取id\u003e 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥\n那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.\nSERIALIZABLE(可串行化) 这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.\n5. Innodb使用的是哪种隔离级别呢?\nInnoDB默认使用的是可重复读隔离级别.\n6. 对MySQL的锁了解吗?\n当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.\n就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.\n7. MySQL都有哪些锁呢?像上面那样子进行锁定岂不是有点阻碍并发效率了?\n从锁的类别上来讲,有共享锁和排他锁.\n共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.\n排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.\n用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.\n锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.\n他们的加锁开销从大大小,并发能力也是从大到小.\n表结构设计 说说分库与分表的设计\n分库分表方案，分库分表中间件，分库分表可能遇到的问题\n分库分表方案:\n水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。 常用的分库分表中间件：\nsharding-jdbc（当当） Mycat TDDL（淘宝） Oceanus(58同城数据库中间件) vitess（谷歌开发的数据库中间件） Atlas(Qihoo 360) InnoDB与MyISAM的区别\nInnoDB支持事务，MyISAM不支持事务 InnoDB支持外键，MyISAM不支持外键 InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持 select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。 Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引） InnoDB支持表、行级锁，而MyISAM支持表级锁。 InnoDB表必须有主键，而MyISAM可以没有主键 Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。 Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。 InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引 1. 为什么要尽量设定一个主键?\n主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.\n设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.\n2. 主键使用自增ID还是UUID?\n推荐使用自增ID,不要使用UUID.\n因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的\n也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)\n如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.\n总之,在数据量大一些的情况下,用自增主键性能会好一些.\n图片来源于《高性能MySQL》: 其中默认后缀为使用自增ID,_uuid为使用UUID为主键的测试,测试了插入100w行和300w行的性能.\n关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.\nIf you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index.\nIf you do not define a PRIMARY KEY for your table, MySQL picks the first UNIQUE index that has only NOT NULL columns as the primary key and InnoDB uses it as the clustered index.\n3. 字段为什么要求定义为not null?\nMySQL官网这样介绍:\nNULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.\nnull值会占用更多的字节,且会在程序中造成很多与预期不符的情况.\n4. 如果要存储用户的密码散列,应该使用什么字段进行存储?\n密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.\n存储引擎相关 1. MySQL支持哪些存储引擎?\nMySQL支持多种存储引擎,比如InnoDB,MyISAM,Memory,Archive等等.\n在大多数的情况下,直接选择使用InnoDB引擎都是最合适的,InnoDB也是MySQL的默认存储引擎.\nInnoDB和MyISAM有什么区别? InnoDB支持事物，而MyISAM不支持事物\nInnoDB支持行级锁，而MyISAM支持表级锁\nInnoDB支持MVCC, 而MyISAM不支持\nInnoDB支持外键，而MyISAM不支持\nInnoDB不支持全文索引，而MyISAM支持。\n零散问题 1. MySQL中的varchar和char有什么区别.\nchar是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用10个字符,而varchar是变长的\n也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.\n在检索效率上来讲,char \u003e varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则应该尽量使用varchar.例如存储用户MD5加密后的密码,则应该使用char.\n2. varchar(10)和int(10)代表什么含义?\nvarchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.\n也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.\n3. MySQL的binlog有有几种录入格式?分别有什么区别?\n有三种格式,statement,row和mixed.\nstatement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.\nrow级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.\nmixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.\n此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.\n4. 超大分页怎么处理?\n超大的分页一般从两个方向上来解决.\n数据库层面,这也是我们主要集中关注的(虽然收效没那么大)\n类似于select * from table where age \u003e 20 limit 1000000,10这种查询其实也是有可以优化的余地的.\n这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢.\n我们可以修改为select * from table where id in (select id from table where age \u003e 20 limit 1000000,10)\n这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快.\n同时如果ID连续的好,我们还可以select * from table where id \u003e 1000000 limit 10,效率也是不错的\n优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.\n从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.\n解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.\n在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.\n5. 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?\n在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.\n慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?\n所以优化也是针对这三个方向来的,\n首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.\n分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.\n如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.\n6. 上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?\n横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.\n我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的.\n假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.\n纵向分表是按列分表.假设我们现在有一张文章表.包含字段id-摘要-内容.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要\n当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.\n我们可以将上面的表分为两张.id-摘要,id-内容.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.\n当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.\n**7. 什么是存储过程？**有哪些优缺点？\n存储过程是一些预编译的SQL语句。\n1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块\n这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。\n2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全\n但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程\n我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁\n在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.\n8. 说一说三个范式\n第一范式: 每个列都不可以再拆分.\n第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分.\n第三范式: 非主键列只依赖于主键,不依赖于其他非主键.\n在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.\n9. MyBatis 中的 #\n乱入了一个奇怪的问题…..我只是想单独记录一下这个问题,因为出现频率太高了.\n# 会将传入的内容当做字符串,而$会直接将传入值拼接在sql语句中.\n所以#可以在一定程度上预防sql注入攻击。\n为什么不要用 SELECT * 不需要的列会增加数据传输时间和网络开销 用“SELECT * ”数据库需要解析更多的对象、字段、权限、属性等相关内容，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。 增大网络开销；* 有时会误带上如log、IconMD5之类的无用且大文本字段，数据传输size会几何增涨。如果DB和应用程序不在同一台机器，这种开销非常明显\n即使 mysql 服务器和客户端是在同一台机器上，使用的协议还是 tcp，通信也是需要额外的时间。\n对于无用的大字段，如 varchar、blob、text，会增加 io 操作 准确来说，长度超过 728 字节的时候，会先把超出的数据序列化到另外一个地方，因此读取这条记录会增加一次 io 操作。（MySQL InnoDB）\n失去MySQL优化器“覆盖索引”策略优化的可能性 SELECT * 杜绝了覆盖索引的可能性，而基于MySQL优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式。\n","wordCount":"9777","inLanguage":"en","image":"https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png","datePublished":"2023-03-16T19:35:07+08:00","dateModified":"2023-03-16T19:35:07+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/storage/mysql%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/storage/>存储, 分布式相关的文章</a></div><h1 class="post-title entry-hint-parent">MySql高频面试问题</h1><div class=post-description>MySql高频面试问题</div><div class=post-meta><span title='2023-03-16 19:35:07 +0800 +0800'>2023-03-16 19:35</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;9777 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#mysql-%e9%87%8d%e8%a6%81%e7%ac%94%e8%ae%b0 aria-label="MySQL 重要笔记">MySQL 重要笔记</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e7%9b%b8%e5%85%b3 aria-label=索引相关>索引相关</a></li><li><a href=#%e4%ba%8b%e5%8a%a1%e7%9b%b8%e5%85%b3 aria-label=事务相关>事务相关</a></li><li><a href=#%e8%a1%a8%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label=表结构设计>表结构设计</a></li><li><a href=#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e7%9b%b8%e5%85%b3 aria-label=存储引擎相关>存储引擎相关</a></li><li><a href=#%e9%9b%b6%e6%95%a3%e9%97%ae%e9%a2%98 aria-label=零散问题>零散问题</a><ul><ul><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%a6%81%e7%94%a8-select- aria-label="为什么不要用 SELECT *">为什么不要用 SELECT *</a></li></ul></ul></ul></li></ul></div></details></div><div class=post-content><p>本文主要受众为开发人员,所以不涉及到MySQL的服务部署等操作,且内容较多,大家准备好耐心和瓜子矿泉水。</p><p>前一阵系统的学习了一下MySQL,也有一些实际操作经验,偶然看到一篇和MySQL相关的面试文章,发现其中的一些问题自己也回答不好,虽然知识点大部分都知道,但是无法将知识串联起来。</p><p>因此决定搞一个MySQL灵魂100问,试着用回答问题的方式,让自己对知识点的理解更加深入一点。</p><p>此文不会事无巨细的从select的用法开始讲解mysql,主要针对的是开发人员需要知道的一些MySQL的知识点</p><p>主要包括索引,事务,优化等方面,以在面试中高频的问句形式给出答案。</p><h2 id=mysql-重要笔记>MySQL 重要笔记<a hidden class=anchor aria-hidden=true href=#mysql-重要笔记>#</a></h2><blockquote><p>三万字、91道MySQL面试题（收藏版）</p><p><a href=https://mp.weixin.qq.com/s/KRWyl-zU1Cd6sxbya4dP_g>https://mp.weixin.qq.com/s/KRWyl-zU1Cd6sxbya4dP_g</a></p><p>书写高质量SQL的30条建议</p><p><a href=https://mp.weixin.qq.com/s/nM6fwEyi2VZeRMWtdZGpGQ>https://mp.weixin.qq.com/s/nM6fwEyi2VZeRMWtdZGpGQ</a></p><p><strong>数据分析面试必备SQL语句+语法</strong></p><p><a href=https://mp.weixin.qq.com/s/8UZAaDyB38gsZANPLxNKgg>https://mp.weixin.qq.com/s/8UZAaDyB38gsZANPLxNKgg</a></p></blockquote><h2 id=索引相关>索引相关<a hidden class=anchor aria-hidden=true href=#索引相关>#</a></h2><p>关于MySQL的索引,曾经进行过一次总结,文章链接在这里 Mysql索引原理及其优化.</p><p><strong>1. 什么是索引?</strong></p><p>索引是一种数据结构,可以帮助我们快速的进行数据的查找.</p><p><strong>2. 索引是个什么样的数据结构呢?</strong></p><p>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有Hash索引,B+树索引等,而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引.</p><p><strong>3. Hash索引和B+树所有有什么区别或者说优劣呢?</strong></p><p>首先要知道Hash索引和B+树索引的底层实现原理:</p><p>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.</p><p>对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.</p><p>那么可以看出他们有以下的不同:</p><ul><li>hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</li></ul><p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.</p><p>而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</p><ul><li><p>hash索引不支持使用索引进行排序,原理同上.</p></li><li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.<strong>AAAA</strong>和<strong>AAAAB</strong>的索引没有相关性.</p></li><li><p>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</p></li><li><p>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</p></li></ul><p>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</p><p><strong>4. 上面提到了B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?</strong></p><p>在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引.</p><p>在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.</p><p>当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询.</p><p><strong>5. 非聚簇索引一定会回表查询吗?</strong></p><p>不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.</p><p>举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行<code>select age from employee where age &lt; 20</code>的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.</p><p><strong>6. 在建立索引的时候,都有哪些需要考虑的因素呢?</strong></p><p>建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.</p><p>此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.</p><p><strong>7. 联合索引是什么?为什么需要注意联合索引中的顺序?</strong></p><p>MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.</p><p>具体原因为:</p><p>MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引</p><p>那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.</p><p>当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,以此类推.</p><p>因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.</p><p><strong>8. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?</strong></p><p>MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息.</p><p>可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.</p><p><strong>9. 那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?</strong></p><ul><li><p>使用不等于查询</p></li><li><p>列参与了数学运算或者函数</p></li><li><p>在字符串like时左边是通配符.类似于&rsquo;%aaa'.</p></li><li><p>当mysql分析全表扫描比使用索引快的时候不使用索引.</p></li><li><p>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.</p></li></ul><p>以上情况,MySQL无法使用索引.</p><p><strong>9. 那MySQL索引使用有哪些注意事项呢？</strong></p><p><strong>索引哪些情况会失效</strong></p><ul><li>查询条件包含or，可能导致索引失效</li><li>如何字段类型是字符串，where时一定用引号括起来，否则索引失效</li><li>like通配符可能导致索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用mysql的内置函数，索引失效。</li><li>对索引列运算（如，+、-、*、/），索引失效。</li><li>索引字段上使用（！= 或者 &lt; >，not in）时，可能会导致索引失效。</li><li>索引字段上使用is null， is not null，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>mysql估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483830&idx=1&sn=6b4aad9fb645130d8cc2999f3c41473c&chksm=97794599a00ecc8f25780959ea2f56b1408003c385b4319eec0b9ceb2dbe63b83998c7b3b658&scene=21#wechat_redirect">后端程序员必备：索引失效的十大杂症</a></p><p><strong>索引不适合哪些场景</strong></p><ul><li>数据量少的不适合加索引</li><li>更新比较频繁的也不适合加索引</li><li>区分度低的字段不适合加索引（如性别）</li></ul><p><strong>索引的一些潜规则</strong></p><ul><li>覆盖索引</li><li>回表</li><li>索引数据结构（B+树）</li><li>最左前缀原则</li><li>索引下推</li></ul><p><strong>MySQL遇到过死锁问题吗，你是如何解决的？</strong></p><p>我排查死锁的一般步骤是酱紫的：</p><ul><li>查看死锁日志show engine innodb status;</li><li>找出死锁Sql</li><li>分析sql加锁情况</li><li>模拟死锁案发</li><li>分析死锁日志</li><li>分析死锁结果</li></ul><p>可以看我这两篇文章哈：</p><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483983&idx=1&sn=88bad91b6058c5fc40d346c0d71428c5&chksm=97794660a00ecf762978d9ebbc390d61de619ba22701f33720e3b95e5edf137e56a18ce5be46&scene=21#wechat_redirect">手把手教你分析Mysql死锁问题</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483716&idx=1&sn=5bc2f65b14e7912cfbbba23016cb033d&chksm=9779456ba00ecc7dd840aea135008c46f88ec6da2586c09f77b85a5c4e20287f9ee8cfb31295&scene=21#wechat_redirect">Mysql死锁如何排查：insert on duplicate死锁一次排查分析过程</a></li></ul><p><strong>日常工作中你是怎么优化SQL的？</strong></p><p>可以从这几个维度回答这个问题：</p><ul><li>加索引</li><li>避免返回不必要的数据</li><li>适当分批量进行</li><li>优化sql结构</li><li>分库分表</li><li>读写分离</li></ul><p>可以看我这篇文章哈：<a href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247483925&idx=1&sn=1f7be5fdeb7230a9202b52bebdedbdb8&chksm=9779463aa00ecf2c0a711a8dc13036e8f7e7ee75e5caccb712ce93920203492def91de5ebc6c&scene=21#wechat_redirect">后端程序员必备：书写高质量SQL的30条建议</a></p><p><strong>数据库索引的原理，为什么要用B+树，为什么不用二叉树？</strong></p><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？</p><p><strong>为什么不是一般二叉树？</strong></p><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><p><strong>为什么不是平衡二叉树呢？</strong></p><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><p><strong>那为什么不是B树而是B+树呢？</strong></p><p>1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</p><p>2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p><p>可以看这篇文章哈：<a href="http://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247484085&idx=1&sn=92639430ac7ef3e412b550a09bde0115&chksm=9779469aa00ecf8c157e899fe0d5c5b060b282a4e5f2f2f63c187eb3c04d04ef6fad7a1e09e3&scene=21#wechat_redirect">再有人问你为什么MySQL用B+树做索引，就把这篇文章发给她</a></p><p><strong>details link :</strong> <a href=https://mp.weixin.qq.com/s/Ctz6yB2131ZIzCOFrsgfMw>https://mp.weixin.qq.com/s/Ctz6yB2131ZIzCOFrsgfMw</a></p><h2 id=事务相关>事务相关<a hidden class=anchor aria-hidden=true href=#事务相关>#</a></h2><p><strong>1. 什么是事务?</strong></p><p>理解什么是事务最经典的就是转账的栗子,相信大家也都了解,这里就不再说一边了.</p><p>事务是一系列的操作,他们要符合ACID特性.最常见的理解就是:事务中的操作要么全部成功,要么全部失败.但是只是这样还不够的.</p><p><strong>2. ACID是什么?可以详细说一下吗?</strong></p><p>A=Atomicity</p><p>原子性,就是上面说的,要么全部成功,要么全部失败.不可能只执行一部分操作.</p><p>C=Consistency</p><p>系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.</p><p>I=Isolation</p><p>隔离性: 通常来说:一个事务在完全提交之前,对其他事务是不可见的.注意前面的通常来说加了红色,意味着有例外情况.</p><p>D=Durability</p><p>持久性,一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.</p><p><strong>3. 同时有多个事务在进行会怎么样呢?</strong></p><p>多事务的并发进行一般会造成以下几个问题:</p><ul><li><p>脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.</p></li><li><p>不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.</p></li><li><p>幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".</p></li></ul><p><strong>4. 怎么解决这些问题呢?MySQL的事务隔离级别了解吗?</strong></p><p>MySQL的四种隔离级别如下:</p><ul><li>未提交读(READ UNCOMMITTED)</li></ul><p>这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).</p><p>这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.</p><ul><li>已提交读(READ COMMITTED)</li></ul><p>其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.</p><ul><li>REPEATABLE READ(可重复读)</li></ul><p>可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是幻读</p><p>当你读取id> 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥</p><p>那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.</p><ul><li>SERIALIZABLE(可串行化)</li></ul><p>这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.</p><p><strong>5. Innodb使用的是哪种隔离级别呢?</strong></p><p>InnoDB默认使用的是可重复读隔离级别.</p><p><strong>6. 对MySQL的锁了解吗?</strong></p><p>当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.</p><p>就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.</p><p><strong>7. MySQL都有哪些锁呢?像上面那样子进行锁定岂不是有点阻碍并发效率了?</strong></p><p>从锁的类别上来讲,有共享锁和排他锁.</p><p>共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.</p><p>排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.</p><p>用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.</p><p>锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.</p><p>他们的加锁开销从大大小,并发能力也是从大到小.</p><h2 id=表结构设计>表结构设计<a hidden class=anchor aria-hidden=true href=#表结构设计>#</a></h2><p><strong>说说分库与分表的设计</strong></p><p>分库分表方案，分库分表中间件，分库分表可能遇到的问题</p><p><strong>分库分表方案:</strong></p><ul><li>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</li><li>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</li><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li></ul><p><strong>常用的分库分表中间件：</strong></p><ul><li>sharding-jdbc（当当）</li><li>Mycat</li><li>TDDL（淘宝）</li><li>Oceanus(58同城数据库中间件)</li><li>vitess（谷歌开发的数据库中间件）</li><li>Atlas(Qihoo 360)</li></ul><p><strong>InnoDB与MyISAM的区别</strong></p><ul><li>InnoDB支持事务，MyISAM不支持事务</li><li>InnoDB支持外键，MyISAM不支持外键</li><li>InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持</li><li>select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</li><li>Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）</li><li>InnoDB支持表、行级锁，而MyISAM支持表级锁。</li><li>InnoDB表必须有主键，而MyISAM可以没有主键</li><li>Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</li><li>Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。</li><li>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li><li></li></ul><p><strong>1. 为什么要尽量设定一个主键?</strong></p><p>主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.</p><p>设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.</p><p><strong>2. 主键使用自增ID还是UUID?</strong></p><p>推荐使用自增ID,不要使用UUID.</p><p>因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的</p><p>也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)</p><p>如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.</p><p>总之,在数据量大一些的情况下,用自增主键性能会好一些.</p><p><em>图片来源于《高性能MySQL》: 其中默认后缀为使用自增ID,_uuid为使用UUID为主键的测试,测试了插入100w行和300w行的性能.</em></p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TyUPmicNlEo7VicUWXlQRm0P8cjjJrHDWKd0Pla0vFZkpHXFbQq4H9vqg3aub3K9B1U6Sczpuibibo2cA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><p>关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.</p><blockquote><p>If you define a PRIMARY KEY on your table, InnoDB uses it as the clustered index.</p><p>If you do not define a PRIMARY KEY for your table, MySQL picks the first UNIQUE index that has only NOT NULL columns as the primary key and InnoDB uses it as the clustered index.</p></blockquote><p><strong>3. 字段为什么要求定义为not null?</strong></p><p>MySQL官网这样介绍:</p><blockquote><p>NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.</p></blockquote><p>null值会占用更多的字节,且会在程序中造成很多与预期不符的情况.</p><p><strong>4. 如果要存储用户的密码散列,应该使用什么字段进行存储?</strong></p><p>密码散列,盐,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储,这样可以节省空间且提高检索效率.</p><h2 id=存储引擎相关>存储引擎相关<a hidden class=anchor aria-hidden=true href=#存储引擎相关>#</a></h2><p><strong>1. MySQL支持哪些存储引擎?</strong></p><p>MySQL支持多种存储引擎,比如InnoDB,MyISAM,Memory,Archive等等.</p><p>在大多数的情况下,直接选择使用InnoDB引擎都是最合适的,InnoDB也是MySQL的默认存储引擎.</p><ol><li>InnoDB和MyISAM有什么区别?</li></ol><ul><li><p>InnoDB支持事物，而MyISAM不支持事物</p></li><li><p>InnoDB支持行级锁，而MyISAM支持表级锁</p></li><li><p>InnoDB支持MVCC, 而MyISAM不支持</p></li><li><p>InnoDB支持外键，而MyISAM不支持</p></li><li><p>InnoDB不支持全文索引，而MyISAM支持。</p></li></ul><h2 id=零散问题>零散问题<a hidden class=anchor aria-hidden=true href=#零散问题>#</a></h2><p><strong>1. MySQL中的varchar和char有什么区别.</strong></p><p>char是一个定长字段,假如申请了<code>char(10)</code>的空间,那么无论实际存储多少内容.该字段都占用10个字符,而varchar是变长的</p><p>也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.</p><p>在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则应该尽量使用varchar.例如存储用户MD5加密后的密码,则应该使用char.</p><p><strong>2. varchar(10)和int(10)代表什么含义?</strong></p><p>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.</p><p>也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</p><p><strong>3. MySQL的binlog有有几种录入格式?分别有什么区别?</strong></p><p>有三种格式,statement,row和mixed.</p><ul><li><p>statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.</p></li><li><p>row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.</p></li><li><p>mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</p></li></ul><p>此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.</p><p><strong>4. 超大分页怎么处理?</strong></p><p>超大的分页一般从两个方向上来解决.</p><ul><li><p>数据库层面,这也是我们主要集中关注的(虽然收效没那么大)</p><p>类似于<code>select * from table where age > 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的.</p><p>这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢.</p><p>我们可以修改为<code>select * from table where id in (select id from table where age > 20 limit 1000000,10)</code></p><p>这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快.</p><p>同时如果ID连续的好,我们还可以<code>select * from table where id > 1000000 limit 10</code>,效率也是不错的</p><p>优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</p></li><li><p>从需求的角度减少这种请求….主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</p></li></ul><p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p><p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TyUPmicNlEo7VicUWXlQRm0P8m6ANBdcclP3HaTibN8HXP0T3wAeFziaVmsaExhUic2vnInmwAA2Ev26Jw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><p><strong>5. 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?</strong></p><p>在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.</p><p>慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?</p><p>所以优化也是针对这三个方向来的,</p><ul><li><p>首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.</p></li><li><p>分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.</p></li><li><p>如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.</p></li></ul><p><strong>6. 上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗?</strong></p><p>横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.</p><p>我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的.</p><p>假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.</p><p>纵向分表是按列分表.假设我们现在有一张文章表.包含字段<code>id-摘要-内容</code>.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要</p><p>当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.</p><p>我们可以将上面的表分为两张.<code>id-摘要</code>,<code>id-内容</code>.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.</p><p>当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.</p><p>**7. 什么是存储过程？**<strong>有哪些优缺点？</strong></p><p>存储过程是一些预编译的SQL语句。</p><p>1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块</p><p>这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p><p>2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全</p><p>但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程</p><p>我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁</p><p>在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.</p><p><strong>8. 说一说三个范式</strong></p><p>第一范式: 每个列都不可以再拆分.</p><p>第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分.</p><p>第三范式: 非主键列只依赖于主键,不依赖于其他非主键.</p><p>在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.</p><p><strong>9. MyBatis 中的 #</strong></p><p>乱入了一个奇怪的问题…..我只是想单独记录一下这个问题,因为出现频率太高了.</p><p># 会将传入的内容当做字符串,而$会直接将传入值拼接在sql语句中.</p><p>所以#可以在一定程度上预防sql注入攻击。</p><ol start=10><li><h5 id=为什么不要用-select->为什么不要用 SELECT *<a hidden class=anchor aria-hidden=true href=#为什么不要用-select->#</a></h5></li></ol><blockquote><ol><li>不需要的列会增加数据传输时间和网络开销
用“SELECT * ”数据库需要解析更多的对象、字段、权限、属性等相关内容，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。</li></ol><p>增大网络开销；* 有时会误带上如log、IconMD5之类的无用且大文本字段，数据传输size会几何增涨。如果DB和应用程序不在同一台机器，这种开销非常明显</p><p>即使 mysql 服务器和客户端是在同一台机器上，使用的协议还是 tcp，通信也是需要额外的时间。</p><ol start=2><li><p>对于无用的大字段，如 varchar、blob、text，会增加 io 操作
准确来说，长度超过 728 字节的时候，会先把超出的数据序列化到另外一个地方，因此读取这条记录会增加一次 io 操作。（MySQL InnoDB）</p></li><li><p>失去MySQL优化器“覆盖索引”策略优化的可能性
SELECT * 杜绝了覆盖索引的可能性，而基于MySQL优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式。</p></li></ol></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/mysql/>MySql</a></li><li><a href=https://reid00.github.io/en/tags/%E9%9D%A2%E8%AF%95/>面试</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/storage/rocksdb/><span class=title>« Prev</span><br><span>RocksDB</span>
</a><a class=next href=https://reid00.github.io/en/posts/langs_linux/python-import%E5%AF%BC%E5%85%A5%E4%B8%8A%E7%BA%A7%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/><span class=title>Next »</span><br><span>Python Import导入上级目录文件</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>