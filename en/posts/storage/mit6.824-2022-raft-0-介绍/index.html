<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MIT6.824 2022 Raft 0 介绍 | Reid's Blog</title>
<meta name=keywords content="Raft,MIT6.824,Consensus,共识算法"><meta name=description content="MIT6.824 2022 Raft 0 介绍"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-0-%E4%BB%8B%E7%BB%8D/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-0-%E4%BB%8B%E7%BB%8D/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="MIT6.824 2022 Raft 0 介绍"><meta property="og:description" content="MIT6.824 2022 Raft 0 介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-0-%E4%BB%8B%E7%BB%8D/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:34:55+08:00"><meta property="article:modified_time" content="2023-03-16T19:34:55+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="MIT6.824 2022 Raft 0 介绍"><meta name=twitter:description content="MIT6.824 2022 Raft 0 介绍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"存储, 分布式相关的文章","item":"https://reid00.github.io/en/posts/storage/"},{"@type":"ListItem","position":3,"name":"MIT6.824 2022 Raft 0 介绍","item":"https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-0-%E4%BB%8B%E7%BB%8D/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MIT6.824 2022 Raft 0 介绍","name":"MIT6.824 2022 Raft 0 介绍","description":"MIT6.824 2022 Raft 0 介绍","keywords":["Raft","MIT6.824","Consensus","共识算法"],"articleBody":"前言 论文 博士论文 博士论文翻译 官网 动画展示 Students’ Guide to Raft （重要） MIT6.824 本篇是实验的前言, 先对论文里面提到的RPC做个大概的梳理和介绍。 Raft 原理可以参考这篇Raft\nFigure2 Raft 实现的核心在这个图，想要正确实现Raft 必须对这个图有深刻理解，在这里我们对图上的各个RPC 进行介绍和阐述。\nState Persistent state for all servers 所有Raft 节点都需要维护的持久化状态: currentTerm: 此节点当前的任期。保证重启后任期不丢失。启动时初始值为0(无意义状态)，单调递增 (Lab 2A) votedFor: 当前任期内,此节点将选票给了谁。 一个任期内,节点只能将选票投给某个节点。需要持久化，从而避免节点重启后重复投票。(Lab 2A) logs: 日志条目, 每条 Entry 包含一条待施加至状态机的命令。Entry 也要记录其被发送至 Leader 时，Leader 当时的任期。Lab2B 中，在内存存储日志即可，不用担心 server 会 down 掉，测试中仅会模拟网络挂掉的情景。初始Index从1开始，0为dummy index。 为什么 currentTerm 和 votedFor 需要持久化?\nvotedFor 保证每个任期最多只有一个Leader！\n考虑如下一种场景： 因为在Raft协议中每个任期内有且仅有一个Leader。现假设有几个Raft节点在当前任期下投票给了Raft节点A，并且Raft A顺利成为了Leader。现故障系统被重启，重启后如果收到一个相同任期的Raft节点B的投票请求，由于每个节点并没有记录其投票状态，那么这些节点就有可能投票给Raft B，并使B成为Leader。此时，在同一个任期内就会存在两个Leader，与Raft的要求不符。\n保证每个Index位置只会有一个Term! (也等价于每个任期内最多有一个Leader)\n在这里例子中，S1关机了，S2和S3会尝试选举一个新的Leader。它们需要证据证明，正确的任期号是8，而不是6。如果仅仅是S2和S3为彼此投票，它们不知道当前的任期号，它们只能查看自己的Log，它们或许会认为下一个任期是6（因为Log里的上一个任期是5）。如果它们这么做了，那么它们会从任期6开始添加Log。但是接下来，就会有问题了，因为我们有了两个不同的任期6（另一个在S1中）。这就是为什么currentTerm需要被持久化存储的原因，因为它需要用来保存已经被使用过的任期号。\n这些数据需要在每次你修改它们的时候存储起来。所以可以确定的是，安全的做法是每次你添加一个Log条目，更新currentTerm或者更新votedFor，你或许都需要持久化存储这些数据。在一个真实的Raft服务器上，这意味着将数据写入磁盘，所以你需要一些文件来记录这些数据。如果你发现，直到服务器与外界通信时，才有可能持久化存储数据，那么你可以通过一些批量操作来提升性能。例如，只在服务器回复一个RPC或者发送一个RPC时，服务器才进行持久化存储，这样可以节省一些持久化存储的操作。\nVolatile state on all servers 每一个节点都应该有的非持久化状态： commitIndex: 已提交的最大 index。被提交的定义为，当 Leader 成功在大部分 server 上复制了一条 Entry，那么这条 Entry 就是一条已提交的 Entry。leader 节点重启后可以通过 appendEntries rpc 逐渐得到不同节点的 matchIndex，从而确认 commitIndex，follower 只需等待 leader 传递过来的 commitIndex 即可。（初始值为0，单调递增） lastApplied: 已被状态机应用的最大 index。已提交和已应用是不同的概念，已应用指这条 Entry 已经被运用到状态机上。已提交先于已应用。同时需要注意的是，Raft 保证了已提交的 Entry 一定会被应用（通过对选举过程增加一些限制，下面会提到）。raft 算法假设了状态机本身是易失的，所以重启后状态机的状态可以通过 log[] （部分 log 可以压缩为 snapshot) 来恢复。（初始值为0，单调递增） commitIndex 和 lastApplied 分别维护 log 已提交和已应用的状态，当节点发现 commitIndex \u003e lastApplied 时，代表着 commitIndex 和 lastApplied 间的 entries 处于已提交，未应用的状态。因此应将其间的 entries 按序应用至状态机。\n对于 Follower，commitIndex 通过 Leader AppendEntries RPC 的参数 leaderCommit 更新。对于 Leader，commitIndex 通过其维护的 matchIndex 数组更新。\nVolatile state on leaders leader 的非持久化状态： nextIndex[]: 由 Leader 维护，nextIndex[i] 代表需要同步给 peer[i] 的下一个 entry 的 index。在 Leader 当选后，重新初始化为 Leader 的 lastLogIndex + 1。 matchIndex[]: 由 Leader 维护，matchIndex[i] 代表 Leader 已知的已在 peer[i] 上成功复制的最高 entry index。在 Leader 当选后，重新初始化为 0。 每次选举后，leader 的此两个数组都应该立刻重新初始化并开始探测。\n不能简单地认为 matchIndex = nextIndex - 1。\nnextIndex 是对追加位置的一种猜测，是乐观的估计。因此，当 Leader 上任时，会将 nextIndex 全部初始化为 lastLogIndex + 1，即乐观地估计所有 Follower 的 log 已经与自身相同。AppendEntries PRC 中，Leader 会根据 nextIndex 来决定向 Follower 发送哪些 entry。当返回失败时，则会将 nextIndex 减一，猜测仅有一条 entry 不一致，再次乐观地尝试。实际上，使用 nextIndex 是为了提升性能，仅向 Follower 发送不一致的 entry，减小 RPC 传输量。\nmatchIndex 则是对同步情况的保守确认，为了保证安全性。matchIndex 及此前的 entry 一定都成功地同步。matchIndex 的作用是帮助 Leader 更新自身的 commitIndex。当 Leader 发现一个 Index N 值，N 大于过半数的 matchIndex，则可将其 commitIndex 更新为 N（需要注意任期号的问题，后文会提到）。matchIndex 在 Leader 上任时被初始化为 0。\nnextIndex 是最乐观的估计，被初始化为最大可能值；matchIndex 是最悲观的估计，被初始化为最小可能值。在一次次心跳中，nextIndex 不断减小，matchIndex 不断增大，直至 matchIndex = nextIndex - 1，则代表该 Follower 已经与 Leader 成功同步。\nRequestVote RPC Invoked by candidates to gather votes (§5.2). 会被 Candidate 调用，以此获取选票。\nArgs\nterm: Candidate 的任期 (Lab 2A) candidateId: 发起投票请求的候选人id (Lab 2A) lastLogIndex: 候选人最新的日志条目索引， Candidate 最后一个 entry 的 index，是投票的额外判据 lastLogTerm: 候选人最新日志条目对应的任期号 Reply\nterm: 收到RequestVote RPC Raft节点的任期。假如 Candidate 发现 Follower 的任期高于自己，则会放弃 Candidate 身份并更新自己的任期 voteGranted: 是否同意 Candidate 当选。 Receiver Implementation 接收日志的follower需要实现的\n当 Candidate 任期小于当前节点任期时，返回 false。 如果 votedFor 为 null（即当前任期内此节点还未投票, Go 代码中用-1）或者 votedFor为 candidateId（即当前任期内此节点已经向此 Candidate 投过票），则同意投票；否则拒绝投票（Lab 2A 只需要实现到这个程度）。 事实上还要: 只有 Candidate 的 log 至少与 Receiver 的 log 一样新（up-to-date）时，才同意投票。Raft 通过两个日志的最后一个 entry 来判断哪个日志更 up-to-date。假如两个 entry 的 term 不同，term 更大的更新。term 相同时，index 更大的更新。 这里投票的额外限制(up-to-date)是为了保证已经被 commit 的 entry 一定不会被覆盖。仅有当 Candidate 的 log 包含所有已提交的 entry，才有可能当选为 Leader。\nAppendEntries RPC Invoked by leader to replicate log entries (§5.3); also used as heartbeat (§5.2). 在领导选举的过程中，AppendEntries RPC 用来实现 Leader 的心跳机制。节点的 AppendEntries RPC 会被 Leader 定期调用。正常存在Leader 时，用来进行Log Replacation。\nArgs\nterm: Leader 任期 (Lab 2A) leadId: Client 可能将请求发送至 Follower 节点，得知 leaderId 后 Follower 可将 Client 的请求重定位至 Leader 节点。因为 Raft 的请求信息必须先经过 Leader 节点，再由 Leader 节点流向其他节点进行同步，信息是单向流动的。在选主过程中，leaderId暂时只有 debug 的作用 (Lab 2A) prevLogIndex: 添加 Entries 的前一条 Entry 的 index prevLogTerm: prevLogIndex 对应 entry 的 term entries[]: 需要同步的 entries。若为空，则代表是一次 heartbeat。需要注意的是，不需要特别判断是否为 heartbeat，即使是 heartbeat，也需要进行一系列的检查。因此本文也不再区分心跳和 AppendEntries RPC leaderCommit: Leader 的 commitIndex，帮助 Follower 更新自身的 commitIndex Reply\nterm: 此节点的任期。假如 Leader 发现 Follower 的任期高于自己，则会放弃 Leader 身份并更新自己的任期。 success: 此节点是否认同 Leader 发送的RPC。 Receiver Implementation 接收日志的follower需要实现的\n当 Leader 任期小于当前节点任期时，返回 false。 若 Follower 在 prevLogIndex 位置的 entry 的 term 与 Args 中的 prevLogTerm 不同（或者 prevLogIndex 的位置没有 entry），返回 false。 如果 Follower 的某一个 entry 与需要同步的 entries 中的一个 entry 冲突，则需要删除冲突 entry 及其之后的所有 entry。需要特别注意的是，假如没有冲突，不能删除任何 entry。因为存在 Follower 的 log 更 up-to-date 的可能。 添加 Log 中不存在的新 entry。 如果 leaderCommit \u003e commitIndex，令 commitIndex = min(leaderCommit, index of last new entry)。此即 Follower 更新 commitIndex 的方式。 Rules for Servers All Servers 如果commitIndex \u003e lastApplied, 那么将lastApplied自增, 并把对应日志log[lastApplied]应用到状态机 如果来自其他节点的 RPC 请求(RequestVote, AppendEntries, InstallSnapshot)中，或发给其他节点的 RPC 的回复中，包含一个term T大于currentTerm, 那么将currentTerm赋值为T并立即切换状态为 Follower。(Lab 2A) Followers 响应来自 Candidate 和 Leader 的 RPC 请求。(Lab 2A) 如果在 election timeout 到期时，Follower 未收到来自当前 Leader 的 AppendEntries RPC，也没有收到来自 Candidate 的 RequestVote RPC，则转变为 Candidate。(Lab 2A) Candidate 转变 Candidate时，开始一轮选举：(Lab 2A) currentTerm ++ 为自己投票, votedFor = me 重置 election timer 向其他所有节点并行发送 RequestVote RPC 如果收到了大多数节点的选票（voteCnt \u003e n/2），当选 Leader。(Lab 2A) 在选举过程中，如果收到了来自新 Leader 的 AppendEntries RPC，停止选举，转变为 Follower。(Lab 2A) 如果 election timer 超时时，还未当选 Leader，则放弃此轮选举，开启新一轮选举。(Lab 2A) Leader 刚上任时，向所有节点发送一轮心跳信息(empty AppendEntries)。此后，每隔一段固定时间，向所有节点发送一轮心跳信息，重置其他节点的 election timer，以维持自己 Leader 的身份。(Lab 2A) 如果收到了来自 client 的 command，将 command 以 entry 的形式添加到日志。在收到大多数响应后将该条目应用到状态机并回复响应给客户端。在 lab2B 中，client 通过 Start() 函数传入 command。 如果 lastLogIndex \u003e= nextIndex[i]，向 peer[i] 发送 AppendEntries RPC，RPC 中包含从 nextIndex[i] 开始的日志。 如果返回值为 true，更新 nextIndex[i] 和 matchIndex[i]。 如果因为 entry 冲突，RPC 返回值为 false，则将 nextIndex[i] 减1并重试。这里的重试不一定代表需要立即重试，实际上可以仅将 nextIndex[i] 减1，下次心跳时则是以新值重试。 如果存在 index 值 N 满足：N \u003e commitIndex \u0026\u0026 过半数 matchIndex[i] \u003e= N \u0026\u0026 log[N].term == currentTerm, 则令commitIndex = N。 这里最后一条是 Leader 更新 commitIndex 的方式。前两个要求都比较好理解，第三个要求是 Raft 的一个特性，即 Leader 仅会直接提交其任期内的 entry。存在这样一种情况，Leader 上任时，其最新的一些条目可能被认为处于未被提交的状态（但这些条目实际已经成功同步到了大部分节点上）。Leader 在上任时并不会检查这些 entry 是不是实际上已经可以被提交，而是通过提交此后的 entry 来间接地提交这些 entry。这种做法能够 work 的基础是 Log Matching Property：\nLog Matching: if two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index.\nInstallSnapshot PRC invoked by leader to send chunks of a snapshot to a follower.Leaders always send chunks in order. 虽然多数情况都是每个服务器独立创建快照, 但是leader有时候必须发送快照给一些落后太多的follower, 这通常发生在leader已经丢弃了下一条要发给该follower的日志条目(Log Compaction时清除掉了)的情况下。\nArgs\nterm: Leader 任期。同样，InstallSnapshot RPC 也要遵循 Figure 2 中的规则。如果节点发现自己的任期小于 Leader 的任期，就要及时更新 leaderId: 用于重定向 client lastIncludedIndex: 快照中包含的最后一个 entry 的 index lastIncludedTerm: 快照中包含的最后一个 entry 的 index 对应的 term offset: 分块在快照中的偏移量 data[]: 快照数据 done: 如果是最后一块数据则为真 Reply\nterm: 节点的任期。Leader 发现高于自己任期的节点时，更新任期并转变为 Follower Receiver Implementation 接收日志的follower需要实现的\n如果 term \u003c currentTerm，直接返回 如果是第一个分块 (offset为0) 则创建新的快照 在指定的偏移量写入数据 如果done为false, 则回复并继续等待之后的数据 保存快照文件, 丢弃所有已存在的或者部分有着更小索引号的快照 如果现存的日志拥有相同的最后任期号和索引值, 则后面的数据继续保留并且回复 丢弃全部日志 能够使用快照来恢复状态机 (并且装载快照中的集群配置) 一次请求 Raft 需要做如下流程： Leader (Follower 收到会定向给Leader)收到 client 的请求； Leader 把 entry 写入持久存储； Leader 发送 log replication message(AppendEntries RPC) 给 Follower； Follower 接收之后，把 entry 写入持久存储，然后给 Leader 发送响应； Leader 等待 Follower 的响应，若 majority 节点接收了，则 apply； Leader 将结果返回给 client。 ","wordCount":"5011","inLanguage":"en","datePublished":"2023-03-16T19:34:55+08:00","dateModified":"2023-03-16T19:34:55+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-0-%E4%BB%8B%E7%BB%8D/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/storage/>存储, 分布式相关的文章</a></div><h1 class=post-title>MIT6.824 2022 Raft 0 介绍</h1><div class=post-description>MIT6.824 2022 Raft 0 介绍</div><div class=post-meta>&lt;span title='2023-03-16 19:34:55 +0800 +0800'>2023-03-16 19:34&lt;/span>&amp;nbsp;·&amp;nbsp;11 min&amp;nbsp;·&amp;nbsp;5011 words&amp;nbsp;·&amp;nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#figure2 aria-label=Figure2>Figure2</a><ul><li><a href=#state aria-label=State>State</a><ul><li><a href=#persistent-state-for-all-servers-%e6%89%80%e6%9c%89raft-%e8%8a%82%e7%82%b9%e9%83%bd%e9%9c%80%e8%a6%81%e7%bb%b4%e6%8a%a4%e7%9a%84%e6%8c%81%e4%b9%85%e5%8c%96%e7%8a%b6%e6%80%81 aria-label="Persistent state for all servers 所有Raft 节点都需要维护的持久化状态:">Persistent state for all servers 所有Raft 节点都需要维护的持久化状态:</a></li><li><a href=#volatile-state-on-all-servers-%e6%af%8f%e4%b8%80%e4%b8%aa%e8%8a%82%e7%82%b9%e9%83%bd%e5%ba%94%e8%af%a5%e6%9c%89%e7%9a%84%e9%9d%9e%e6%8c%81%e4%b9%85%e5%8c%96%e7%8a%b6%e6%80%81 aria-label="Volatile state on all servers 每一个节点都应该有的非持久化状态：">Volatile state on all servers 每一个节点都应该有的非持久化状态：</a></li><li><a href=#volatile-state-on-leaders-leader-%e7%9a%84%e9%9d%9e%e6%8c%81%e4%b9%85%e5%8c%96%e7%8a%b6%e6%80%81 aria-label="Volatile state on leaders leader 的非持久化状态：">Volatile state on leaders leader 的非持久化状态：</a></li></ul></li><li><a href=#requestvote-rpc aria-label="RequestVote RPC">RequestVote RPC</a></li><li><a href=#appendentries-rpc aria-label="AppendEntries RPC">AppendEntries RPC</a></li><li><a href=#rules-for-servers aria-label="Rules for Servers">Rules for Servers</a><ul><li><a href=#all-servers aria-label="All Servers">All Servers</a></li><li><a href=#followers aria-label=Followers>Followers</a></li><li><a href=#candidate aria-label=Candidate>Candidate</a></li><li><a href=#leader aria-label=Leader>Leader</a></li></ul></li><li><a href=#installsnapshot-prc aria-label="InstallSnapshot PRC">InstallSnapshot PRC</a></li></ul></li><li><a href=#%e4%b8%80%e6%ac%a1%e8%af%b7%e6%b1%82-raft-%e9%9c%80%e8%a6%81%e5%81%9a%e5%a6%82%e4%b8%8b%e6%b5%81%e7%a8%8b aria-label="一次请求 Raft 需要做如下流程：">一次请求 Raft 需要做如下流程：</a></li></ul></div></details></div><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><ul><li><a href=https://raft.github.io/raft.pdf>论文</a></li><li><a href=https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf>博士论文</a></li><li><a href=https://www.cnblogs.com/pxlsdz/p/15640462.html>博士论文翻译</a></li><li><a href=https://raft.github.io/>官网</a></li><li><a href=http://thesecretlivesofdata.com/raft/#overview>动画展示</a></li><li><a href=https://thesquareplanet.com/blog/students-guide-to-raft/>Students&rsquo; Guide to Raft</a> （重要）</li><li><a href=https://pdos.csail.mit.edu/6.824/index.html>MIT6.824</a></li></ul><p>本篇是实验的前言, 先对论文里面提到的RPC做个大概的梳理和介绍。
Raft 原理可以参考这篇<a href=https://reid00.github.io/en/posts/storage/raft-%E4%BB%8B%E7%BB%8D/>Raft</a></p><h1 id=figure2>Figure2<a hidden class=anchor aria-hidden=true href=#figure2>#</a></h1><p>Raft 实现的核心在这个图，想要正确实现Raft 必须对这个图有深刻理解，在这里我们对图上的各个RPC 进行介绍和阐述。</p><h2 id=state>State<a hidden class=anchor aria-hidden=true href=#state>#</a></h2><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230209/image.46dgvt54kms0.webp alt=State></p><h3 id=persistent-state-for-all-servers-所有raft-节点都需要维护的持久化状态>Persistent state for all servers 所有Raft 节点都需要维护的持久化状态:<a hidden class=anchor aria-hidden=true href=#persistent-state-for-all-servers-所有raft-节点都需要维护的持久化状态>#</a></h3><ul><li><code>currentTerm</code>: 此节点当前的任期。保证重启后任期不丢失。启动时初始值为0(无意义状态)，单调递增 (Lab 2A)</li><li><code>votedFor</code>: 当前任期内,此节点将选票给了谁。 <code>一个任期内,节点只能将选票投给某个节点</code>。需要持久化，从而避免节点重启后重复投票。(Lab 2A)</li><li><code>logs</code>: 日志条目, 每条 Entry 包含一条待施加至状态机的命令。Entry 也要记录其被发送至 Leader 时，Leader 当时的任期。Lab2B 中，在内存存储日志即可，不用担心 server 会 down 掉，测试中仅会模拟网络挂掉的情景。初始Index从1开始，0为dummy index。</li></ul><p>为什么 <code>currentTerm</code> 和 <code>votedFor</code> 需要持久化?</p><p><strong>votedFor 保证每个任期最多只有一个Leader！</strong></p><p>考虑如下一种场景：
因为在<code>Raft</code>协议中每个任期内有且仅有一个Leader。现假设有几个<code>Raft</code>节点在当前任期下投票给了<code>Raft</code>节点A，并且<code>Raft</code> A顺利成为了Leader。现故障系统被重启，重启后如果收到一个相同任期的<code>Raft</code>节点B的投票请求，由于每个节点并没有记录其投票状态，那么这些节点就有可能投票给<code>Raft</code> B，并使B成为Leader。此时，在同一个任期内就会存在两个Leader，与<code>Raft</code>的要求不符。</p><p><strong>保证每个Index位置只会有一个Term! (也等价于每个任期内最多有一个Leader)</strong></p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230113/image.25rcj5suacxs.webp alt=currentTerm></p><p>在这里例子中，S1关机了，S2和S3会尝试选举一个新的Leader。它们需要证据证明，正确的任期号是8，而不是6。如果仅仅是S2和S3为彼此投票，它们不知道当前的任期号，它们只能查看自己的Log，它们或许会认为下一个任期是6（因为Log里的上一个任期是5）。如果它们这么做了，那么它们会从任期6开始添加Log。但是接下来，就会有问题了，因为我们有了两个不同的任期6（另一个在S1中）。这就是为什么currentTerm需要被持久化存储的原因，因为它需要用来保存已经被使用过的任期号。</p><p>这些数据需要在每次你修改它们的时候存储起来。所以可以确定的是，安全的做法是每次你添加一个Log条目，更新currentTerm或者更新votedFor，你或许都需要持久化存储这些数据。在一个真实的Raft服务器上，这意味着将数据写入磁盘，所以你需要一些文件来记录这些数据。如果你发现，直到服务器与外界通信时，才有可能持久化存储数据，那么你可以通过一些批量操作来提升性能。例如，只在服务器回复一个RPC或者发送一个RPC时，服务器才进行持久化存储，这样可以节省一些持久化存储的操作。</p><h3 id=volatile-state-on-all-servers-每一个节点都应该有的非持久化状态>Volatile state on all servers 每一个节点都应该有的非持久化状态：<a hidden class=anchor aria-hidden=true href=#volatile-state-on-all-servers-每一个节点都应该有的非持久化状态>#</a></h3><ul><li><code>commitIndex</code>: 已提交的最大 index。被提交的定义为，当 Leader 成功在大部分 server 上复制了一条 Entry，那么这条 Entry 就是一条已提交的 Entry。leader 节点重启后可以通过 appendEntries rpc 逐渐得到不同节点的 matchIndex，从而确认 commitIndex，follower 只需等待 leader 传递过来的 commitIndex 即可。（初始值为0，单调递增）</li><li><code>lastApplied</code>: 已被状态机应用的最大 index。已提交和已应用是不同的概念，已应用指这条 Entry 已经被运用到状态机上。已提交先于已应用。同时需要注意的是，Raft 保证了已提交的 Entry 一定会被应用（通过对选举过程增加一些限制，下面会提到）。raft 算法假设了状态机本身是易失的，所以重启后状态机的状态可以通过 log[] （部分 log 可以压缩为 snapshot) 来恢复。（初始值为0，单调递增）</li></ul><p><code>commitIndex</code> 和 <code>lastApplied</code> 分别维护 log 已提交和已应用的状态，当节点发现 commitIndex > lastApplied 时，代表着 <code>commitIndex</code> 和 <code>lastApplied</code> 间的 entries 处于已提交，未应用的状态。因此应将其间的 entries <code>按序应用至状态机</code>。</p><p>对于 Follower，commitIndex 通过 Leader AppendEntries RPC 的参数 leaderCommit 更新。对于 Leader，commitIndex 通过其维护的 matchIndex 数组更新。</p><h3 id=volatile-state-on-leaders-leader-的非持久化状态>Volatile state on leaders leader 的非持久化状态：<a hidden class=anchor aria-hidden=true href=#volatile-state-on-leaders-leader-的非持久化状态>#</a></h3><ul><li><code>nextIndex[]</code>: 由 Leader 维护，nextIndex[i] 代表需要同步给 peer[i] 的下一个 entry 的 index。在 Leader 当选后，重新初始化为 Leader 的 lastLogIndex + 1。</li><li><code>matchIndex[]</code>: 由 Leader 维护，matchIndex[i] 代表 Leader 已知的已在 peer[i] 上成功复制的最高 entry index。在 Leader 当选后，重新初始化为 0。</li></ul><p>每次选举后，leader 的此两个数组都应该立刻重新初始化并开始探测。</p><p>不能简单地认为 matchIndex = nextIndex - 1。</p><p>nextIndex <code>是对追加位置的一种猜测</code>，是乐观的估计。因此，当 Leader 上任时，会将 nextIndex 全部初始化为 lastLogIndex + 1，即乐观地估计所有 Follower 的 log 已经与自身相同。AppendEntries PRC 中，Leader 会根据 nextIndex 来决定向 Follower 发送哪些 entry。当返回失败时，则会将 nextIndex 减一，猜测仅有一条 entry 不一致，再次乐观地尝试。实际上，使用 nextIndex 是为了提升性能，仅向 Follower 发送不一致的 entry，减小 RPC 传输量。</p><p>matchIndex <code>则是对同步情况的保守确认</code>，为了保证安全性。matchIndex 及此前的 entry 一定都成功地同步。matchIndex 的作用是帮助 Leader 更新自身的 commitIndex。当 Leader 发现一个 Index N 值，N 大于过半数的 matchIndex，则可将其 commitIndex 更新为 N（需要注意任期号的问题，后文会提到）。matchIndex 在 Leader 上任时被初始化为 0。</p><p>nextIndex 是最乐观的估计，被初始化为最大可能值；matchIndex 是最悲观的估计，被初始化为最小可能值。在一次次心跳中，nextIndex 不断减小，matchIndex 不断增大，直至 matchIndex = nextIndex - 1，则代表该 Follower 已经与 Leader 成功同步。</p><h2 id=requestvote-rpc>RequestVote RPC<a hidden class=anchor aria-hidden=true href=#requestvote-rpc>#</a></h2><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230209/image.h1g3mszhogg.webp alt=RV></p><p>Invoked by candidates to gather votes (§5.2).
会被 Candidate 调用，以此获取选票。</p><p>Args</p><ul><li><code>term</code>: Candidate 的任期 (Lab 2A)</li><li><code>candidateId</code>: 发起投票请求的候选人id (Lab 2A)</li><li><code>lastLogIndex</code>: 候选人最新的日志条目索引， Candidate 最后一个 entry 的 index，是投票的额外判据</li><li><code>lastLogTerm</code>: 候选人最新日志条目对应的任期号</li></ul><p>Reply</p><ul><li><code>term</code>: 收到<code>RequestVote RPC</code> Raft节点的任期。假如 Candidate 发现 Follower 的任期高于自己，则会放弃 Candidate 身份并更新自己的任期</li><li><code>voteGranted</code>: 是否同意 Candidate 当选。</li></ul><p>Receiver Implementation 接收日志的follower需要实现的</p><ol><li>当 Candidate 任期小于当前节点任期时，返回 false。</li><li>如果 <code>votedFor</code> 为 null（即当前任期内此节点还未投票, Go 代码中用-1）或者 <code>votedFor</code>为 <code>candidateId</code>（即当前任期内此节点已经向此 Candidate 投过票），则同意投票；否则拒绝投票（Lab 2A 只需要实现到这个程度）。 事实上还要: 只有 Candidate 的 log 至少与 Receiver 的 log 一样新（up-to-date）时，才同意投票。Raft 通过两个日志的最后一个 entry 来判断哪个日志更 up-to-date。假如两个 entry 的 term 不同，term 更大的更新。term 相同时，index 更大的更新。</li></ol><p>这里投票的额外限制(up-to-date)是为了保证已经被 commit 的 entry 一定不会被覆盖。仅有当 Candidate 的 log 包含所有已提交的 entry，才有可能当选为 Leader。</p><h2 id=appendentries-rpc>AppendEntries RPC<a hidden class=anchor aria-hidden=true href=#appendentries-rpc>#</a></h2><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230209/image.4r4ijxz3egw0.webp alt=AE></p><p>Invoked by leader to replicate log entries (§5.3); also used as heartbeat (§5.2).
在领导选举的过程中，AppendEntries RPC 用来实现 Leader 的心跳机制。节点的 AppendEntries RPC 会被 Leader 定期调用。正常存在Leader 时，用来进行Log Replacation。</p><p>Args</p><ul><li><code>term</code>: Leader 任期 (Lab 2A)</li><li><code>leadId</code>: Client 可能将请求发送至 Follower 节点，得知 leaderId 后 Follower 可将 Client 的请求重定位至 Leader 节点。因为 Raft 的请求信息必须先经过 Leader 节点，再由 Leader 节点流向其他节点进行同步，信息是单向流动的。在选主过程中，leaderId暂时只有 debug 的作用 (Lab 2A)</li><li><code>prevLogIndex</code>: 添加 Entries 的前一条 Entry 的 index</li><li><code>prevLogTerm</code>: prevLogIndex 对应 entry 的 term</li><li><code>entries[]</code>: 需要同步的 entries。若为空，则代表是一次 heartbeat。需要注意的是，不需要特别判断是否为 heartbeat，即使是 heartbeat，也需要进行一系列的检查。因此本文也不再区分心跳和 AppendEntries RPC</li><li><code>leaderCommit</code>: Leader 的 commitIndex，帮助 Follower 更新自身的 commitIndex</li></ul><p>Reply</p><ul><li><code>term</code>: 此节点的任期。假如 Leader 发现 Follower 的任期高于自己，则会放弃 Leader 身份并更新自己的任期。</li><li><code>success</code>: 此节点是否认同 Leader 发送的RPC。</li></ul><p>Receiver Implementation 接收日志的follower需要实现的</p><ol><li>当 Leader 任期小于当前节点任期时，返回 false。</li><li>若 Follower 在 prevLogIndex 位置的 entry 的 term 与 Args 中的 prevLogTerm 不同（或者 prevLogIndex 的位置没有 entry），返回 false。</li><li>如果 Follower 的某一个 entry 与需要同步的 entries 中的一个 entry 冲突，则需要删除冲突 entry 及其之后的所有 entry。需要特别注意的是，假如没有冲突，不能删除任何 entry。因为存在 Follower 的 log 更 up-to-date 的可能。</li><li>添加 Log 中不存在的新 entry。</li><li>如果 leaderCommit > commitIndex，令 commitIndex = min(leaderCommit, index of last new entry)。此即 Follower 更新 commitIndex 的方式。</li></ol><h2 id=rules-for-servers>Rules for Servers<a hidden class=anchor aria-hidden=true href=#rules-for-servers>#</a></h2><h3 id=all-servers>All Servers<a hidden class=anchor aria-hidden=true href=#all-servers>#</a></h3><ul><li>如果commitIndex > lastApplied, 那么将lastApplied自增, 并把对应日志log[lastApplied]应用到状态机</li><li>如果来自其他节点的 RPC <code>请求</code>(RequestVote, AppendEntries, InstallSnapshot)中，或发给其他节点的 RPC 的<code>回复</code>中，包含一个term T大于<code>currentTerm</code>, 那么将<code>currentTerm</code>赋值为T并立即切换状态为 Follower。(Lab 2A)</li></ul><h3 id=followers>Followers<a hidden class=anchor aria-hidden=true href=#followers>#</a></h3><ul><li>响应来自 Candidate 和 Leader 的 RPC 请求。(Lab 2A)</li><li>如果在 election timeout 到期时，Follower 未收到来自当前 Leader 的 AppendEntries RPC，也没有收到来自 Candidate 的 RequestVote RPC，则转变为 Candidate。(Lab 2A)</li></ul><h3 id=candidate>Candidate<a hidden class=anchor aria-hidden=true href=#candidate>#</a></h3><ul><li>转变 Candidate时，开始一轮选举：(Lab 2A)<ul><li>currentTerm ++</li><li>为自己投票, votedFor = me</li><li>重置 election timer</li><li>向其他所有节点<code>并行</code>发送 RequestVote RPC</li></ul></li><li>如果收到了大多数节点的选票（voteCnt > n/2），当选 Leader。(Lab 2A)</li><li>在选举过程中，如果收到了来自新 Leader 的 AppendEntries RPC，停止选举，转变为 Follower。(Lab 2A)</li><li>如果 election timer 超时时，还未当选 Leader，则放弃此轮选举，开启新一轮选举。(Lab 2A)</li></ul><h3 id=leader>Leader<a hidden class=anchor aria-hidden=true href=#leader>#</a></h3><ul><li>刚上任时，向所有节点发送一轮心跳信息(empty AppendEntries)。此后，每隔一段固定时间，向所有节点发送一轮心跳信息，重置其他节点的 election timer，以维持自己 Leader 的身份。(Lab 2A)</li><li>如果收到了来自 client 的 command，将 command 以 entry 的形式添加到日志。在收到大多数响应后将该条目应用到状态机并回复响应给客户端。在 lab2B 中，client 通过 Start() 函数传入 command。</li><li>如果 lastLogIndex >= nextIndex[i]，向 peer[i] 发送 AppendEntries RPC，RPC 中包含从 nextIndex[i] 开始的日志。<ul><li>如果返回值为 true，更新 nextIndex[i] 和 matchIndex[i]。</li><li>如果因为 entry 冲突，RPC 返回值为 false，则将 nextIndex[i] 减1并重试。这里的重试不一定代表需要立即重试，实际上可以仅将 nextIndex[i] 减1，下次心跳时则是以新值重试。</li></ul></li><li>如果存在 index 值 N 满足：N > commitIndex && 过半数 matchIndex[i] >= N && log[N].term == currentTerm, 则令commitIndex = N。</li></ul><p>这里最后一条是 Leader 更新 commitIndex 的方式。前两个要求都比较好理解，第三个要求是 Raft 的一个特性，即 Leader 仅会直接提交其任期内的 entry。存在这样一种情况，Leader 上任时，其最新的一些条目可能被认为处于未被提交的状态（但这些条目实际已经成功同步到了大部分节点上）。Leader 在上任时并不会检查这些 entry 是不是实际上已经可以被提交，而是通过提交此后的 entry 来间接地提交这些 entry。这种做法能够 work 的基础是 Log Matching Property：</p><blockquote><p>Log Matching: if two logs contain an entry with the same index and term, then the logs are identical in all entries up through the given index.</p></blockquote><h2 id=installsnapshot-prc>InstallSnapshot PRC<a hidden class=anchor aria-hidden=true href=#installsnapshot-prc>#</a></h2><p>invoked by leader to send chunks of a snapshot to a follower.Leaders always send chunks in order.
虽然多数情况都是每个服务器独立创建快照, 但是leader有时候必须发送快照给一些落后太多的follower, 这通常发生在leader已经丢弃了下一条要发给该follower的日志条目(Log Compaction时清除掉了)的情况下。</p><p>Args</p><ul><li><code>term</code>: Leader 任期。同样，InstallSnapshot RPC 也要遵循 Figure 2 中的规则。如果节点发现自己的任期小于 Leader 的任期，就要及时更新</li><li><code>leaderId</code>: 用于重定向 client</li><li><code>lastIncludedIndex</code>: 快照中包含的最后一个 entry 的 index</li><li><code>lastIncludedTerm</code>: 快照中包含的最后一个 entry 的 index 对应的 term</li><li><code>offset</code>: 分块在快照中的偏移量</li><li><code>data[]</code>: 快照数据</li><li><code>done</code>: 如果是最后一块数据则为真</li></ul><p>Reply</p><ul><li><code>term</code>: 节点的任期。Leader 发现高于自己任期的节点时，更新任期并转变为 Follower</li></ul><p>Receiver Implementation 接收日志的follower需要实现的</p><ol><li>如果 term &lt; currentTerm，直接返回</li><li>如果是第一个分块 (offset为0) 则创建新的快照</li><li>在指定的偏移量写入数据</li><li>如果done为false, 则回复并继续等待之后的数据</li><li>保存快照文件, 丢弃所有已存在的或者部分有着更小索引号的快照</li><li>如果现存的日志拥有相同的最后任期号和索引值, 则后面的数据继续保留并且回复</li><li>丢弃全部日志</li><li>能够使用快照来恢复状态机 (并且装载快照中的集群配置)</li></ol><h1 id=一次请求-raft-需要做如下流程>一次请求 Raft 需要做如下流程：<a hidden class=anchor aria-hidden=true href=#一次请求-raft-需要做如下流程>#</a></h1><ol><li>Leader (Follower 收到会定向给Leader)收到 client 的请求；</li><li>Leader 把 entry 写入持久存储；</li><li>Leader 发送 log replication message(AppendEntries RPC) 给 Follower；</li><li>Follower 接收之后，把 entry 写入持久存储，然后给 Leader 发送响应；</li><li>Leader 等待 Follower 的响应，若 majority 节点接收了，则 apply；</li><li>Leader 将结果返回给 client。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/raft/>Raft</a></li><li><a href=https://reid00.github.io/en/tags/mit6.824/>MIT6.824</a></li><li><a href=https://reid00.github.io/en/tags/consensus/>Consensus</a></li><li><a href=https://reid00.github.io/en/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/>共识算法</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-lab2d-log-persistence/><span class=title>« Prev</span><br><span>MIT6.824 2022 Raft Lab2D Log Persistence</span>
</a><a class=next href=https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-lab2a-leader-election/><span class=title>Next »</span><br><span>MIT6.824 2022 Raft Lab2A Leader Election</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>