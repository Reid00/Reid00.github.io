<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MySql索引介绍 | Reid's Blog</title>
<meta name=keywords content="MySql,索引"><meta name=description content="MySql索引介绍"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/storage/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/storage/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var doNotTrack=!1,dnt;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="MySql索引介绍"><meta property="og:description" content="MySql索引介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/storage/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:35:06+08:00"><meta property="article:modified_time" content="2023-03-16T19:35:06+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="MySql索引介绍"><meta name=twitter:description content="MySql索引介绍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"存储, 分布式相关的文章","item":"https://reid00.github.io/en/posts/storage/"},{"@type":"ListItem","position":3,"name":"MySql索引介绍","item":"https://reid00.github.io/en/posts/storage/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MySql索引介绍","name":"MySql索引介绍","description":"MySql索引介绍","keywords":["MySql","索引"],"articleBody":"什么是索引，索引的作用 当我们要在新华字典里查某个字（如「先」）具体含义的时候，通常都会拿起一本新华字典来查，你可以先从头到尾查询每一页是否有「先」这个字，这样做（对应数据库中的全表扫描）确实能找到，但效率无疑是非常低下的，更高效的方相信大家也都知道，就是在首页的索引里先查找「先」对应的页数，然后直接跳到相应的页面查找，这样查询时候大大减少了，可以为是 O(1)。\n数据库中的索引也是类似的，通过索引定位到要读取的页，大大减少了需要扫描的行数，能极大的提升效率，简而言之，索引主要有以下几个作用:\n即上述所说，索引能极大地减少扫描行数 索引可以帮助服务器避免排序和临时表 索引可以将随机 IO 变成顺序 IO MySQL中索引的存储类型有两种：BTREE和HASH，具体和表的存储引擎相关；\nMyISAM和InnoDB存储引擎只支持BTREE索引，MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。\n第一点上文已经解释了，我们来看下第二点和第三点\n先来看第二点，假设我们不用索引，试想运行如下语句\n1 select * from user order by age desc 则 MySQL 的流程是这样的，扫描所有行，把所有行加载到内存后，再按 age 排序生成一张临时表，再把这表排序后将相应行返回给客户端，更糟的，如果这张临时表的大小大于 tmp_table_size 的值（默认为 16 M），内存临时表会转为磁盘临时表，性能会更差，如果加了索引，索引本身是有序的 ，所以从磁盘读的行数本身就是按 age 排序好的，也就不会生成临时表，就不用再额外排序 ，无疑提升了性能。\n再来看随机 IO 和顺序 IO。先来解释下这两个概念。\n相信不少人应该吃过旋转火锅，服务员把一盘盘的菜放在旋转传输带上，然后等到这些菜转到我们面前，我们就可以拿到菜了，假设装一圈需要 4 分钟，则最短等待时间是 0（即菜就在你跟前），最长等待时间是 4 分钟（菜刚好在你跟前错过），那么平均等待时间即为 2 分钟，假设我们现在要拿四盘菜，这四盘菜随机分配在传输带上，则可知拿到这四盘菜的平均等待时间是 8 分钟（随机 IO），如果这四盘菜刚好紧邻着排在一起，则等待时间只需 2 分钟（顺序 IO）。\n上述中传输带就类比磁道，磁道上的菜就类比扇区（sector）中的信息，磁盘块（block）是由多个相邻的扇区组成的，是操作系统读取的最小单元，这样如果信息能以 block 的形式聚集在一起，就能极大减少磁盘 IO 时间,这就是顺序 IO 带来的性能提升，下文中我们将会看到 B+ 树索引就起到这样的作用。\n如图示：多个扇区组成了一个 block，如果要读的信息都在这个 block 中，则只需一次 IO 读\n而如果信息在一个磁道中, 分散地分布在各个扇区中，或者分布在不同磁道的扇区上（寻道时间是随机IO主要瓶颈所在），将会造成随机 IO，影响性能。\n我们来看一下一个随机 IO 的时间分布：\nseek Time: 寻道时间，磁头移动到扇区所在的磁道 Rotational Latency：完成步骤 1 后，磁头移动到同一磁道扇区对应的位置所需求时间 Transfer Time 从磁盘读取信息传入内存时间 这其中寻道时间占据了绝大多数的时间（大概占据随机 IO 时间的占 40%）。\n随机 IO 和顺序 IO 大概相差百倍 (随机 IO：10 ms/ page, 顺序 IO 0.1ms / page)，可见顺序 IO 性能之高，索引带来的性能提升显而易见！\n索引的种类 索引主要分为以下几类\nB+树索引 哈希索引 B+树索引 B+ 树索引之前在此文中详细阐述过，强烈建议大家看一遍，对理解 B+ 树有很大的帮助，简单回顾一下吧\nB+ 树是以 N 叉树的形式存在的，这样有效降低了树的高度，查找数据也不需要全表扫描了，顺着根节点层层往下查找能很快地找到我们的目标数据。 每个节点的大小即一个页的大小，一次 IO 会将一个页（每页包含多个磁盘块）的数据都读入（即磁盘预读，程序局部性原理:读到了某个值，很大可能这个值周围的数据也会被用到，干脆一起读入内存），叶子节点通过指针的相互指向连接，能有效减少顺序遍历时的随机 IO，而且我们也可以看到，叶子节点都是按索引的顺序排序好的，这也意味着根据索引查找或排序都是排序好了的，不会再在内存中形成临时表。\n详解：Mysql设计利用了磁盘预读原理，将一个B+Tree节点大小设为一个页大小，在新建节点时直接申请一个页的空间，这样就能保证一个节点物理上存储在一个页里，加之计算机存储分配都是按页对齐的，这样就实现了每个Node节点只需要一次I/O操作。\n一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍16K，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。\nB树和B+树的区别，数据库为什么使用B+树而不是B树？ 在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。 B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。 B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。 B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快. 因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；B 树进行范围查询，会产生大量随机IO 在B+树中叶子节点存放数据，非叶子节点存放键值+指针。 哈希索引 哈希索引基本散列表实现，散列表（也称哈希表）是根据关键码值(Key value)而直接进行访问的数据结构，它让码值经过哈希函数的转换映射到散列表对应的位置上，查找效率非常高。假设我们对名字建立了哈希索引，则查找过程如下图所示：\n对于每一行数据，存储引擎都会对所有的索引列（上图中的 name 列）计算一个哈希码（上图散列表的位置），散列表里的每个元素指向数据行的指针，由于索引自身只存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引查找速度非常快！\n当然了哈希表的劣势也是比较明显的，不支持区间查找，不支持排序，所以更多的时候哈希表是与 B Tree等一起使用的，在 InnoDB 引擎中就有一种名为「自适应哈希索引」的特殊索引，当 innoDB 注意到某些索引值使用非常频繁时，就会内存中基于 B-Tree 索引之上再创建哈希索引，这样也就让 B+ 树索引也有了哈希索引的快速查找等优点，这是完全自动，内部的行为，用户无法控制或配置，不过如果有必要，可以关闭该功能。\ninnoDB 引擎本身是不支持显式创建哈希索引的，我们可以在 B+ 树的基础上创建一个伪哈希索引，它与真正的哈希索引不是一回事，它是以哈希值而非键本身来进行索引查找的，这种伪哈希索引的使用场景是怎样的呢，假设我们在 db 某张表中有个 url 字段，我们知道每个 url 的长度都很长，如果以 url 这个字段创建索引，无疑要占用很大的存储空间，如果能通过哈希（比如CRC32）把此 url 映射成 4 个字节，再以此哈希值作索引 ，索引占用无疑大大缩短！不过在查询的时候要记得同时带上 url 和 url_crc,主要是为了避免哈希冲突，导致 url_crc 的值可能一样\n1 SELECT id FROM url WHERE url = \"http://www.baidu.com\" AND url_crc = CRC32(\"http://www.baidu.com\") 这样做把基于 url 的字符串索引改成了基于 url_crc 的整型索引，效率更高，同时索引占用的空间也大大减少，一举两得，当然人可能会说需要手动维护索引太麻烦了，那可以改进触发器实现。\n除了上文说的两个索引 ，还有空间索引（R-Tree），全文索引等，由生产中不是很常用，这里不作过多阐述\n高性能索引策略 不同的索引设计选择能对性能产生很大的影响，有人可能会发现生产中明明加了索引却不生效，有时候加了虽然生效但对搜索性能并没有提升多少，对于多列联合索引，哪列在前，哪列在后也是有讲究的，我们一起来看看\n加了索引，为何却不生效 加了索引却不生效可能会有以下几种原因\n1、索引列是表示式的一部分，或是函数的一部分 1 SELECT book_id FROM BOOK WHERE book_id + 1 = 5; 或者\n1 SELECT book_id FROM BOOK WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(gmt_create) \u003c= 10 上述两个 SQL 虽然在列 book_id 和 gmt_create 设置了索引 ，但由于它们是表达式或函数的一部分，导致索引无法生效，最终导致全表扫描。\n2、隐式类型转换 以上两种情况相信不少人都知道索引不能生效，但下面这种隐式类型转换估计会让不少人栽跟头，来看下下面这个例子:\n假设有以下表:\n1 2 3 4 5 6 7 8 9 CREATE TABLE `tradelog` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `operator` int(11) DEFAULT NULL, `t_modified` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`), KEY `t_modified` (`t_modified`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 执行 SQL 语句\n1 SELECT * FROM tradelog WHERE tradeid=110717; 交易编号 tradeid 上有索引，但用 EXPLAIN 执行却发现使用了全表扫描，为啥呢，tradeId 的类型是 varchar(32), 而此 SQL 用 tradeid 一个数字类型进行比较，发生了隐形转换，会隐式地将字符串转成整型，如下:\n1 SELECT * FROM tradelog WHERE CAST(tradid AS signed int) = 110717; 这样也就触发了上文中第一条的规则 ，即：索引列不能是函数的一部分。\n3、隐式编码转换 这种情况非常隐蔽，来看下这个例子\n1 2 3 4 5 6 7 CREATE TABLE `trade_detail` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `trade_step` int(11) DEFAULT NULL, /*操作步骤*/ `step_info` varchar(32) DEFAULT NULL, /*步骤信息*/ PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; trade_detail 是交易详情， tradelog 是操作此交易详情的记录，现在要查询 id=2 的交易的所有操作步骤信息，则我们会采用如下方式\n1 SELECT d.* FROM tradelog l, trade_detail d WHERE d.tradeid=l.tradeid AND l.id=2; 由于 tradelog 与 trade_detail 这两个表的字符集不同，且 tradelog 的字符集是 utf8mb4，而 trade_detail 字符集是 utf8, utf8mb4 是 utf8 的超集，所以会自动将 utf8 转成 utf8mb4。即上述语句会发生如下转换:\n1 SELECT d.* FROM tradelog l, trade_detail d WHERE (CONVERT(d.traideid USING utf8mb4)))=l.tradeid AND l.id=2; 自然也就触发了 「索引列不能是函数的一部分」这条规则。怎么解决呢，第一种方案当然是把两个表的字符集改成一样，如果业务量比较大，生产上不方便改的话，还有一种方案是把 utf8mb4 转成 utf8，如下\n1 SELECT d.* FROM tradelog l , trade_detail d WHERE d.tradeid=CONVERT(l.tradeid USING utf8) AND l.id=2; 这样索引列就生效了。\n4、使用 order by 造成的全表扫描 1 SELECT * FROM user ORDER BY age DESC 上述语句在 age 上加了索引，但依然造成了全表扫描，这是因为我们使用了 SELECT *,导致回表查询，MySQL 认为回表的代价比全表扫描更大，所以不选择使用索引，如果想使用到 age 的索引，我们可以用覆盖索引来代替:\n1 SELECT age FROM user ORDER BY age DESC 或者加上 limit 的条件（数据比较小）\n1 SELECT * FROM user ORDER BY age DESC limit 10 这样就能利用到索引。\n无法避免对索引列使用函数，怎么使用索引 时候我们无法避免对索引列使用函数，但这样做会导致全表索引，是否有更好的方式呢。\n比如我现在就是想记录 2016 ~ 2018 所有年份 7月份的交易记录总数\n1 SELECT count(*) FROM tradelog WHERE month(t_modified)=7; 由于索引列是函数的参数，所以显然无法用到索引，我们可以将它改造成基本字段区间的查找如下\n1 2 3 4 SELECT count(*) FROM tradelog WHERE -\u003e (t_modified \u003e= '2016-7-1' AND t_modified\u003c'2016-8-1') or -\u003e (t_modified \u003e= '2017-7-1' AND t_modified\u003c'2017-8-1') or -\u003e (t_modified \u003e= '2018-7-1' AND t_modified\u003c'2018-8-1'); 前缀索引与索引选择性 之前我们说过，如于长字符串的字段（如 url），我们可以用伪哈希索引的形式来创建索引，以避免索引变得既大又慢，除此之外其实还可以用前缀索引（字符串的部分字符）的形式来达到我们的目的，那么这个前缀索引应该如何选取呢，这叫涉及到一个叫索引选择性的概念\n索引选择性：不重复的索引值（也称为基数，cardinality）和数据表的记录总数的比值，比值越高，代表索引的选择性越好，唯一索引的选择性是最好的，比值是 1。\n画外音：我们可以通过 SHOW INDEXES FROM table 来查看每个索引 cardinality 的值以评估索引设计的合理性\n怎么选择这个比例呢，我们可以分别取前 3，4，5，6，7 的前缀索引，然后再比较下选择这几个前缀索引的选择性，执行以下语句\n1 2 3 4 5 6 7 SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*) as sel3, COUNT(DISTINCT LEFT(city,4))/COUNT(*) as sel4, COUNT(DISTINCT LEFT(city,5))/COUNT(*) as sel5, COUNT(DISTINCT LEFT(city,6))/COUNT(*) as sel6, COUNT(DISTINCT LEFT(city,7))/COUNT(*) as sel7 FROM city_demo 得结果如下\nsel3 sel4 sel5 sel6 sel7 0.0239 0.0293 0.0305 0.0309 0.0310 可以看到当前缀长度为 7 时，索引选择性提升的比例已经很小了，也就是说应该选择 city 的前六个字符作为前缀索引，如下\n1 ALTER TABLE city_demo ADD KEY(city(6)) 我们当前是以平均选择性为指标的，有时候这样是不够的，还得考虑最坏情况下的选择性，以这个 demo 为例，可能一些人看到选择 4，5 的前缀索引与选择 6，7 的选择性相差不大，那就得看下选择 4，5 的前缀索引分布是否均匀了\n1 2 3 4 SELECT COUNT(*) AS cnt, LEFT(city, 4) AS pref FROM city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 5 可能会出现以下结果\ncnt pref 305 Sant 200 Toul 90 Chic 20 Chan 可以看到分布极不均匀，以 Sant，Toul 为前缀索引的数量极多，这两者的选择性都不是很理想，所以要选择前缀索引时也要考虑最差的选择性的情况。\n前缀索引虽然能实现索引占用空间小且快的效果，但它也有明显的弱点，MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY ，而且也无法使用前缀索引做覆盖扫描，前缀索引也有可能增加扫描行数。\n假设有以下表数据及要执行的 SQL\nd email 1 zhangssxyz@163.com 2 zhangs1@163.com 3 zhangs1@163.com 4 zhangs1@163.com 1 SELECT id,email FROM user WHERE email='zhangssxyz@xxx.com'; 如果我们针对 email 设置的是整个字段的索引，则上表中根据 「zhangssxyz@163.com」查询到相关记记录后,再查询此记录的下一条记录，发现没有，停止扫描。此时可知只扫描一行记录，如果我们以前六个字符（即 email(6)）作为前缀索引，则显然要扫描四行记录，并且获得行记录后不得不回到主键索引再判断 email 字段的值，所以使用前缀索引要评估它带来的这些开销。\n另外有一种情况我们可能需要考虑一下，如果前缀基本都是相同的该怎么办，比如现在我们为某市的市民建立一个人口信息表，则这个市人口的身份证虽然不同，但身份证前面的几位数都是相同的，这种情况该怎么建立前缀索引呢。\n一种方式就是我们上文说的，针对身份证建立哈希索引，另一种方式比较巧妙，将身份证倒序存储，查的时候可以按如下方式查询:\n1 SELECT field_list FROM t WHERE id_card = reverse('input_id_card_string'); 这样就可以用身份证的后六位作前缀索引了，是不是很巧妙 ^_^\n实际上上文所述的索引选择性同样适用于联合索引的设计，如果没有特殊情况，我们一般建议在建立联合索引时，把选择性最高的列放在最前面，比如，对于以下语句：\n1 SELECT * FROM payment WHERE staff_id = xxx AND customer_id = xxx; 单就这个语句而言， (staff_id，customer_id) 和 (customer_id, staff_id) 这两个联合索引我们应该建哪一个呢，可以统计下这两者的选择性。\n1 2 3 4 5 SELECT COUNT(DISTINCT staff_id)/COUNT(*) as staff_id_selectivity, COUNT(DISTINCT customer_id)/COUNT(*) as customer_id_selectivity, COUNT(*) FROM payment 结果为:\n1 2 3 staff_id_selectivity: 0.0001 customer_id_selectivity: 0.0373 COUNT(*): 16049 从中可以看出 customer_id 的选择性更高，所以应该选择 customer_id 作为第一列。\n索引设计准则：三星索引 上文我们得出了一个索引列顺序的经验 法则：将选择性最高的列放在索引的最前列，这种建立在某些场景可能有用，但通常不如避免随机 IO 和 排序那么重要，这里引入索引设计中非常著名的一个准则：三星索引。\n如果一个查询满足三星索引中三颗星的所有索引条件，理论上可以认为我们设计的索引是最好的索引。什么是三星索引\n第一颗星：WHERE 后面参与查询的列可以组成了单列索引或联合索引 第二颗星：避免排序，即如果 SQL 语句中出现 order by colulmn，那么取出的结果集就已经是按照 column 排序好的，不需要再生成临时表 第三颗星：SELECT 对应的列应该尽量是索引列，即尽量避免回表查询。 所以对于如下语句:\n1 SELECT age, name, city where age = xxx and name = xxx order by age 设计的索引应该是 (age, name,city) 或者 (name, age,city)\n当然 了三星索引是一个比较理想化的标准，实际操作往往只能满足期望中的一颗或两颗星，考虑如下语句:\n1 SELECT age, name, city where age \u003e= 10 AND age \u003c= 20 and city = xxx order by name desc 假设我们分别为这三列建了联合索引，则显然它符合第三颗星（使用了覆盖索引），如果索引是（city, age, name)，则虽然满足了第一颗星，但排序无法用到索引，不满足第二颗星，如果索引是 (city, name, age)，则第二颗星满足了，但此时 age 在 WHERE 中的搜索条件又无法满足第一星，\n另外第三颗星（尽量使用覆盖索引）也无法完全满足，试想我要 SELECT 多列，要把这多列都设置为联合索引吗，这对索引的维护是个问题，因为每一次表的 CURD 都伴随着索引的更新，很可能频繁伴随着页分裂与页合并。\n综上所述，三星索引只是给我们构建索引提供了一个参考，索引设计应该尽量靠近三星索引的标准，但实际场景我们一般无法同时满足三星索引，一般我们会优先选择满足第三颗星（因为回表代价较大）至于第一，二颗星就要依赖于实际的成本及实际的业务场景考虑。\n为什么要一定要设置主键? from: https://zhuanlan.zhihu.com/p/116866170\n其实这个不是一定的，有些场景下，小系统或者没什么用的表，不设置主键也没关系，mysql最好是用自增主键，主要是以下两个原因：果定义了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则innodb 会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则innodb 会选择内置6字节长的ROWID作为隐含的聚集索引。所以，反正都要生成一个主键，那你还不如自己指定一个主键，提高查询效率！\n前面我写了几篇关于 mysql 索引的文章，索引是 mysql 非常重要的一部分。你也可能经常会看到一些关于 mysql 军规、mysql 查询优化的文章，其实这些操作的背后都是基于一定的原理的，你要想明白这些原理，首先就得知道 mysql 底层的一些东西。\n我在这里举几个例子吧。\n我们都知道表的主键一般都要使用自增 id，不建议使用业务 id ，是因为使用自增 id 可以避免页分裂。这个其实可以相当于一个结论，你都可以直接记住这个结论就可以了。\n但是如果你要弄明白什么是页分裂，或者什么情况下会页分裂，这个时候你就需要对 mysql 的底层数据结构要有一定的理解了。\n我这里也稍微解释一下页分裂，mysql （注意本文讲的 mysql 默认为InnoDB 引擎）底层数据结构是 B+ 树，所谓的索引其实就是一颗 B+ 树，一个表有多少个索引就会有多少颗 B+ 树，mysql 中的数据都是按顺序保存在 B+ 树上的（所以说索引本身是有序的）。\n然后 mysql 在底层又是以数据页为单位来存储数据的，一个数据页大小默认为 16k，当然你也可以自定义大小，也就是说如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。\n如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。\n如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。\n当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上。\n这就造成了页分裂，这个大量移动数据的过程是会严重影响插入效率的。\n其实对主键 id 还有一个小小的要求，在满足业务需求的情况下，尽量使用占空间更小的主键 id，因为普通索引的叶子节点上保存的是主键 id 的值，如果主键 id 占空间较大的话，那将会成倍增加 mysql 空间占用大小。\n主键是用自增还是UUID 最好是用自增主键，主要是以下两个原因：\n1. 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 2. 如果使用非自增主键（如uuid），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到索引页的随机某个位置，此时MySQL为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成索引碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。\n不过，也不是所有的场景下都得使用自增主键，可能场景下，主键必须自己生成，不在乎那些性能的开销。那也没有问题。\n自增主键用完了怎么办? 在mysql中，Int整型的范围（-2147483648~2147483648），约20亿！因此不用考虑自增ID达到最大值这个问题。而且数据达到千万级的时候就应该考虑分库分表了。\n主键为什么不推荐有业务含义? 最好是主键是无意义的自增ID，然后另外创建一个业务主键ID，\n因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。\n还有就是，带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。\n货币字段用什么类型 货币字段一般都用 Decimal类型， float和double是以二进制存储的，数据大的时候，可能存在误差。\n以下是FLOAT和DOUBLE的区别：\n浮点数以8位精度存储在FLOAT中，并且有四个字节。\n浮点数存储在DOUBLE中，精度为18位，有八个字节。\n表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，那么是拆成子表好？还是放一起好？ 其实各有利弊，拆开带来的问题：连接消耗；不拆可能带来的问题：查询性能，所以要看你的实际情况，如果表数据量比较大，最好还是拆开为好。这样查询速度更快。\n字段为什么要定义为NOT NULL? 一般情况，都会设置一个默认值，不会出现字段里面有null，又有空的情况。主要有以下几个原因：\n索引性能不好，Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。\n如果某列存在null的情况，可能导致count() 等函数执行不对的情况。\nsql 语句写着也麻烦，既要判断是否为空，又要判断是否为null等。\n总结 本文简述了索引的基本原理，索引的几种类型，以及分析了一下设计索引尽量应该遵循的一些准则，相信我们对索引的理解又更深了一步。另外强烈建议大家去学习一下附录中的几本书。文中的挺多例子都是在文末的参考资料中总结出来的，读经典书籍，相信大家会受益匪浅！\n","wordCount":"903","inLanguage":"en","datePublished":"2023-03-16T19:35:06+08:00","dateModified":"2023-03-16T19:35:06+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/storage/mysql%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/storage/>存储, 分布式相关的文章</a></div><h1 class=post-title>MySql索引介绍</h1><div class=post-description>MySql索引介绍</div><div class=post-meta>&lt;span title='2023-03-16 19:35:06 +0800 +0800'>2023-03-16&lt;/span>&amp;nbsp;·&amp;nbsp;5 min&amp;nbsp;·&amp;nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e7%b4%a2%e5%bc%95%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=什么是索引，索引的作用>什么是索引，索引的作用</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e7%9a%84%e7%a7%8d%e7%b1%bb aria-label=索引的种类>索引的种类</a><ul><li><a href=#b%e6%a0%91%e7%b4%a2%e5%bc%95 aria-label=B+树索引>B+树索引</a></li><li><a href=#b%e6%a0%91%e5%92%8cb%e6%a0%91%e7%9a%84%e5%8c%ba%e5%88%ab%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8b%e6%a0%91%e8%80%8c%e4%b8%8d%e6%98%afb%e6%a0%91 aria-label=B树和B+树的区别，数据库为什么使用B+树而不是B树？>B树和B+树的区别，数据库为什么使用B+树而不是B树？</a></li><li><a href=#%e5%93%88%e5%b8%8c%e7%b4%a2%e5%bc%95 aria-label=哈希索引>哈希索引</a></li></ul></li><li><a href=#%e9%ab%98%e6%80%a7%e8%83%bd%e7%b4%a2%e5%bc%95%e7%ad%96%e7%95%a5 aria-label=高性能索引策略>高性能索引策略</a><ul><li><a href=#%e5%8a%a0%e4%ba%86%e7%b4%a2%e5%bc%95%e4%b8%ba%e4%bd%95%e5%8d%b4%e4%b8%8d%e7%94%9f%e6%95%88 aria-label=加了索引，为何却不生效>加了索引，为何却不生效</a><ul><li><a href=#1%e7%b4%a2%e5%bc%95%e5%88%97%e6%98%af%e8%a1%a8%e7%a4%ba%e5%bc%8f%e7%9a%84%e4%b8%80%e9%83%a8%e5%88%86%e6%88%96%e6%98%af%e5%87%bd%e6%95%b0%e7%9a%84%e4%b8%80%e9%83%a8%e5%88%86 aria-label=1、索引列是表示式的一部分，或是函数的一部分>1、索引列是表示式的一部分，或是函数的一部分</a></li><li><a href=#2%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=2、隐式类型转换>2、隐式类型转换</a></li><li><a href=#3%e9%9a%90%e5%bc%8f%e7%bc%96%e7%a0%81%e8%bd%ac%e6%8d%a2 aria-label=3、隐式编码转换>3、隐式编码转换</a></li><li><a href=#4%e4%bd%bf%e7%94%a8-order-by-%e9%80%a0%e6%88%90%e7%9a%84%e5%85%a8%e8%a1%a8%e6%89%ab%e6%8f%8f aria-label="4、使用 order by 造成的全表扫描">4、使用 order by 造成的全表扫描</a></li></ul></li><li><a href=#%e6%97%a0%e6%b3%95%e9%81%bf%e5%85%8d%e5%af%b9%e7%b4%a2%e5%bc%95%e5%88%97%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95 aria-label=无法避免对索引列使用函数，怎么使用索引>无法避免对索引列使用函数，怎么使用索引</a></li><li><a href=#%e5%89%8d%e7%bc%80%e7%b4%a2%e5%bc%95%e4%b8%8e%e7%b4%a2%e5%bc%95%e9%80%89%e6%8b%a9%e6%80%a7 aria-label=前缀索引与索引选择性>前缀索引与索引选择性</a></li></ul></li><li><a href=#%e7%b4%a2%e5%bc%95%e8%ae%be%e8%ae%a1%e5%87%86%e5%88%99%e4%b8%89%e6%98%9f%e7%b4%a2%e5%bc%95 aria-label=索引设计准则：三星索引>索引设计准则：三星索引</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%b8%80%e5%ae%9a%e8%a6%81%e8%ae%be%e7%bd%ae%e4%b8%bb%e9%94%ae aria-label=为什么要一定要设置主键?><strong>为什么要一定要设置主键?</strong></a></li><li><a href=#%e4%b8%bb%e9%94%ae%e6%98%af%e7%94%a8%e8%87%aa%e5%a2%9e%e8%bf%98%e6%98%afuuid aria-label=主键是用自增还是UUID><strong>主键是用自增还是UUID</strong></a></li><li><a href=#%e8%87%aa%e5%a2%9e%e4%b8%bb%e9%94%ae%e7%94%a8%e5%ae%8c%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e aria-label=自增主键用完了怎么办?><strong>自增主键用完了怎么办?</strong></a></li><li><a href=#%e4%b8%bb%e9%94%ae%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%8e%a8%e8%8d%90%e6%9c%89%e4%b8%9a%e5%8a%a1%e5%90%ab%e4%b9%89 aria-label=主键为什么不推荐有业务含义?><strong>主键为什么不推荐有业务含义?</strong></a></li><li><a href=#%e8%b4%a7%e5%b8%81%e5%ad%97%e6%ae%b5%e7%94%a8%e4%bb%80%e4%b9%88%e7%b1%bb%e5%9e%8b aria-label=货币字段用什么类型><strong>货币字段用什么类型</strong></a></li><li><a href=#%e8%a1%a8%e4%b8%ad%e6%9c%89%e5%a4%a7%e5%ad%97%e6%ae%b5x%e4%be%8b%e5%a6%82text%e7%b1%bb%e5%9e%8b%e4%b8%94%e5%ad%97%e6%ae%b5x%e4%b8%8d%e4%bc%9a%e7%bb%8f%e5%b8%b8%e6%9b%b4%e6%96%b0%e4%bb%a5%e8%af%bb%e4%b8%ba%e4%b8%bb%e9%82%a3%e4%b9%88%e6%98%af%e6%8b%86%e6%88%90%e5%ad%90%e8%a1%a8%e5%a5%bd%e8%bf%98%e6%98%af%e6%94%be%e4%b8%80%e8%b5%b7%e5%a5%bd aria-label=表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，那么是拆成子表好？还是放一起好？><strong>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，那么是拆成子表好？还是放一起好？</strong></a></li><li><a href=#%e5%ad%97%e6%ae%b5%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ae%9a%e4%b9%89%e4%b8%banot-null aria-label="字段为什么要定义为NOT NULL?"><strong>字段为什么要定义为NOT NULL?</strong></a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h3 id=什么是索引索引的作用>什么是索引，索引的作用<a hidden class=anchor aria-hidden=true href=#什么是索引索引的作用>#</a></h3><p>当我们要在新华字典里查某个字（如「先」）具体含义的时候，通常都会拿起一本新华字典来查，你可以先从头到尾查询每一页是否有「先」这个字，这样做（对应数据库中的全表扫描）确实能找到，但效率无疑是非常低下的，更高效的方相信大家也都知道，就是在首页的索引里先查找「先」对应的页数，然后直接跳到相应的页面查找，这样查询时候大大减少了，可以为是 O(1)。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLVeqReRUs3d1PtxtB9ibNZc053QsqckPrOxzj2kWccVGXcoibkicBvvrWO1SBCicia12LibDhKZHrd1mCRQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><p>数据库中的索引也是类似的，通过索引定位到要读取的页，大大减少了需要扫描的行数，能极大的提升效率，简而言之，索引主要有以下几个作用:</p><ol><li><strong>即上述所说，索引能极大地减少扫描行数</strong></li><li><strong>索引可以帮助服务器避免排序和临时表</strong></li><li><strong>索引可以将随机 IO 变成顺序 IO</strong></li></ol><p>MySQL中索引的存储类型有两种：<code>BTREE和HASH</code>，具体和表的存储引擎相关；</p><p>MyISAM和InnoDB存储引擎<strong>只支持BTREE索引</strong>，MEMORY/HEAP存储引擎<strong>可以支持HASH和BTREE索引</strong>。</p><p>第一点上文已经解释了，我们来看下第二点和第三点</p><p>先来看第二点，假设我们不用索引，试想运行如下语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=k>desc</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>则 MySQL 的流程是这样的，扫描所有行，把所有行加载到内存后，再按 age 排序生成一张临时表，再把这表排序后将相应行返回给客户端，更糟的，如果这张临时表的大小大于 tmp_table_size 的值（默认为 16 M），内存临时表会转为磁盘临时表，性能会更差，如果加了索引，索引本身是有序的 ，所以从磁盘读的行数本身就是按 age 排序好的，也就不会生成临时表，就不用再额外排序 ，无疑提升了性能。</p><p>再来看随机 IO 和顺序 IO。先来解释下这两个概念。</p><p>相信不少人应该吃过旋转火锅，服务员把一盘盘的菜放在旋转传输带上，然后等到这些菜转到我们面前，我们就可以拿到菜了，假设装一圈需要 4 分钟，则最短等待时间是 0（即菜就在你跟前），最长等待时间是 4 分钟（菜刚好在你跟前错过），那么平均等待时间即为 2 分钟，假设我们现在要拿四盘菜，这四盘菜<strong>随机分配</strong>在传输带上，则可知拿到这四盘菜的平均等待时间是 8 分钟（随机 IO），如果这四盘菜刚好紧邻着排在一起，则等待时间只需 2 分钟（顺序 IO）。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLVeqReRUs3d1PtxtB9ibNZc0yYI1ibAoeJo8WL0Ywm2Xe3IUqgV0amb6IeoFJulibXJ5q7U8jukHibNvQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><p>上述中传输带就类比磁道，磁道上的菜就类比扇区（sector）中的信息，<strong>磁盘块（block）<strong>是由多个相邻的扇区组成的，是操作系统</strong>读取的最小单元</strong>，这样如果信息能以 block 的形式聚集在一起，就能极大减少磁盘 IO 时间,这就是顺序 IO 带来的性能提升，下文中我们将会看到 B+ 树索引就起到这样的作用。</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLVeqReRUs3d1PtxtB9ibNZc0ydwFBgDjkEA7YUer3roicuaY3qz5q32PUN4eyaq1YZibZzxc99t9TRXw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><p><em><strong>如图示：多个扇区组成了一个 block，如果要读的信息都在这个 block 中，则只需一次 IO 读</strong></em></p><p>而如果信息在一个磁道中, 分散地分布在各个扇区中，或者分布在不同磁道的扇区上（寻道时间是随机IO主要瓶颈所在），将会造成随机 IO，影响性能。</p><p>我们来看一下一个随机 IO 的时间分布：</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLVeqReRUs3d1PtxtB9ibNZc0gzJbkZTcricC3ibqduLwWrGEJKyXtpbvAohNrqVrYMhKOS7taT5CkQhA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><ol><li>seek Time: 寻道时间，磁头移动到扇区所在的磁道</li><li>Rotational Latency：完成步骤 1 后，磁头移动到同一磁道扇区对应的位置所需求时间</li><li>Transfer Time 从磁盘读取信息传入内存时间</li></ol><p>这其中寻道时间占据了绝大多数的时间（大概占据随机 IO 时间的占 40%）。</p><p>随机 IO 和顺序 IO 大概相差百倍 (随机 IO：10 ms/ page, 顺序 IO 0.1ms / page)，可见顺序 IO 性能之高，索引带来的性能提升显而易见！</p><h3 id=索引的种类>索引的种类<a hidden class=anchor aria-hidden=true href=#索引的种类>#</a></h3><p>索引主要分为以下几类</p><ul><li>B+树索引</li><li>哈希索引</li></ul><h4 id=b树索引>B+树索引<a hidden class=anchor aria-hidden=true href=#b树索引>#</a></h4><p>B+ 树索引之前在<a href=https://reid00.github.io/en/posts/storage/b+%E6%A0%91/>此文</a>中详细阐述过，强烈建议大家看一遍，对理解 B+ 树有很大的帮助，简单回顾一下吧</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLVeqReRUs3d1PtxtB9ibNZc0FXGrE3BQcwLKNC7Fuqkr9iayyLrhkRB785cWdhckcCTbeEDh8GK4ib9w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><p>B+ 树是以 N 叉树的形式存在的，这样有效降低了树的高度，查找数据也不需要全表扫描了，顺着根节点层层往下查找能很快地找到我们的目标数据。 <strong>每个节点的大小即一个页的大小</strong>，一次 IO 会将一个页（<strong>每页包含多个磁盘块</strong>）的数据都读入（即磁盘预读，<strong>程序局部性原理</strong>:读到了某个值，很大可能这个值周围的数据也会被用到，干脆一起读入内存），叶子节点通过指针的相互指向连接，能有效减少顺序遍历时的随机 IO，而且我们也可以看到，叶子节点都是按索引的顺序排序好的，这也意味着根据索引查找或排序都是排序好了的，不会再在内存中形成临时表。</p><p><strong>详解</strong>：Mysql设计利用了磁盘预读原理，将一个B+Tree节点大小设为一个页大小，在新建节点时直接申请一个页的空间，这样就能保证一个节点物理上存储在一个页里，加之计算机存储分配都是按页对齐的，这样就实现了每个Node节点只需要一次I/O操作。</p><p>一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍16K，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。</p><h4 id=b树和b树的区别数据库为什么使用b树而不是b树>B树和B+树的区别，数据库为什么使用B+树而不是B树？<a hidden class=anchor aria-hidden=true href=#b树和b树的区别数据库为什么使用b树而不是b树>#</a></h4><ul><li>在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。</li><li>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。</li></ul><blockquote><ul><li>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</li><li>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快.</li><li>因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；B 树进行范围查询，会产生大量随机IO</li><li>在B+树中叶子节点存放数据，非叶子节点存放键值+指针。</li></ul></blockquote><h4 id=哈希索引>哈希索引<a hidden class=anchor aria-hidden=true href=#哈希索引>#</a></h4><p>哈希索引基本散列表实现，散列表（也称哈希表）是根据关键码值(Key value)而直接进行访问的数据结构，它让码值经过哈希函数的转换映射到散列表对应的位置上，查找效率非常高。假设我们对名字建立了哈希索引，则查找过程如下图所示：</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLVeqReRUs3d1PtxtB9ibNZc043qL7uqWObhS1AiaEtPcN85lcicTAibUQDyB9n1FPC3vOAnicEKCC6kSfA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=img></p><p>对于每一行数据，存储引擎都会对所有的索引列（上图中的 name 列）计算一个哈希码（上图散列表的位置），散列表里的每个元素指向数据行的指针，由于索引自身只存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引查找速度非常快！</p><p>当然了哈希表的劣势也是比较明显的，不支持区间查找，不支持排序，所以更多的时候哈希表是与 B Tree等一起使用的，在 InnoDB 引擎中就有一种名为「自适应哈希索引」的特殊索引，当 innoDB 注意到某些索引值使用非常频繁时，就会内存中基于 B-Tree 索引之上再创建哈希索引，这样也就让 B+ 树索引也有了哈希索引的快速查找等优点，这是完全自动，内部的行为，用户无法控制或配置，不过如果有必要，可以关闭该功能。</p><p>innoDB 引擎本身是不支持显式创建哈希索引的，我们可以在 B+ 树的基础上创建一个伪哈希索引，它与真正的哈希索引不是一回事，它是以哈希值而非键本身来进行索引查找的，这种伪哈希索引的使用场景是怎样的呢，假设我们在 db 某张表中有个 url 字段，我们知道每个 url 的长度都很长，如果以 url 这个字段创建索引，无疑要占用很大的存储空间，如果能<strong>通过哈希</strong>（比如CRC32）<strong>把此 url 映射成 4 个字节</strong>，<strong>再以此哈希值作索引 ，索引占用无疑大大缩短</strong>！不过在查询的时候要记得同时带上 url 和 url_crc,主要是为了避免哈希冲突，导致 url_crc 的值可能一样</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>url</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>url</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;http://www.baidu.com&#34;</span><span class=w>  </span><span class=k>AND</span><span class=w> </span><span class=n>url_crc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nf>CRC32</span><span class=p>(</span><span class=s2>&#34;http://www.baidu.com&#34;</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这样做把基于 url 的字符串索引改成了基于 url_crc 的整型索引，效率更高，同时索引占用的空间也大大减少，一举两得，当然人可能会说需要手动维护索引太麻烦了，那可以改进触发器实现。</p><p>除了上文说的两个索引 ，还有空间索引（R-Tree），全文索引等，由生产中不是很常用，这里不作过多阐述</p><h3 id=高性能索引策略>高性能索引策略<a hidden class=anchor aria-hidden=true href=#高性能索引策略>#</a></h3><p>不同的索引设计选择能对性能产生很大的影响，有人可能会发现生产中明明加了索引却不生效，有时候加了虽然生效但对搜索性能并没有提升多少，对于多列联合索引，哪列在前，哪列在后也是有讲究的，我们一起来看看</p><h4 id=加了索引为何却不生效>加了索引，为何却不生效<a hidden class=anchor aria-hidden=true href=#加了索引为何却不生效>#</a></h4><p>加了索引却不生效可能会有以下几种原因</p><h5 id=1索引列是表示式的一部分或是函数的一部分>1、索引列是表示式的一部分，或是函数的一部分<a hidden class=anchor aria-hidden=true href=#1索引列是表示式的一部分或是函数的一部分>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>book_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>BOOK</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>book_id</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>或者</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>book_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>BOOK</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=nf>TO_DAYS</span><span class=p>(</span><span class=k>CURRENT_DATE</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nf>TO_DAYS</span><span class=p>(</span><span class=n>gmt_create</span><span class=p>)</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>10</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上述两个 SQL 虽然在列 book_id 和 gmt_create 设置了索引 ，但由于它们是表达式或函数的一部分，导致索引无法生效，最终导致全表扫描。</p><h5 id=2隐式类型转换>2、隐式类型转换<a hidden class=anchor aria-hidden=true href=#2隐式类型转换>#</a></h5><p>以上两种情况相信不少人都知道索引不能生效，但下面这种隐式类型转换估计会让不少人栽跟头，来看下下面这个例子:</p><p>假设有以下表:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>tradelog</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>tradeid</span><span class=o>`</span><span class=w> </span><span class=kt>varchar</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>operator</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>t_modified</span><span class=o>`</span><span class=w> </span><span class=kt>datetime</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>tradeid</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>tradeid</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>t_modified</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>t_modified</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=kp>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=kp>CHARSET</span><span class=o>=</span><span class=n>utf8mb4</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>执行 SQL 语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tradelog</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>tradeid</span><span class=o>=</span><span class=mi>110717</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>交易编号 tradeid 上有索引，但用 EXPLAIN 执行却发现使用了全表扫描，为啥呢，tradeId 的类型是 varchar(32), 而此 SQL 用 tradeid 一个数字类型进行比较，发生了隐形转换，会隐式地将字符串转成整型，如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tradelog</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=nf>CAST</span><span class=p>(</span><span class=n>tradid</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>signed</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>110717</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这样也就触发了上文中第一条的规则 ，即：索引列不能是函数的一部分。</p><h5 id=3隐式编码转换>3、隐式编码转换<a hidden class=anchor aria-hidden=true href=#3隐式编码转换>#</a></h5><p>这种情况非常隐蔽，来看下这个例子</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>trade_detail</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>`</span><span class=n>tradeid</span><span class=o>`</span><span class=w> </span><span class=kt>varchar</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>`</span><span class=n>trade_step</span><span class=o>`</span><span class=w> </span><span class=kt>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w> </span><span class=cm>/*操作步骤*/</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=o>`</span><span class=n>step_info</span><span class=o>`</span><span class=w> </span><span class=kt>varchar</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=no>NULL</span><span class=p>,</span><span class=w> </span><span class=cm>/*步骤信息*/</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>tradeid</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>tradeid</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=kp>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=kp>CHARSET</span><span class=o>=</span><span class=n>utf8</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>trade_detail 是交易详情， tradelog 是操作此交易详情的记录，现在要查询 id=2 的交易的所有操作步骤信息，则我们会采用如下方式</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tradelog</span><span class=w> </span><span class=n>l</span><span class=p>,</span><span class=w> </span><span class=n>trade_detail</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>tradeid</span><span class=o>=</span><span class=n>l</span><span class=p>.</span><span class=n>tradeid</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>l</span><span class=p>.</span><span class=n>id</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>由于 tradelog 与 trade_detail 这两个表的字符集不同，且 tradelog 的字符集是 utf8mb4，而 trade_detail 字符集是 utf8, utf8mb4 是 utf8 的超集，所以会自动将 utf8 转成 utf8mb4。即上述语句会发生如下转换:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tradelog</span><span class=w> </span><span class=n>l</span><span class=p>,</span><span class=w> </span><span class=n>trade_detail</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=p>(</span><span class=k>CONVERT</span><span class=p>(</span><span class=n>d</span><span class=p>.</span><span class=n>traideid</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>utf8mb4</span><span class=p>)))</span><span class=o>=</span><span class=n>l</span><span class=p>.</span><span class=n>tradeid</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>l</span><span class=p>.</span><span class=n>id</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>自然也就触发了 「索引列不能是函数的一部分」这条规则。怎么解决呢，第一种方案当然是把两个表的字符集改成一样，如果业务量比较大，生产上不方便改的话，还有一种方案是把 utf8mb4 转成 utf8，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tradelog</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=p>,</span><span class=w> </span><span class=n>trade_detail</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>d</span><span class=p>.</span><span class=n>tradeid</span><span class=o>=</span><span class=k>CONVERT</span><span class=p>(</span><span class=n>l</span><span class=p>.</span><span class=n>tradeid</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=n>utf8</span><span class=p>)</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>l</span><span class=p>.</span><span class=n>id</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>这样索引列就生效了。</p><h5 id=4使用-order-by-造成的全表扫描>4、使用 order by 造成的全表扫描<a hidden class=anchor aria-hidden=true href=#4使用-order-by-造成的全表扫描>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=k>DESC</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上述语句在 age 上加了索引，但依然造成了全表扫描，这是因为我们使用了 SELECT *,导致回表查询，MySQL 认为回表的代价比全表扫描更大，所以不选择使用索引，如果想使用到 age 的索引，我们可以用覆盖索引来代替:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=k>DESC</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>或者加上 limit 的条件（数据比较小）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=k>DESC</span><span class=w> </span><span class=k>limit</span><span class=w> </span><span class=mi>10</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这样就能利用到索引。</p><h4 id=无法避免对索引列使用函数怎么使用索引>无法避免对索引列使用函数，怎么使用索引<a hidden class=anchor aria-hidden=true href=#无法避免对索引列使用函数怎么使用索引>#</a></h4><p>时候我们无法避免对索引列使用函数，但这样做会导致全表索引，是否有更好的方式呢。</p><p>比如我现在就是想记录 2016 ~ 2018 所有年份 7月份的交易记录总数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=nf>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tradelog</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=nf>month</span><span class=p>(</span><span class=n>t_modified</span><span class=p>)</span><span class=o>=</span><span class=mi>7</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>由于索引列是函数的参数，所以显然无法用到索引，我们可以将它改造成基本字段区间的查找如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=nf>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>tradelog</span><span class=w> </span><span class=k>WHERE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=p>(</span><span class=n>t_modified</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=s1>&#39;2016-7-1&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>t_modified</span><span class=o>&lt;</span><span class=s1>&#39;2016-8-1&#39;</span><span class=p>)</span><span class=w> </span><span class=k>or</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=p>(</span><span class=n>t_modified</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=s1>&#39;2017-7-1&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>t_modified</span><span class=o>&lt;</span><span class=s1>&#39;2017-8-1&#39;</span><span class=p>)</span><span class=w> </span><span class=k>or</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>-&gt;</span><span class=w> </span><span class=p>(</span><span class=n>t_modified</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=s1>&#39;2018-7-1&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>t_modified</span><span class=o>&lt;</span><span class=s1>&#39;2018-8-1&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=前缀索引与索引选择性>前缀索引与索引选择性<a hidden class=anchor aria-hidden=true href=#前缀索引与索引选择性>#</a></h4><p>之前我们说过，如于长字符串的字段（如 url），我们可以用伪哈希索引的形式来创建索引，以避免索引变得既大又慢，除此之外其实还可以用前缀索引（字符串的部分字符）的形式来达到我们的目的，那么这个前缀索引应该如何选取呢，这叫涉及到一个叫索引选择性的概念</p><blockquote><p>索引选择性：不重复的索引值（也称为基数，cardinality）和数据表的记录总数的比值，比值越高，代表索引的选择性越好，唯一索引的选择性是最好的，比值是 1。</p></blockquote><p>画外音：我们可以通过 <strong>SHOW INDEXES FROM table</strong> 来查看每个索引 cardinality 的值以评估索引设计的合理性</p><p>怎么选择这个比例呢，我们可以分别取前 3，4，5，6，7 的前缀索引，然后再比较下选择这几个前缀索引的选择性，执行以下语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>city</span><span class=p>,</span><span class=mi>3</span><span class=p>))</span><span class=o>/</span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sel3</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>city</span><span class=p>,</span><span class=mi>4</span><span class=p>))</span><span class=o>/</span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sel4</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>city</span><span class=p>,</span><span class=mi>5</span><span class=p>))</span><span class=o>/</span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sel5</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>city</span><span class=p>,</span><span class=mi>6</span><span class=p>))</span><span class=o>/</span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sel6</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>city</span><span class=p>,</span><span class=mi>7</span><span class=p>))</span><span class=o>/</span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>sel7</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>city_demo</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>得结果如下</p><table><thead><tr><th style=text-align:left>sel3</th><th style=text-align:left>sel4</th><th style=text-align:left>sel5</th><th style=text-align:left>sel6</th><th style=text-align:left>sel7</th></tr></thead><tbody><tr><td style=text-align:left>0.0239</td><td style=text-align:left>0.0293</td><td style=text-align:left>0.0305</td><td style=text-align:left>0.0309</td><td style=text-align:left>0.0310</td></tr></tbody></table><p>可以看到当前缀长度为 7 时，索引选择性提升的比例已经很小了，也就是说应该选择 city 的前六个字符作为前缀索引，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>city_demo</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=nf>city</span><span class=p>(</span><span class=mi>6</span><span class=p>))</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>我们当前是以平均选择性为指标的，有时候这样是不够的，还得考虑最坏情况下的选择性，以这个 demo 为例，可能一些人看到选择 4，5 的前缀索引与选择 6，7 的选择性相差不大，那就得看下选择 4，5 的前缀索引分布是否均匀了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w>  </span><span class=n>cnt</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>LEFT</span><span class=p>(</span><span class=n>city</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>pref</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>FROM</span><span class=w> </span><span class=n>city_demo</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>pref</span><span class=w> </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>cnt</span><span class=w> </span><span class=k>DESC</span><span class=w> </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>5</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可能会出现以下结果</p><table><thead><tr><th style=text-align:left>cnt</th><th style=text-align:left>pref</th></tr></thead><tbody><tr><td style=text-align:left>305</td><td style=text-align:left>Sant</td></tr><tr><td style=text-align:left>200</td><td style=text-align:left>Toul</td></tr><tr><td style=text-align:left>90</td><td style=text-align:left>Chic</td></tr><tr><td style=text-align:left>20</td><td style=text-align:left>Chan</td></tr></tbody></table><p>可以看到分布极不均匀，以 Sant，Toul 为前缀索引的数量极多，这两者的选择性都不是很理想，所以要选择前缀索引时也要考虑最差的选择性的情况。</p><p>前缀索引虽然能实现索引占用空间小且快的效果，但它也有明显的弱点，MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY ，而且也无法使用前缀索引做覆盖扫描，前缀索引也有可能增加扫描行数。</p><p>假设有以下表数据及要执行的 SQL</p><table><thead><tr><th style=text-align:left>d</th><th style=text-align:left>email</th></tr></thead><tbody><tr><td style=text-align:left>1</td><td style=text-align:left><a href=mailto:zhangssxyz@163.com>zhangssxyz@163.com</a></td></tr><tr><td style=text-align:left>2</td><td style=text-align:left><a href=mailto:zhangs1@163.com>zhangs1@163.com</a></td></tr><tr><td style=text-align:left>3</td><td style=text-align:left><a href=mailto:zhangs1@163.com>zhangs1@163.com</a></td></tr><tr><td style=text-align:left>4</td><td style=text-align:left><a href=mailto:zhangs1@163.com>zhangs1@163.com</a></td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=n>email</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>user</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>email</span><span class=o>=</span><span class=s1>&#39;zhangssxyz@xxx.com&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如果我们针对 email 设置的是整个字段的索引，则上表中根据 「zhangssxyz@163.com」查询到相关记记录后,再查询此记录的下一条记录，发现没有，停止扫描。此时可知<strong>只扫描一行记录</strong>，如果我们以前六个字符（即 email(6)）作为前缀索引，则显然要扫描四行记录，并且获得行记录后不得不回到主键索引再判断 email 字段的值，所以使用前缀索引要评估它带来的这些开销。</p><p>另外有一种情况我们可能需要考虑一下，如果前缀基本都是相同的该怎么办，比如现在我们为某市的市民建立一个人口信息表，则这个市人口的身份证虽然不同，但身份证前面的几位数都是相同的，这种情况该怎么建立前缀索引呢。</p><p>一种方式就是我们上文说的，针对身份证建立哈希索引，另一种方式比较巧妙，将身份证倒序存储，查的时候可以按如下方式查询:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>field_list</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id_card</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nf>reverse</span><span class=p>(</span><span class=s1>&#39;input_id_card_string&#39;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这样就可以用身份证的后六位作前缀索引了，是不是很巧妙 ^_^</p><p>实际上上文所述的索引选择性同样适用于联合索引的设计，如果没有特殊情况，我们一般建议在建立联合索引时，把选择性最高的列放在最前面，比如，对于以下语句：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>payment</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>staff_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>xxx</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>customer_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>xxx</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>单就这个语句而言， (staff_id，customer_id) 和 (customer_id, staff_id) 这两个联合索引我们应该建哪一个呢，可以统计下这两者的选择性。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=n>staff_id</span><span class=p>)</span><span class=o>/</span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>staff_id_selectivity</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=w> </span><span class=n>customer_id</span><span class=p>)</span><span class=o>/</span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>customer_id_selectivity</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>payment</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>结果为:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=n>staff_id_selectivity</span><span class=p>:</span><span class=w> </span><span class=mi>0</span><span class=p>.</span><span class=mi>0001</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>customer_id_selectivity</span><span class=p>:</span><span class=w> </span><span class=mi>0</span><span class=p>.</span><span class=mi>0373</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nf>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>):</span><span class=w> </span><span class=mi>16049</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>从中可以看出 customer_id 的选择性更高，所以应该选择 customer_id 作为第一列。</p><h2 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h2><h3 id=索引设计准则三星索引>索引设计准则：三星索引<a hidden class=anchor aria-hidden=true href=#索引设计准则三星索引>#</a></h3><p>上文我们得出了一个索引列顺序的经验 法则：将选择性最高的列放在索引的最前列，这种建立在某些场景可能有用，但通常不如避免随机 IO 和 排序那么重要，这里引入索引设计中非常著名的一个准则：三星索引。</p><p>如果一个查询满足三星索引中三颗星的所有索引条件，<strong>理论上</strong>可以认为我们设计的索引是最好的索引。什么是三星索引</p><ol><li>第一颗星：WHERE 后面参与查询的列可以组成了单列索引或联合索引</li><li>第二颗星：避免排序，即如果 SQL 语句中出现 order by colulmn，那么取出的结果集就已经是按照 column 排序好的，不需要再生成临时表</li><li>第三颗星：SELECT 对应的列应该尽量是索引列，即尽量避免回表查询。</li></ol><p>所以对于如下语句:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>age</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>city</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>xxx</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>xxx</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>age</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>设计的索引应该是 (age, name,city) 或者 (name, age,city)</p><p>当然 了三星索引是一个比较理想化的标准，实际操作往往只能满足期望中的一颗或两颗星，考虑如下语句:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>age</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>city</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>20</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>city</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>xxx</span><span class=w> </span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>desc</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>假设我们分别为这三列建了联合索引，则显然它符合第三颗星（使用了覆盖索引），如果索引是（city, age, name)，则虽然满足了第一颗星，但排序无法用到索引，不满足第二颗星，如果索引是 (city, name, age)，则第二颗星满足了，但此时 age 在 WHERE 中的搜索条件又无法满足第一星，</p><p>另外第三颗星（尽量使用覆盖索引）也无法完全满足，试想我要 SELECT 多列，要把这多列都设置为联合索引吗，这对索引的维护是个问题，因为每一次表的 CURD 都伴随着索引的更新，很可能频繁伴随着页分裂与页合并。</p><p>综上所述，三星索引只是给我们构建索引提供了一个参考，索引设计应该尽量靠近三星索引的标准，但实际场景我们一般无法同时满足三星索引，一般我们会优先选择满足第三颗星（因为回表代价较大）至于第一，二颗星就要依赖于实际的成本及实际的业务场景考虑。</p><h3 id=为什么要一定要设置主键><strong>为什么要一定要设置主键?</strong><a hidden class=anchor aria-hidden=true href=#为什么要一定要设置主键>#</a></h3><p>from: <a href=https://zhuanlan.zhihu.com/p/116866170>https://zhuanlan.zhihu.com/p/116866170</a></p><blockquote><p>其实这个不是一定的，有些场景下，小系统或者没什么用的表，不设置主键也没关系，mysql最好是用自增主键，主要是以下两个原因：果定义了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则innodb 会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则innodb 会选择内置6字节长的ROWID作为隐含的聚集索引。所以，反正都要生成一个主键，那你还不如自己指定一个主键，提高查询效率！</p></blockquote><blockquote><p>前面我写了几篇关于 mysql 索引的文章，索引是 mysql 非常重要的一部分。你也可能经常会看到一些关于 mysql 军规、mysql 查询优化的文章，其实这些操作的背后都是基于一定的原理的，你要想明白这些原理，首先就得知道 mysql 底层的一些东西。</p><p>我在这里举几个例子吧。</p><p>我们都知道表的主键一般都要使用自增 id，不建议使用业务 id ，是因为使用自增 id 可以避免页分裂。这个其实可以相当于一个结论，你都可以直接记住这个结论就可以了。</p><p>但是如果你要弄明白什么是页分裂，或者什么情况下会页分裂，这个时候你就需要对 mysql 的底层数据结构要有一定的理解了。</p><p>我这里也稍微解释一下页分裂，mysql （注意本文讲的 mysql 默认为InnoDB 引擎）底层数据结构是 B+ 树，<strong>所谓的索引其实就是一颗 B+ 树，一个表有多少个索引就会有多少颗 B+ 树，mysql 中的数据都是按顺序保存在 B+ 树上的</strong>（所以说索引本身是有序的）。</p><p>然后 mysql 在底层又是以数据页为单位来存储数据的，一个数据页大小默认为 16k，当然你也可以自定义大小，也就是说如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。</p><p>如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。</p><p>如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。</p><p>当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上。</p><p>这就造成了页分裂，这个大量移动数据的过程是会严重影响插入效率的。</p><p>其实对主键 id 还有一个小小的要求，在满足业务需求的情况下，尽量使用占空间更小的主键 id，因为普通索引的叶子节点上保存的是主键 id 的值，如果主键 id 占空间较大的话，那将会成倍增加 mysql 空间占用大小。</p></blockquote><h3 id=主键是用自增还是uuid><strong>主键是用自增还是UUID</strong><a hidden class=anchor aria-hidden=true href=#主键是用自增还是uuid>#</a></h3><blockquote><p>最好是用自增主键，主要是以下两个原因：</p><p>　　1. 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。
　　2. 如果使用非自增主键（如uuid），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到索引页的随机某个位置，此时MySQL为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成索引碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>不过，也不是所有的场景下都得使用自增主键，可能场景下，主键必须自己生成，不在乎那些性能的开销。那也没有问题。</p></blockquote><h3 id=自增主键用完了怎么办><strong>自增主键用完了怎么办?</strong><a hidden class=anchor aria-hidden=true href=#自增主键用完了怎么办>#</a></h3><blockquote><p>在mysql中，Int整型的范围（-2147483648~2147483648），约20亿！因此不用考虑自增ID达到最大值这个问题。而且数据达到千万级的时候就应该考虑分库分表了。</p></blockquote><h3 id=主键为什么不推荐有业务含义><strong>主键为什么不推荐有业务含义?</strong><a hidden class=anchor aria-hidden=true href=#主键为什么不推荐有业务含义>#</a></h3><blockquote><p>最好是主键是无意义的自增ID，然后另外创建一个业务主键ID，</p><p>因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。主键一旦发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。</p><p>还有就是，带有业务含义的主键，不一定是顺序自增的。那么就会导致数据的插入顺序，并不能保证后面插入数据的主键一定比前面的数据大。如果出现了，后面插入数据的主键比前面的小，就有可能引发页分裂，产生空间碎片。</p></blockquote><h3 id=货币字段用什么类型><strong>货币字段用什么类型</strong><a hidden class=anchor aria-hidden=true href=#货币字段用什么类型>#</a></h3><blockquote><p>货币字段一般都用 Decimal类型，
float和double是以二进制存储的，数据大的时候，可能存在误差。</p><p>以下是FLOAT和DOUBLE的区别：</p><p>浮点数以8位精度存储在FLOAT中，并且有四个字节。</p><p>浮点数存储在DOUBLE中，精度为18位，有八个字节。</p></blockquote><h3 id=表中有大字段x例如text类型且字段x不会经常更新以读为主那么是拆成子表好还是放一起好><strong>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为主，那么是拆成子表好？还是放一起好？</strong><a hidden class=anchor aria-hidden=true href=#表中有大字段x例如text类型且字段x不会经常更新以读为主那么是拆成子表好还是放一起好>#</a></h3><blockquote><p>其实各有利弊，拆开带来的问题：连接消耗；不拆可能带来的问题：查询性能，所以要看你的实际情况，如果表数据量比较大，最好还是拆开为好。这样查询速度更快。</p></blockquote><h3 id=字段为什么要定义为not-null><strong>字段为什么要定义为NOT NULL?</strong><a hidden class=anchor aria-hidden=true href=#字段为什么要定义为not-null>#</a></h3><blockquote><p>一般情况，都会设置一个默认值，不会出现字段里面有null，又有空的情况。主要有以下几个原因：</p><ol><li><p>索引性能不好，Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。</p></li><li><p>如果某列存在null的情况，可能导致count() 等函数执行不对的情况。</p></li><li><p>sql 语句写着也麻烦，既要判断是否为空，又要判断是否为null等。</p></li></ol></blockquote><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>本文简述了索引的基本原理，索引的几种类型，以及分析了一下设计索引尽量应该遵循的一些准则，相信我们对索引的理解又更深了一步。另外强烈建议大家去学习一下附录中的几本书。文中的挺多例子都是在文末的参考资料中总结出来的，读经典书籍，相信大家会受益匪浅！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/mysql/>MySql</a></li><li><a href=https://reid00.github.io/en/tags/%E7%B4%A2%E5%BC%95/>索引</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/langs_linux/python-import%E5%AF%BC%E5%85%A5%E4%B8%8A%E7%BA%A7%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/><span class=title>« Prev</span><br><span>Python Import导入上级目录文件</span>
</a><a class=next href=https://reid00.github.io/en/posts/storage/mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/><span class=title>Next »</span><br><span>MySql索引优化</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>