<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>存储, 分布式相关的文章 | Reid's Blog</title>
<meta name=keywords content><meta name=description content="存储, 分布式相关的文章 - Reid's Blog"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/storage/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://reid00.github.io/en/posts/storage/index.xml><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/storage/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="存储, 分布式相关的文章"><meta property="og:description" content="Reid's Personal Notes -- https://github.com/Reid00"><meta property="og:type" content="website"><meta property="og:url" content="https://reid00.github.io/en/posts/storage/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="存储, 分布式相关的文章"><meta name=twitter:description content="Reid's Personal Notes -- https://github.com/Reid00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"存储, 分布式相关的文章","item":"https://reid00.github.io/en/posts/storage/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a></div><h1>存储, 分布式相关的文章
<a href=/en/posts/storage/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySql事务</h2></header><div class=entry-content><p>『浅入深出』MySQL 中事务的实现 https://draveness.me/mysql-transaction/
MySQL 中如何实现事务隔离 https://www.cnblogs.com/fengzheng/p/12557762.html
详解一条 SQL 的执行过程
https://juejin.cn/post/6931606328129355790
首先说读未提交，它是性能最好，也可以说它是最野蛮的方式，因为它压根儿就不加锁，所以根本谈不上什么隔离效果，可以理解为没有隔离。
...</p></div><footer class=entry-footer><span title='2023-03-16 19:35:05 +0800 +0800'>2023-03-16 19:35</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2136 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to MySql事务" href=https://reid00.github.io/en/posts/storage/mysql%E4%BA%8B%E5%8A%A1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySql语句优化</h2></header><div class=entry-content><p>一，SQL语句性能优化 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
应尽量避免在 where 子句中对字段进行 null 值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默 认值。
...</p></div><footer class=entry-footer><span title='2023-03-16 19:35:05 +0800 +0800'>2023-03-16 19:35</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;4345 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to MySql语句优化" href=https://reid00.github.io/en/posts/storage/mysql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LSM Tree</h2></header><div class=entry-content><p>简介LSM Tree MySQL、etcd 等存储系统都是面向读多写少场景的，其底层大都采用 B-Tree 及其变种数据结构。而 LSM-Tree 则解决了另一个应用场景——写多读少时面临的问题。在面对亿级的海量数据的存储和检索的场景下，我们通常选择强力的 NoSQL 数据库，如 Hbase、RocksDB 等，它们的文件组织方式，都是仿照 LSM-Tree 实现的。 reference
...</p></div><footer class=entry-footer><span title='2023-03-16 19:35:04 +0800 +0800'>2023-03-16 19:35</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;5705 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to LSM Tree" href=https://reid00.github.io/en/posts/storage/lsm-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ES面试题</h2></header><div class=entry-content><p>ElasticSearch面试题 1.为什么要使用Elasticsearch? 因为在我们商城中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。
...</p></div><footer class=entry-footer><span title='2023-03-16 19:35:02 +0800 +0800'>2023-03-16 19:35</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;7614 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to ES面试题" href=https://reid00.github.io/en/posts/storage/es%E9%9D%A2%E8%AF%95%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>20230214 MIT6.824 2022 Lab4 ShardedKV</h2></header><div class=entry-content><p>ShardedKV 介绍 有关 shardkv，其可以算是一个 multi-raft 的实现，只是缺少了物理节点的抽象概念。在实际的生产系统中，不同 raft 组的成员可能存在于一个物理节点上，而且一般情况下都是一个物理节点拥有一个状态机，不同 raft 组使用不同地命名空间或前缀来操作同一个状态机。基于此，下文所提到的的节点都代指 raft 组的某个成员，而不代指某个物理节点。比如节点宕机代指 raft 组的某个成员被 kill 掉，而不是指某个物理节点宕机，从而可能影响多个 raft 的成员。
...</p></div><footer class=entry-footer><span title='2023-03-16 19:34:58 +0800 +0800'>2023-03-16 19:34</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;11170 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to 20230214 MIT6.824 2022 Lab4 ShardedKV" href=https://reid00.github.io/en/posts/storage/20230214-mit6.824-2022-lab4-shardedkv/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MIT6.824 2022 Lab3 RaftKV</h2></header><div class=entry-content><p>介绍 在lab2的Raft函数库之上，搭建一个能够容错的key/value存储服务，需要提供强一致性保证。
强一致性介绍 对于单个请求，整个服务需要表现得像个单机服务，并且对状态机的修改基于之前所有的请求。对于并发的请求，返回的值和最终的状态必须相同，就好像所有请求都是串行的一样。即使有些请求发生在了同一时间，那么也应当一个一个响应。此外，在一个请求被执行之前，这之前的请求都必须已经被完成（在技术上我们也叫着线性化（linearizability））。 kv服务支持三种操作：Put, Append, Get。通过在内存维护一个简单的键/值对数据库，键和值都是字符串；
...</p></div><footer class=entry-footer><span title='2023-03-16 19:34:58 +0800 +0800'>2023-03-16 19:34</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;3850 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to MIT6.824 2022 Lab3 RaftKV" href=https://reid00.github.io/en/posts/storage/mit6.824-2022-lab3-raftkv/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Raft Etcd 之 Linearizable Read</h2></header><div class=entry-content><p>介绍 linearizable read 简单的说就是不返回 stale 数据，具体可以参考Strong consistency models
Read Index 机制就是 Leader 在收到读请求时进行如下几步：
如果 Leader 在当前任期还没有提交过日志，先提交一条空日志 Leader 保存记录当前 commit index 作为 readIndex 通过心跳，询问成员自己还是不是 Leader，如果收到过半的确认，则可确信自己仍是 Leader 等待 Apply Index 超过 readIndex 读取数据，响应 Client etcd不仅实现了leader上的read only query，同时也实现了follower上的read only query，原理是一样的，只不过读请求到达follower时，commit index是需要向leader去要的，leader返回commit index给follower之前，同样，需要走上面的ReadIndex流程，因为leader同样需要check自己到底还是不是leader
...</p></div><footer class=entry-footer><span title='2023-03-16 19:34:58 +0800 +0800'>2023-03-16 19:34</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;1100 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to Raft Etcd 之 Linearizable Read" href=https://reid00.github.io/en/posts/storage/raft-etcd-%E4%B9%8B-linearizable-read/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MIT6.824 2022 Raft 为什么Raft协议不能提交之前任期的日志</h2></header><div class=entry-content><p>如果允许提交之前任期的日志，将导致什么问题? 我们将论文中的上图展开:
(a): S1 是leader，将黄色的日志2同步到了S2，然后S1崩溃。 (b): S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，将蓝色日志3存储到本地，然后崩溃了。 (c): S1重新启动，选举成功。注意在这时，如果允许提交之前任期的日志，将首先开始同步过往任期的日志，即将S1上的本地黄色的日志2同步到了S3。这时黄色的节点2已经同步到了集群多数节点，然后S1写了一条新日志4，然后S1又崩溃了。 接下来会出现两种不同的情况: (d1): S5重新当选，如果允许提交之前任期的日志，就开始同步往期日志，将本地的蓝色日志3同步到所有的节点。结果已经被同步到半数以上节点的黄色日志2被覆盖了。这说明，如果允许“提交之前任期的日志”，会可能出现即便已经同步到半数以上节点的日志被覆盖，这是不允许的。 (d2): 反之，如果在崩溃之前，S1不去同步往期的日志，而是首先同步自己任期内的日志4到所有节点，就不会导致黄色日志2被覆盖。因为leader同步日志的流程中，会通过不断的向后重试的方式，将日志同步到其他所有follower，只要日志4被复制成功，在它之前的日志2就会被复制成功。（d2）是想说明：不能直接提交过往任期的日志，即便已经被多数通过，但是可以先同步一条自己任内的日志，如果这条日志通过，就能带着前面的日志一起通过，这是（c）和（d2）两个图的区别。图（c）中，S1先去提交过往任期的日志2，图（d2）中，S1先去提交自己任内的日志4。 假如 s1 提交的话，则 index 为 2，term 为 2 的 entry 就被应用到状态机中了，是不可改变了，此时 s1 如果挂了，来到 term5，s5 是可以被选为 leader 的，因为按照之前的 log 比对策略来说，s5 的最后一个 log 的 term 是 3 比 s2 s3 s4 的最后一个 log 的 term 都大。一旦 s5 被选举为 leader，即 d 场景，s5 会复制 index 为 2,term 为 3 的 entry 到上述机器上，这时候就会造成之前 s1 已经提交的 index 为 2 的位置被重新覆盖，因此违背了一致性。
...</p></div><footer class=entry-footer><span title='2023-03-16 19:34:57 +0800 +0800'>2023-03-16 19:34</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;2706 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to MIT6.824 2022 Raft 为什么Raft协议不能提交之前任期的日志" href=https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-%E4%B8%BA%E4%BB%80%E4%B9%88raft%E5%8D%8F%E8%AE%AE%E4%B8%8D%E8%83%BD%E6%8F%90%E4%BA%A4%E4%B9%8B%E5%89%8D%E4%BB%BB%E6%9C%9F%E7%9A%84%E6%97%A5%E5%BF%97/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multi Raft</h2></header><div class=entry-content><p>Mulit Raft Group 通过对 Raft 协议的描述我们知道：用户在对一组 Raft 系统进行更新操作时必须先经过 Leader，再由 Leader 同步给大多数 Follower。而在实际运用中，一组 Raft 的 Leader 往往存在单点的流量瓶颈，流量高便无法承载，同时每个节点都是全量数据，所以会受到节点的存储限制而导致容量瓶颈，无法扩展。
...</p></div><footer class=entry-footer><span title='2023-03-16 19:34:57 +0800 +0800'>2023-03-16 19:34</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;2467 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to Multi Raft" href=https://reid00.github.io/en/posts/storage/multi-raft/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MIT6.824 2022 Raft Lab2C Log Compaction</h2></header><div class=entry-content><p>介绍 对Raft Figure2 中需要持久化的字段进行保存。
完成persist()和readPersist()函数，编码方式参照注释 优化nextIndex[]回退方式，否则无法通过所有测试 提示:
...</p></div><footer class=entry-footer><span title='2023-03-16 19:34:56 +0800 +0800'>2023-03-16 19:34</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;1309 words&nbsp;·&nbsp;Reid</footer><a class=entry-link aria-label="post link to MIT6.824 2022 Raft Lab2C Log Compaction" href=https://reid00.github.io/en/posts/storage/mit6.824-2022-raft-lab2c-log-compaction/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://reid00.github.io/en/posts/storage/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://reid00.github.io/en/posts/storage/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>