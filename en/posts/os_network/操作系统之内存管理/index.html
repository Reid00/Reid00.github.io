<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>操作系统之内存管理 | Reid's Blog</title>
<meta name=keywords content="内存,Memory"><meta name=description content="操作系统之内存管理"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://reid00.github.io/en/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK")}</script><meta property="og:title" content="操作系统之内存管理"><meta property="og:description" content="操作系统之内存管理"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-13T15:32:55+08:00"><meta property="article:modified_time" content="2023-04-13T15:32:55+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="操作系统之内存管理"><meta name=twitter:description content="操作系统之内存管理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"操作系统，网络编程，架构相关的文章","item":"https://reid00.github.io/en/posts/os_network/"},{"@type":"ListItem","position":3,"name":"操作系统之内存管理","item":"https://reid00.github.io/en/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"操作系统之内存管理","name":"操作系统之内存管理","description":"操作系统之内存管理","keywords":["内存","Memory"],"articleBody":"什么是内存 最直观的，我们买手机，电脑，内存条，都会标明内存是多大，例如途中的8G，16G，128G都指的内存大小。 我们应该都听说过 RAM 存储器，它是一种半导体存储器件。RAM 是英文单词 Random Access Memory 的缩写，即“随机”的意思。所以 RAM 存储器也称为“随机存储器”。\n那么 RAM 存储器和内存有什么关系呢？内存就是许多 RAM 存储器的集合，就是将许多 RAM 存储器集成在一起的电路板。RAM 存储器的优点是存取速度快、读写方便，所以内存的速度当然也就快了。\n操作系统发展历史 稍微了解操作系统历史的人，都知道没有操作系统的裸机-\u003e一次只能运行一个程序的单道批处理系统-\u003e多道批处理系统-\u003e分时系统这个发展历程。\n裸机时代 主要是人工操作，程序员将对应用程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。\n人机矛盾：手工操作的慢速度和计算机的高速度之间形成了尖锐矛盾，手工操作方式已严重损害了系统资源的利用率（使资源利用率降为百分之几，甚至更低），不能容忍。唯一的解决办法：只有摆脱人的手工操作，实现作业的自动过渡。这样就出现了成批处理。\n单道批处理系统 特点是一次只能运行一个进程，只有运行完毕后才能将下一个进程加载到内存里面，所以进程的数据都是直接放在物理内存上的，因此CPU是直接操作内存的物理地址，这个时候不存在虚拟逻辑地址，因为一次只能运行一个程序。\n矛盾：每次主机内存中仅存放一道作业，每当它运行期间发出输入/输出（I/O）请求后，高速的CPU便处于等待低速的I/O完成状态，致使CPU空闲。\n多道批处理系统 到后来发展出了多道程序系统，它要求在计算机中存在着多个进程，处理器需要在多个进程间进行切换，当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。\n问题来了，这么多进程，内存不够用怎么办，各个进程同时运行时内存地址互相覆盖怎么办？\n这时候就出现问题了，链接器在链接一个可执行文件的时候，总是默认程序的起始地址为0x0，但物理内存上只有一个0x0的地址呀？也许你会说:”没关系，我们可以在程序装入内存的时候再次动态改变它的地址.”好吧我忍了。但如果我的物理内存大小只有1G,而现在某一个程序需要超过1G的空间怎么办呢？你还能用刚才那句话解释吗？\n操作系统的发展，包括后面的分时系统，其实都是在解决协调各个环节速度不匹配的矛盾。\nCPU比磁盘速度快太多 存储器层次之间的作用和关联为金字塔形状，CPU不可以直接操控磁盘，是通过操控内存来进行工作的，因为磁盘的速度远远小于CPU的速度，跟不上，需要中间的内存层进行缓冲。\n内存速度比硬盘速度快的原理: 内存的速度之所以比硬盘的速度快（不是快一点，而是快很多），是因为它们的存储原理和读取方式不一样。\n硬盘是机械结构，通过磁头的转动读取数据。一般情况下台式机的硬盘为每分钟 7200 转，而笔记本的硬盘为每分钟 5400 转。 而内存是没有机械结构的，内存是通过电存取数据的。\n内存通过电存取数据，本质上就是因为 RAM 存储器是通过电存储数据的。但也正因为它们是通过电存储数据的，所以一旦断电数据就都丢失了。因此内存只是供数据暂时逗留的空间，而硬盘是永久的，断电后数据也不会消失。\n小结：程序执行前需要先放到内存中才能被CPU处理，因此内存的主要作用就是缓和CPU与硬盘之间的速度矛盾。\n程序运行过程 在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢?\n方案: 给内存的存储单元编地址。 程序运行过程如下： 编译: 把高级语言翻译为机器语言；\n链接: 由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块；\n装入(装载): 由装入程序将装入模块装入内存运行； 三种链接方式 静态链接 在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件(装入模块)，即得到完整的逻辑地址，之后不再拆开。 装入时动态链接 运行前边装入边链接的链接方式。 运行时动态链接 运行时该目标模块时，才对它进行链接，用不到的模块不需要装入内存。其优点是便于修改和更新，便于实现对目标模块的共享。 可以看到运行时动态链接，不需要一次性将模块全部装入内存，可以等到运行时需要的时候再动态的连接进去，这样一来就就提供了内存不够用的问题的解决思路，还可以这样，用到了再链接进去\n三种装入方式 绝对装入 编译或汇编时得到绝对地址，即内存物理地址，直接存到对应的物理地址。 单道处理系统就是直接操作物理地址，因此绝对装入只适用于单道程序环境。\n静态重定位装入 又称可重定位装入，这里引入逻辑地址，装入时将逻辑地址重定位转化为物理地址，多道批处理系统的使用方式。 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。\n动态重定位装入 又称动态运行时装入，运行时将逻辑地址重定位转化为物理地址，这种方式需要一个重定位寄存器的支持，当然现代操作系统使用的都是这种。\n逻辑地址都是从0开始的，假设装入的起始物理地址为100，动态重定位装入如下图： 内存管理的职责 内存管理的概念，包含三部分:\n1 内存空间的分配和回收 2 内存空间的扩充 3 地址转化 4 存储保护 内存空间的分配和回收 - 连续内存管理方式 单一连续分配方式 固定分区分配 动态分区分配 单一连续分配方式 在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。\n优点:实现简单;无外部碎片;\n缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。 固定分区分配 将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。\n操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的 大小、起始地址、状态(是否已分配)，\n当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。\n优点: 实现简单，无外部碎片。\n缺点: 会产生内部碎片，内存利用率低。\n动态分区分配 动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。(eg:假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…)\n产生三个问题：\n系统要用什么样的数据结构记录内 存的使用情况? （常用的 空闲分区表和空闲分区链） 当很多个空闲分区都能满足需求时， 应该选择哪个分区进行分配? 如何进行分区的分配与回收操作? 动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。\n缺点：动态分区分配没有内部碎片，但是有外部碎片。\n内部碎片:分配给某进程的内存区域中，有些部分没有用上。 外部碎片:是指内存中的某些空闲分区由于太小而难以利用。\n如果内存中空闲空间的总和本来可以满足某进程的要求， 但由于进程需要的是一整块连续的内存空间，因此这些 “碎片”不能满足进程的需求。 可以通过紧凑(拼凑，Compaction)技术来解决外部碎片。 动态分区分配算法 首次适应算法: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区\n最佳适应算法：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区\n最坏适应算法：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用\n邻近适应算法：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。 内存空间的分配与回收 - 非连续分配管理方式 连续分配:为用户进程分配的必须是一个连续的内存空间。 非连续分配:为用户进程分配的可以是一些分散的内存空间。\n基本分页存储管理 基本分段存储管理 段页式存储管理 分页-什么是基本分页存储 将内存空间分为一个个大小相等的分区(比如:每个分区 4KB)，每个分区就是一个“页框”(页框=页帧=内存块=物理块=物理页面)。每个页框有一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。 将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，页号也是从0开始。\n操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。\n注: 进程的最后一个页面可能没有一个页框那么大。也就是第 16K-1 内存，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费。\n分页-页表 为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表，页表通常存在PCB(进程控制块)中。 分页-分页之后的地址转换 页号 = 逻辑地址 / 页面长度 (取除法的整数部分) 页内偏移量 = 逻辑地址 % 页面长度(取除法的余数部分)\n如何实现地址转换:\n计算出逻辑地址对应的 逻辑页号和逻辑页内偏移量 查页表， 找到对应页面在物理内存的位置 - 页框(内存块) 物理地址 = 物理内存块地址 + 业内偏移量 基本地址变换 基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。 通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F 和页表长度M。 进程未执行时，页表的始址 和 页表长度 放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。\n快表地址变换 快表，又称联想寄存器(TLB， translation lookaside buffer )，是一种访问速度比内存快很多的高速缓存(TLB不是内存!)，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。\n注：TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本 快表快多少？ 例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少? (1+100) * 0.9 + (1+100+100) * 0.1 = 111 us\n有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) * 0.9 + (100+100) * 0.1 = 110.9 us\n若未采用快表机制，则访问一个逻辑地址需要 100+100 = 200us 显然，引入快表机制后，访问一个逻辑地址的速度快多了。\n分页-两级页表 单级页表的问题： 问题一: 根据页号查询页表的方法:K 号页对应的页表项存放位置 = 页表始址 + K * 4 ，页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；\n问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。\n解决办法：把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表。 分页-多级页表 分段-什么是分段 进程的地址空间:按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言 中，程序员使用段名来编程)，每段从0开始编址。\n内存分配规则: 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。 分段-段表 分段-地址转换 分段 VS 分页 1.1 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。 1.2 段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。\n2.1 分段对用户是可见的，用户编程时需要显式地给出段名。 2.2 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。\n3.1 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 3.2 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。 4.1 分段比分页更容易实现信息的共享和保护。 不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的(比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致) 分段小结 段页式 分页管理 优点: 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 缺点: 不方便按照逻辑模块实现信息的共享和保护\n分段管理 优点: 很方便按照逻辑模块实现信息的共享和保护 缺点： 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片\n段页式-什么是段页式 每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始 地址)组成。 每个段表项长度相等，段号是隐含的。 内存每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。\n段表式页表 段页式地址转换 段页式小结 内存空间的扩充 很多游戏的大小超过 60GB，按理来说这个游戏程序运行之前需要把 60GB 数据全部放入内存。然而，实际我的电脑内存才 8GB，我还要开着微信浏览器等别的进程，但为什么这个游戏可以顺利运行呢?\n利用虚拟技术(操作系统的虚拟性) 时间局部性: 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环);\n空间局部性: 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。 (因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)\n这个程序执行时，会频繁访问10号 和23号页面\n1 2 3 4 5 6 7 int i = 0; int a[100]; while (i \u003c 100) { a[i] = i; i ++ ; } 虚拟内存大小是多少?\n虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的，虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)\n如:某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。\n则虚拟内存的最大容量为 2^32 B = 4GB;\n虚拟内存的实际容量 = min (2^32 B, 512MB+2GB) = 2GB+512MB;\n虚拟内存的实现 请求分页管理 请求分页存储管理与基本分页存储管理的主要区别: 请求调页：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。\n页面置换：若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。\n请求分页-缺页中断 缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 一条指令在执行期间，可能产生多次缺页中断。(如:copy A to B，即将逻辑地址A中的数据复制到 逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)\n只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。\n和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。\n需要用某种“页面置换算法”来决定一个换出页面(下节内容)\n换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/ 换出太频繁，会有很大的开销。\n页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中\n小结: 请求分页-页面置换 页面的换入、换出需要磁盘 I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率\n最佳置换算法(OPT) 先进先出置换算法(FIFO) 最近最久未使用置换算法(LRU) 时钟置换算法(CLOCK) 改进型的时钟置换算法 内存管理的职责-地址转换 为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换(这个过程称为地址重定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。\n具体的地址转化方式如上。\n内存管理的职责-存储保护 ","wordCount":"6764","inLanguage":"en","image":"https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png","datePublished":"2023-04-13T15:32:55+08:00","dateModified":"2023-04-13T15:32:55+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/os_network/>操作系统，网络编程，架构相关的文章</a></div><h1 class="post-title entry-hint-parent">操作系统之内存管理</h1><div class=post-description>操作系统之内存管理</div><div class=post-meta><span title='2023-04-13 15:32:55 +0800 +0800'>2023-04-13 15:32</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;6764 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98 aria-label=什么是内存>什么是内存</a></li><li><a href=#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%8f%91%e5%b1%95%e5%8e%86%e5%8f%b2 aria-label=操作系统发展历史>操作系统发展历史</a><ul><li><a href=#%e8%a3%b8%e6%9c%ba%e6%97%b6%e4%bb%a3 aria-label=裸机时代>裸机时代</a></li><li><a href=#%e5%8d%95%e9%81%93%e6%89%b9%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f aria-label=单道批处理系统>单道批处理系统</a></li><li><a href=#%e5%a4%9a%e9%81%93%e6%89%b9%e5%a4%84%e7%90%86%e7%b3%bb%e7%bb%9f aria-label=多道批处理系统>多道批处理系统</a></li><li><a href=#cpu%e6%af%94%e7%a3%81%e7%9b%98%e9%80%9f%e5%ba%a6%e5%bf%ab%e5%a4%aa%e5%a4%9a aria-label=CPU比磁盘速度快太多>CPU比磁盘速度快太多</a></li></ul></li><li><a href=#%e7%a8%8b%e5%ba%8f%e8%bf%90%e8%a1%8c%e8%bf%87%e7%a8%8b aria-label=程序运行过程>程序运行过程</a><ul><li><a href=#%e7%a8%8b%e5%ba%8f%e8%bf%90%e8%a1%8c%e8%bf%87%e7%a8%8b%e5%a6%82%e4%b8%8b aria-label=程序运行过程如下：>程序运行过程如下：</a></li><li><a href=#%e4%b8%89%e7%a7%8d%e9%93%be%e6%8e%a5%e6%96%b9%e5%bc%8f aria-label=三种链接方式>三种链接方式</a></li><li><a href=#%e4%b8%89%e7%a7%8d%e8%a3%85%e5%85%a5%e6%96%b9%e5%bc%8f aria-label=三种装入方式>三种装入方式</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%9a%84%e8%81%8c%e8%b4%a3 aria-label=内存管理的职责>内存管理的职责</a><ul><li><a href=#1-%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%9e%e6%94%b6 aria-label="1 内存空间的分配和回收">1 内存空间的分配和回收</a></li><li><a href=#2-%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%9a%84%e6%89%a9%e5%85%85 aria-label="2 内存空间的扩充">2 内存空间的扩充</a></li><li><a href=#3-%e5%9c%b0%e5%9d%80%e8%bd%ac%e5%8c%96 aria-label="3 地址转化">3 地址转化</a></li><li><a href=#4-%e5%ad%98%e5%82%a8%e4%bf%9d%e6%8a%a4 aria-label="4 存储保护">4 存储保护</a></li><li><a href=#%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%9a%84%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%9e%e6%94%b6---%e8%bf%9e%e7%bb%ad%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label="内存空间的分配和回收 - 连续内存管理方式">内存空间的分配和回收 - 连续内存管理方式</a><ul><li><a href=#%e5%8d%95%e4%b8%80%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d%e6%96%b9%e5%bc%8f aria-label=单一连续分配方式>单一连续分配方式</a></li><li><a href=#%e5%9b%ba%e5%ae%9a%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d aria-label=固定分区分配>固定分区分配</a></li><li><a href=#%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d aria-label=动态分区分配>动态分区分配</a></li><li><a href=#%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e5%88%86%e9%85%8d%e7%ae%97%e6%b3%95 aria-label=动态分区分配算法>动态分区分配算法</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%9a%84%e5%88%86%e9%85%8d%e4%b8%8e%e5%9b%9e%e6%94%b6---%e9%9d%9e%e8%bf%9e%e7%bb%ad%e5%88%86%e9%85%8d%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f aria-label="内存空间的分配与回收 - 非连续分配管理方式">内存空间的分配与回收 - 非连续分配管理方式</a><ul><li><a href=#%e5%88%86%e9%a1%b5-%e4%bb%80%e4%b9%88%e6%98%af%e5%9f%ba%e6%9c%ac%e5%88%86%e9%a1%b5%e5%ad%98%e5%82%a8 aria-label=分页-什么是基本分页存储>分页-什么是基本分页存储</a></li><li><a href=#%e5%88%86%e9%a1%b5-%e9%a1%b5%e8%a1%a8 aria-label=分页-页表>分页-页表</a></li><li><a href=#%e5%88%86%e9%a1%b5-%e5%88%86%e9%a1%b5%e4%b9%8b%e5%90%8e%e7%9a%84%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2 aria-label=分页-分页之后的地址转换>分页-分页之后的地址转换</a></li><li><a href=#%e5%9f%ba%e6%9c%ac%e5%9c%b0%e5%9d%80%e5%8f%98%e6%8d%a2 aria-label=基本地址变换>基本地址变换</a></li><li><a href=#%e5%bf%ab%e8%a1%a8%e5%9c%b0%e5%9d%80%e5%8f%98%e6%8d%a2 aria-label=快表地址变换>快表地址变换</a></li><li><a href=#%e5%88%86%e9%a1%b5-%e4%b8%a4%e7%ba%a7%e9%a1%b5%e8%a1%a8 aria-label=分页-两级页表>分页-两级页表</a></li><li><a href=#%e5%88%86%e9%a1%b5-%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8 aria-label=分页-多级页表>分页-多级页表</a></li><li><a href=#%e5%88%86%e6%ae%b5-%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e6%ae%b5 aria-label=分段-什么是分段>分段-什么是分段</a></li><li><a href=#%e5%88%86%e6%ae%b5-%e6%ae%b5%e8%a1%a8 aria-label=分段-段表>分段-段表</a></li><li><a href=#%e5%88%86%e6%ae%b5-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2 aria-label=分段-地址转换>分段-地址转换</a></li><li><a href=#%e5%88%86%e6%ae%b5-vs-%e5%88%86%e9%a1%b5 aria-label="分段 VS 分页">分段 VS 分页</a></li><li><a href=#%e5%88%86%e6%ae%b5%e5%b0%8f%e7%bb%93 aria-label=分段小结>分段小结</a></li><li><a href=#%e6%ae%b5%e9%a1%b5%e5%bc%8f aria-label=段页式>段页式</a></li><li><a href=#%e6%ae%b5%e9%a1%b5%e5%bc%8f-%e4%bb%80%e4%b9%88%e6%98%af%e6%ae%b5%e9%a1%b5%e5%bc%8f aria-label=段页式-什么是段页式>段页式-什么是段页式</a></li><li><a href=#%e6%ae%b5%e8%a1%a8%e5%bc%8f%e9%a1%b5%e8%a1%a8 aria-label=段表式页表>段表式页表</a></li><li><a href=#%e6%ae%b5%e9%a1%b5%e5%bc%8f%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2 aria-label=段页式地址转换>段页式地址转换</a></li><li><a href=#%e6%ae%b5%e9%a1%b5%e5%bc%8f%e5%b0%8f%e7%bb%93 aria-label=段页式小结>段页式小结</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e7%9a%84%e6%89%a9%e5%85%85 aria-label=内存空间的扩充>内存空间的扩充</a><ul><li><a href=#%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label=虚拟内存的实现>虚拟内存的实现</a></li><li><a href=#%e8%af%b7%e6%b1%82%e5%88%86%e9%a1%b5%e7%ae%a1%e7%90%86 aria-label=请求分页管理>请求分页管理</a></li><li><a href=#%e8%af%b7%e6%b1%82%e5%88%86%e9%a1%b5-%e7%bc%ba%e9%a1%b5%e4%b8%ad%e6%96%ad aria-label=请求分页-缺页中断>请求分页-缺页中断</a></li><li><a href=#%e8%af%b7%e6%b1%82%e5%88%86%e9%a1%b5-%e9%a1%b5%e9%9d%a2%e7%bd%ae%e6%8d%a2 aria-label=请求分页-页面置换>请求分页-页面置换</a></li></ul></li><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%9a%84%e8%81%8c%e8%b4%a3-%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2 aria-label=内存管理的职责-地址转换>内存管理的职责-地址转换</a></li><li><a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%9a%84%e8%81%8c%e8%b4%a3-%e5%ad%98%e5%82%a8%e4%bf%9d%e6%8a%a4 aria-label=内存管理的职责-存储保护>内存管理的职责-存储保护</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=什么是内存>什么是内存<a hidden class=anchor aria-hidden=true href=#什么是内存>#</a></h1><p>最直观的，我们买手机，电脑，内存条，都会标明内存是多大，例如途中的8G，16G，128G都指的内存大小。
我们应该都听说过 RAM 存储器，它是一种半导体存储器件。RAM 是英文单词 Random Access Memory 的缩写，即“随机”的意思。所以 RAM 存储器也称为“随机存储器”。</p><p>那么 RAM 存储器和内存有什么关系呢？内存就是许多 RAM 存储器的集合，就是将许多 RAM 存储器集成在一起的电路板。RAM 存储器的优点是存取速度快、读写方便，所以内存的速度当然也就快了。</p><h1 id=操作系统发展历史>操作系统发展历史<a hidden class=anchor aria-hidden=true href=#操作系统发展历史>#</a></h1><p>稍微了解操作系统历史的人，都知道没有操作系统的裸机->一次只能运行一个程序的单道批处理系统->多道批处理系统->分时系统这个发展历程。</p><h2 id=裸机时代>裸机时代<a hidden class=anchor aria-hidden=true href=#裸机时代>#</a></h2><p>主要是人工操作，程序员将对应用程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。</p><p>人机矛盾：手工操作的慢速度和计算机的高速度之间形成了尖锐矛盾，手工操作方式已严重损害了系统资源的利用率（使资源利用率降为百分之几，甚至更低），不能容忍。唯一的解决办法：只有摆脱人的手工操作，实现作业的自动过渡。这样就出现了成批处理。</p><h2 id=单道批处理系统>单道批处理系统<a hidden class=anchor aria-hidden=true href=#单道批处理系统>#</a></h2><p>特点是一次只能运行一个进程，只有运行完毕后才能将下一个进程加载到内存里面，所以进程的数据都是直接放在物理内存上的，因此CPU是直接操作内存的物理地址，这个时候不存在虚拟逻辑地址，因为一次只能运行一个程序。</p><p>矛盾：每次主机内存中仅存放一道作业，每当它运行期间发出输入/输出（I/O）请求后，高速的CPU便处于等待低速的I/O完成状态，致使CPU空闲。</p><h2 id=多道批处理系统>多道批处理系统<a hidden class=anchor aria-hidden=true href=#多道批处理系统>#</a></h2><p>到后来发展出了多道程序系统，它要求在计算机中存在着多个进程，处理器需要在多个进程间进行切换，当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p><p>问题来了，这么多进程，内存不够用怎么办，各个进程同时运行时内存地址互相覆盖怎么办？</p><p>这时候就出现问题了，链接器在链接一个可执行文件的时候，总是默认程序的起始地址为0x0，但物理内存上只有一个0x0的地址呀？也许你会说:”没关系，我们可以在程序装入内存的时候再次动态改变它的地址.”好吧我忍了。但如果我的物理内存大小只有1G,而现在某一个程序需要超过1G的空间怎么办呢？你还能用刚才那句话解释吗？</p><p>操作系统的发展，包括后面的分时系统，其实都是在解决协调各个环节速度不匹配的矛盾。</p><h2 id=cpu比磁盘速度快太多>CPU比磁盘速度快太多<a hidden class=anchor aria-hidden=true href=#cpu比磁盘速度快太多>#</a></h2><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.zfps6qpuo4g.webp alt=mem></p><p>存储器层次之间的作用和关联为金字塔形状，CPU不可以直接操控磁盘，是通过操控内存来进行工作的，因为磁盘的速度远远小于CPU的速度，跟不上，需要中间的内存层进行缓冲。</p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.mxu12ib6ygg.webp alt=mem></p><p><strong>内存速度比硬盘速度快的原理:</strong>
内存的速度之所以比硬盘的速度快（不是快一点，而是快很多），是因为它们的存储原理和读取方式不一样。</p><p>硬盘是机械结构，通过磁头的转动读取数据。一般情况下台式机的硬盘为每分钟 7200 转，而笔记本的硬盘为每分钟 5400 转。
而内存是没有机械结构的，内存是通过电存取数据的。</p><p>内存通过电存取数据，本质上就是因为 RAM 存储器是通过电存储数据的。但也正因为它们是通过电存储数据的，所以一旦断电数据就都丢失了。因此内存只是供数据暂时逗留的空间，而硬盘是永久的，断电后数据也不会消失。</p><p>小结：程序执行前需要先放到内存中才能被CPU处理，<strong>因此内存的主要作用就是缓和CPU与硬盘之间的速度矛盾</strong>。</p><h1 id=程序运行过程>程序运行过程<a hidden class=anchor aria-hidden=true href=#程序运行过程>#</a></h1><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢?</p><p>方案: 给内存的存储单元编地址。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.3t6oblgcvfs0.webp alt=addr></p><h2 id=程序运行过程如下>程序运行过程如下：<a hidden class=anchor aria-hidden=true href=#程序运行过程如下>#</a></h2><p>编译: 把高级语言翻译为机器语言；</p><p>链接: 由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块；</p><p>装入(装载): 由装入程序将装入模块装入内存运行；
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.24522ixby6xs.webp alt=process></p><h2 id=三种链接方式>三种链接方式<a hidden class=anchor aria-hidden=true href=#三种链接方式>#</a></h2><ol><li><code>静态链接</code> 在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件(装入模块)，即得到完整的逻辑地址，之后不再拆开。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.1zb2kszlwoe8.webp alt=static></li><li><code>装入时动态链接</code> 运行前边装入边链接的链接方式。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.b20ag2h667s.webp alt=inserting></li><li><code>运行时动态链接</code> 运行时该目标模块时，才对它进行链接，用不到的模块不需要装入内存。其优点是便于修改和更新，便于实现对目标模块的共享。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4pfyk9h8gpe0.webp alt=running></li></ol><p>可以看到运行时动态链接，不需要一次性将模块全部装入内存，可以等到运行时需要的时候再动态的连接进去，这样一来就就提供了内存不够用的问题的解决思路，还可以这样，用到了再链接进去</p><h2 id=三种装入方式>三种装入方式<a hidden class=anchor aria-hidden=true href=#三种装入方式>#</a></h2><ol><li><p>绝对装入
编译或汇编时得到绝对地址，即内存物理地址，直接存到对应的物理地址。
单道处理系统就是直接操作物理地址，因此绝对装入只适用于单道程序环境。</p></li><li><p>静态重定位装入
又称<code>可重定位装入</code>，这里引入逻辑地址，装入时将逻辑地址重定位转化为物理地址，多道批处理系统的使用方式。
静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p></li><li><p>动态重定位装入
又称<code>动态运行时装入</code>，运行时将逻辑地址重定位转化为物理地址，这种方式需要一个重定位寄存器的支持，<strong>当然现代操作系统使用的都是这种</strong>。</p></li></ol><p>逻辑地址都是从0开始的，假设装入的起始物理地址为100，动态重定位装入如下图：
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.5zrub17ge3o0.webp alt=动态重定位装入>
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.7hf44tabpe80.webp alt=动态重定位装入></p><h1 id=内存管理的职责>内存管理的职责<a hidden class=anchor aria-hidden=true href=#内存管理的职责>#</a></h1><p>内存管理的概念，包含三部分:</p><h2 id=1-内存空间的分配和回收>1 内存空间的分配和回收<a hidden class=anchor aria-hidden=true href=#1-内存空间的分配和回收>#</a></h2><h2 id=2-内存空间的扩充>2 内存空间的扩充<a hidden class=anchor aria-hidden=true href=#2-内存空间的扩充>#</a></h2><h2 id=3-地址转化>3 地址转化<a hidden class=anchor aria-hidden=true href=#3-地址转化>#</a></h2><h2 id=4-存储保护>4 存储保护<a hidden class=anchor aria-hidden=true href=#4-存储保护>#</a></h2><h2 id=内存空间的分配和回收---连续内存管理方式>内存空间的分配和回收 - 连续内存管理方式<a hidden class=anchor aria-hidden=true href=#内存空间的分配和回收---连续内存管理方式>#</a></h2><ol><li>单一连续分配方式</li><li>固定分区分配</li><li>动态分区分配</li></ol><h3 id=单一连续分配方式>单一连续分配方式<a hidden class=anchor aria-hidden=true href=#单一连续分配方式>#</a></h3><p>在单一连续分配方式中，内存被分为系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。内存中<code>只能有一道用户程序</code>，用户程序独占整个用户区空间。</p><p>优点:实现简单;无外部碎片;</p><p>缺点:只能用于单用户、单任务的操作系统中;有内部碎片;存储器利用率极低。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.1tk02cd0v6ww.webp alt=连续分配方式></p><h3 id=固定分区分配>固定分区分配<a hidden class=anchor aria-hidden=true href=#固定分区分配>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.1215pgk2hf7k.webp alt=固定分区分配>
将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的 大小、起始地址、状态(是否已分配)，</p><p>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p><p>优点: 实现简单，无外部碎片。</p><p>缺点: 会产生内部碎片，内存利用率低。</p><h3 id=动态分区分配>动态分区分配<a hidden class=anchor aria-hidden=true href=#动态分区分配>#</a></h3><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时， 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数 目是可变的。(eg:假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB&mldr;)</p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4gia0io7bpg0.webp alt=动态分区分配></p><p>产生三个问题：</p><ol><li>系统要用什么样的数据结构记录内 存的使用情况? （常用的 空闲分区表和空闲分区链）</li><li>当很多个空闲分区都能满足需求时， 应该选择哪个分区进行分配?</li><li>如何进行分区的分配与回收操作?</li></ol><p>动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p><p>缺点：动态分区分配没有内部碎片，但是有外部碎片。</p><p><code>内部碎片</code>:分配给某进程的内存区域中，有些部分没有用上。
<code>外部碎片</code>:是指内存中的某些空闲分区由于太小而难以利用。</p><p>如果内存中空闲空间的总和本来可以满足某进程的要求， 但由于进程需要的是一整块连续的内存空间，因此这些 “碎片”不能满足进程的需求。 可以通过紧凑(拼凑，Compaction)技术来解决外部碎片。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.3a7fmbiye9y0.webp alt=总结></p><h3 id=动态分区分配算法>动态分区分配算法<a hidden class=anchor aria-hidden=true href=#动态分区分配算法>#</a></h3><ol><li><p>首次适应算法: 每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p></li><li><p>最佳适应算法：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区</p></li><li><p>最坏适应算法：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时 优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</p></li><li><p>邻近适应算法：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.18tjnv5de43k.webp alt=优缺点></p></li></ol><h2 id=内存空间的分配与回收---非连续分配管理方式>内存空间的分配与回收 - 非连续分配管理方式<a hidden class=anchor aria-hidden=true href=#内存空间的分配与回收---非连续分配管理方式>#</a></h2><p><code>连续分配</code>:为用户进程分配的必须是一个连续的内存空间。
<code>非连续分配</code>:为用户进程分配的可以是一些分散的内存空间。</p><ol><li>基本分页存储管理</li><li>基本分段存储管理</li><li>段页式存储管理</li></ol><h3 id=分页-什么是基本分页存储>分页-什么是基本分页存储<a hidden class=anchor aria-hidden=true href=#分页-什么是基本分页存储>#</a></h3><p>将<code>内存空间</code>分为一个个大小相等的分区(比如:每个分区 4KB)，每个分区就是一个“页框”(页框=页帧=内存块=物理块=物理页面)。每个页框有一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4avqk34lg2a0.webp alt=分页存储></p><p>将进程的<code>逻辑地址空间</code>也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，页号也是从0开始。</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。</p><p>注: 进程的最后一个页面可能没有一个页框那么大。也就是第 <code>16K-1 </code>内存，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费。</p><h3 id=分页-页表>分页-页表<a hidden class=anchor aria-hidden=true href=#分页-页表>#</a></h3><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表，页表通常存在PCB(进程控制块)中。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.zm7qek2xugg.webp alt=页表></p><h3 id=分页-分页之后的地址转换>分页-分页之后的地址转换<a hidden class=anchor aria-hidden=true href=#分页-分页之后的地址转换>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.6yfdphocb7c0.webp alt=地址翻译></p><p>页号 = 逻辑地址 / 页面长度 (取除法的整数部分)
页内偏移量 = 逻辑地址 % 页面长度(取除法的余数部分)</p><p>如何实现地址转换:</p><ol><li>计算出逻辑地址对应的 逻辑页号和逻辑页内偏移量</li><li>查页表， 找到对应页面在物理内存的位置 - 页框(内存块)</li><li>物理地址 = 物理内存块地址 + 业内偏移量</li></ol><h3 id=基本地址变换>基本地址变换<a hidden class=anchor aria-hidden=true href=#基本地址变换>#</a></h3><p>基本地址变换机构可以借助进程的<code>页表</code>将逻辑地址转换为物理地址。 通常会在系统中设置一个<code>页表寄存器(PTR)</code>，存放页表在内存中的起始地址F 和页表长度M。 进程未执行时，页表的始址 和 页表长度 放在<code>进程控制块(PCB)</code>中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4kwb9ivtf9y0.webp alt=地址转化></p><h3 id=快表地址变换>快表地址变换<a hidden class=anchor aria-hidden=true href=#快表地址变换>#</a></h3><p>快表，又称联想寄存器(TLB， translation lookaside buffer )，是一种访问速度比内存快很多的高速缓存(TLB不是内存!)，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p><p>注：TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4gtsqt93qza0.webp alt=快表></p><p>快表快多少？
例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少?
(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us</p><p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) * 0.9 + (100+100) * 0.1 = 110.9 us</p><p>若未采用快表机制，则访问一个逻辑地址需要 100+100 = 200us 显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p><h3 id=分页-两级页表>分页-两级页表<a hidden class=anchor aria-hidden=true href=#分页-两级页表>#</a></h3><p>单级页表的问题：
问题一: 根据页号查询页表的方法:K 号页对应的页表项存放位置 = 页表始址 + K * 4 ，页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框；</p><p>问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><p>解决办法：把页表再分页并离散存储，然后再建立一张页表记录页表各个部分的存放位置，称为页目录表，或称外层页表，或称顶层页表。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.3mitf7y33ic0.webp alt=issue1>
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.25x5o7n2d5kw.webp alt=issue2></p><h3 id=分页-多级页表>分页-多级页表<a hidden class=anchor aria-hidden=true href=#分页-多级页表>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.2a5vib9y2u3o.webp alt=多级页表></p><h3 id=分段-什么是分段>分段-什么是分段<a hidden class=anchor aria-hidden=true href=#分段-什么是分段>#</a></h3><p>进程的地址空间:按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言 中，程序员使用段名来编程)，每段从0开始编址。</p><p>内存分配规则: 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.w68y8ejoe7k.webp alt=分段></p><h3 id=分段-段表>分段-段表<a hidden class=anchor aria-hidden=true href=#分段-段表>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.bqbtyeli4ow.webp alt=分段-段表></p><h3 id=分段-地址转换>分段-地址转换<a hidden class=anchor aria-hidden=true href=#分段-地址转换>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4nhnn6rfo9e0.webp alt=分段-地址转换></p><h3 id=分段-vs-分页>分段 VS 分页<a hidden class=anchor aria-hidden=true href=#分段-vs-分页>#</a></h3><p>1.1 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。
1.2 段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。</p><p>2.1 分段对用户是可见的，用户编程时需要显式地给出段名。
2.2 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p>3.1 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。
3.2 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.2cszoy0gky68.webp alt=段页命名区别></p><p>4.1 分段比分页更容易实现信息的共享和保护。 不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的(比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.797q0rjqhv40.webp alt=分段优势></p><h3 id=分段小结>分段小结<a hidden class=anchor aria-hidden=true href=#分段小结>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.30u70aqoghu0.webp alt=分段小结></p><h3 id=段页式>段页式<a hidden class=anchor aria-hidden=true href=#段页式>#</a></h3><p>分页管理
优点:
内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片
缺点:
不方便按照逻辑模块实现信息的共享和保护</p><p>分段管理
优点:
很方便按照逻辑模块实现信息的共享和保护
缺点：
如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</p><h3 id=段页式-什么是段页式>段页式-什么是段页式<a hidden class=anchor aria-hidden=true href=#段页式-什么是段页式>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4m9qpf1ptfo0.webp alt=段页式></p><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始 地址)组成。
每个段表项长度相等，段号是隐含的。
内存每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。</p><h3 id=段表式页表>段表式页表<a hidden class=anchor aria-hidden=true href=#段表式页表>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.1rdmhaufu128.webp alt=段表式页表></p><h3 id=段页式地址转换>段页式地址转换<a hidden class=anchor aria-hidden=true href=#段页式地址转换>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.1t8of9nmwpls.webp alt=段页式地址转换></p><h3 id=段页式小结>段页式小结<a hidden class=anchor aria-hidden=true href=#段页式小结>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.1oklm3wx9ezk.webp alt=段页式小结></p><h2 id=内存空间的扩充>内存空间的扩充<a hidden class=anchor aria-hidden=true href=#内存空间的扩充>#</a></h2><p>很多游戏的大小超过 60GB，按理来说这个游戏程序运行之前需要把 60GB 数据全部放入内存。然而，实际我的电脑内存才 8GB，我还要开着微信浏览器等别的进程，但为什么这个游戏可以顺利运行呢?</p><p>利用虚拟技术(操作系统的虚拟性)
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.1zognod65duo.webp alt=虚拟内存></p><p>时间局部性: 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环);</p><p>空间局部性: 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p><p>这个程序执行时，会频繁访问10号 和23号页面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>100</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>++</span> <span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>虚拟内存大小是多少?</p><p>虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的，虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)</p><p>如:某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。</p><p>则虚拟内存的最大容量为 2^32 B = 4GB;</p><p>虚拟内存的实际容量 = min (2^32 B, 512MB+2GB) = 2GB+512MB;</p><h3 id=虚拟内存的实现>虚拟内存的实现<a hidden class=anchor aria-hidden=true href=#虚拟内存的实现>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.2hh2i3r6zq40.webp alt=虚拟内存的实现></p><h3 id=请求分页管理>请求分页管理<a hidden class=anchor aria-hidden=true href=#请求分页管理>#</a></h3><p><strong>请求分页存储管理与基本分页存储管理的主要区别:</strong>
请求调页：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p><p>页面置换：若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.2e7ekxjiw680.webp alt=调页></p><h3 id=请求分页-缺页中断>请求分页-缺页中断<a hidden class=anchor aria-hidden=true href=#请求分页-缺页中断>#</a></h3><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.6mlbru3g80o0.webp alt=缺页中断></p><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断 一条指令在执行期间，可能产生多次缺页中断。(如:copy A to B，即将逻辑地址A中的数据复制到 逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断)</p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4qx15papin00.webp alt=中断分类></p><ol><li><p>只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p></li><li><p>和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p></li><li><p>需要用某种“页面置换算法”来决定一个换出页面(下节内容)</p></li><li><p>换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/ 换出太频繁，会有很大的开销。</p></li><li><p>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中</p></li></ol><p>小结:
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.7l2reihvffg0.webp alt=缺页小结></p><h3 id=请求分页-页面置换>请求分页-页面置换<a hidden class=anchor aria-hidden=true href=#请求分页-页面置换>#</a></h3><p>页面的换入、换出需要磁盘 I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率</p><p>最佳置换算法(OPT)
先进先出置换算法(FIFO)
最近最久未使用置换算法(LRU)
时钟置换算法(CLOCK)
改进型的时钟置换算法
<img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.3bd6komzajs0.webp alt=页面置换></p><h2 id=内存管理的职责-地址转换>内存管理的职责-地址转换<a hidden class=anchor aria-hidden=true href=#内存管理的职责-地址转换>#</a></h2><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换(这个过程称为地址重定位)应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p><p>具体的地址转化方式如上。</p><h2 id=内存管理的职责-存储保护>内存管理的职责-存储保护<a hidden class=anchor aria-hidden=true href=#内存管理的职责-存储保护>#</a></h2><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.3sbnqnfmr680.webp alt=内存保护1></p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.4311pn7hww20.webp alt=内存保护2></p><p><img loading=lazy src=https://github.com/Reid00/image-host/raw/main/20230413/image.2tqhetfz7xa0.webp alt=内存></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/%E5%86%85%E5%AD%98/>内存</a></li><li><a href=https://reid00.github.io/en/tags/memory/>Memory</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/><span class=title>« Prev</span><br><span>操作系统之文件系统</span>
</a><a class=next href=https://reid00.github.io/en/posts/ml/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E4%B9%8Bxgboost/><span class=title>Next »</span><br><span>集成学习之xgboost</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>