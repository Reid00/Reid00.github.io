<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>For循环耗时从3.2秒降到0.3秒 | Reid's Blog</title>
<meta name=keywords content="CPU,循环,优化"><meta name=description content="For循环耗时从3.2秒降到0.3秒"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/en/posts/os_network/for%E5%BE%AA%E7%8E%AF%E8%80%97%E6%97%B6%E4%BB%8E3.2%E7%A7%92%E9%99%8D%E5%88%B00.3%E7%A7%92/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK",{anonymize_ip:!1})}</script><meta property="og:title" content="For循环耗时从3.2秒降到0.3秒"><meta property="og:description" content="For循环耗时从3.2秒降到0.3秒"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/en/posts/os_network/for%E5%BE%AA%E7%8E%AF%E8%80%97%E6%97%B6%E4%BB%8E3.2%E7%A7%92%E9%99%8D%E5%88%B00.3%E7%A7%92/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-26T10:09:28+08:00"><meta property="article:modified_time" content="2023-12-26T10:09:28+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="For循环耗时从3.2秒降到0.3秒"><meta name=twitter:description content="For循环耗时从3.2秒降到0.3秒"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/en/posts/"},{"@type":"ListItem","position":2,"name":"操作系统，网络编程，架构相关的文章","item":"https://reid00.github.io/en/posts/os_network/"},{"@type":"ListItem","position":3,"name":"For循环耗时从3.2秒降到0.3秒","item":"https://reid00.github.io/en/posts/os_network/for%E5%BE%AA%E7%8E%AF%E8%80%97%E6%97%B6%E4%BB%8E3.2%E7%A7%92%E9%99%8D%E5%88%B00.3%E7%A7%92/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"For循环耗时从3.2秒降到0.3秒","name":"For循环耗时从3.2秒降到0.3秒","description":"For循环耗时从3.2秒降到0.3秒","keywords":["CPU","循环","优化"],"articleBody":"一道面试题 1 2 3 4 5 6 7 8 9 int test(int n) { int fact = 1, num = n+1; for(int i =1; i\u003cnum; i++) { fact *= 1; } return fact; } 面试官：这段求阶乘的代码怎么样？ 答：挺简洁的，简单易懂。不过如果参数 n 值比较大的话，会导致 fact 溢出，结果是错的。 面试官：嗯，是的。不过，咱们先不考虑溢出的问题，你觉得这段代码的性能怎么样？ 答：时间复杂度是 O(n)，而且代码比较精炼，性能应该还挺不错的吧？(心虚 ing…) 面试官：你能想办法把它优化一下，让性能更好吗？ 思考 ing… 答：在多 CPU 系统上，如果 n 的值比较大的话，可以考虑用多线程来实现。 面试官：嗯，这是一个思路。如果是单 CPU 呢？ 再次思考 ing… 答：用 GCC 编译的话，可以加上优化选项-O3，应该能提高性能。 面试官：嗯，还有吗？ 答：没了。 面试官：好了，感谢来参加面试，回去等通知吧！ 思考一下，如果是你的话，会怎么回答呢？ 下面，来深入讲解一下，隐藏在这道题背后的深层次知识！ 本文较长，且涉及到 CPU 内部很底层的知识，请耐心看完，一定会有收获！\n测试程序 测试程序 test.c 非常简单，计算 1000000000 的阶乘：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 __attribute__((noinline)) int cacl(int n) { int fact = 1; for(int i =1; i\u003cn; i++) { fact *= 1; } return fact; } int main() { return cacl(1000000000); } 为方便分析，函数 calc()前面加上attribute((noinline))，禁止 GCC 把 calc 内联在 main()中。此外，calc()中，fact 类型是 int，main()中调用 calc(1000000000)，会导致 fact 溢出，但不影响测试，不用管它。\n然后，把程序稍微改一下，命名为 test_2.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __attribute__((noinline)) int cacl(int n) { int fact0=1, fact1=1, fact2=1, fact3=1; for(int i =1; i\u003cn; i += 4) { fact0 *= i; fact1 *= i+1; fact2 *= i+2; fact3 *= i+3; } return fact0 * fact1 * fact2 * fact3; } int main() { return cacl(1000000000); } 注意：这里为方便讲解，假设 n 总是 4 的倍数。如果要处理 n 不是 4 的倍数的情况，只需要在主循环体外，增加一个小的循环单独处理最后的 n%4 个数，也就是最多 3 个数即可，对整体性能影响几乎为 0.\n运行耗时从原来的 3.29 秒降到了 1 秒，性能提升了 200%！你以为这就完了？\n这还不是最终的结果，因为我们还有一个优化技巧还没加上，最终优化后的结果是 0.3 秒！文末会讲！先不着急，咱们一个一个来讲！\n优化： 关于循环展开：你真的理解吗？ 看到这里，有人会说，不就是循环展开嘛，很简单的，没什么好研究的，而且加了优化选项之后，编译器会自动进行循环展开的，没必要手动去展开，也就没有研究的价值了！\n真的是这样吗？先尝试回答下面几个问题：\n循环展开为什么能提高程序性能，其背后的深层次原理是什么？ 循环随便怎么展开都一定可以提高性能吗？ 用了优化选项，编译器一定会帮我们自动进行循环展开优化吗？ 第一个问题后面会详细讲解，我们先用实例回答下第 2 个和第 3 个问题。\n先看第 2 个问题。\n循环随便展开都能提高性能吗？ 答案是否定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __attribute__((noinline)) int cacl(int n) { int fact = 1; for(int i =1; i\u003cn; i += 4) { fact *= i; fact *= i+1; fact *= i+2; fact *= i+3; } return fact; } int main() { return cacl(1000000000); } 仍然是循环展开，只不过把循环展开的方式稍微改了一下。再编译一下，用 time 命令测量下运行耗时： 和 test.c 相比运行耗时只减少了 0.2 秒！为什么同样是循环展开，test_2.c 只需要 1.6 秒，而 test_3.c 却要 3 秒，为什么性能差异这么大呢？别着急，后面细讲。\n再看第三个问题，加了优化选项，编译器一定会帮我们自动进行循环展开优化吗？一试便知\n-O3，编译器一定会循环展开吗？ 重新编译下 test.c, test_2.c, 和 test_3.c，只不过，这次我们加上-O3 优化选项，然后分别用 time 命令再测量下运行时间。\n先是 test.c： 加了-O3 优化后，程序耗时从原来的 3.29 秒降到了 1.07 秒，性能提升确实非常明显！是否好奇，-O3 选项对 test.c 做了什么样的优化，能够把程序耗时降到三分之一？这个后面再讲。\n现在，我们先试下 test_2.c： 同样，加了-O3 后，程序耗时从原来的 1 秒降到了 0.368 秒！此外，在同样加了-O3 的情况下，使用了循环展开的 test_2.c，程序耗时仍然是 test.c 的三分之一！可见，编译器确实优化了一些东西，但是，无论是否加-O3 优化选项，进行手动循环展开的 test.c 仍然是性能最好的！\n最后，再试下 test_3.c: 看到了吧？同样加了-O3 优化选项的前提下，性能仍然与 test_2.c 相差甚远！\n小结一下我们现在得到的几组测试结果： 在解释这些性能差异的原因之前，必须要先补充一些 CPU 相关的基础知识，否则无法真正理解这背后的原因！所以，请务必认真看完！\n这会涉及到 CPU 内部实现细节的知识，相对比较底层，而且对绝大多数程序员是透明的，因此很多人甚至都没听说过这些概念。不过，也不用担心，跟之前一样，我会尽量用通俗易懂的语言来解释这些概念。\n背景知识：CPU 内部架构 指令流水线(pipeline) 所谓流水线，是把指令的执行过程分成多个阶段，每个阶段使用 CPU 内部不同的硬件资源来完成。以经典的 5 级流水线为例，一条指令的执行被分为 5 个阶段：\n取指(IF)：从内存中取出一条指令。 译码(ID)：对指令进行解码，确定该指令要执行的操作。 执行(EX)：执行该指令要执行的操作。 访存(MEM)：进行内存访问操作。 写回(WB)：把执行的结果写回寄存器或内存。 在时钟信号的驱动下，CPU 依次来执行这些步骤，这就构成了指令流水线(pipeline)。如下图所示： 在CPU内部，执行每个阶段使用不同的硬件资源，从而可以让多条指令的执行时间相互重叠。当第一条指令完成取指，进入译码阶段时，第二条指令就可以进入取指阶段了。以此类推，在一个 5 级流水线中，理想情况下，可以有 5 条不同的指令的不同阶段在同时执行，因此每个时钟周期都会有一条指令完成执行，从而大大提高了 CPU 执行指令的吞吐率，从而提高 CPU 整体性能。这就叫做 ILP - 指令级并行（Instruction Level Parallelism）。如下图所示： 通过把指令执行分为多个阶段，CPU 每个时钟周期只处理一个阶段的工作，这样大大简化了 CPU 内部负责每个阶段的功能单元，每个时钟周期要做的事情少了，提高时钟频率也变得简单了。\n前面说过，有了流水线技术，理想情况下，每个时钟周期，CPU 可以完成一条指令的执行。那有没有什么方法，可以让 CPU 在每个时钟周期，完成多条指令的执行呢，这岂不是会大大提高 CPU 整体性能吗？\n当然有！这就是 Superscalar 技术！（除此之外还有 VLIW，不是本文重点，不再展开讨论。）\n超标量(Superscalar) Superscalar，通过在 CPU 内部实现多条指令流水线，可以真正实现多条命令并行执行，也被称为多发射数据通路技术。以双发射流水线为例，每个时钟周期，CPU 可以同时读取两条指令，然后同时对这两条指令进行译码，同时执行，然后同时写回。如下图所示： 流水线冲突 大家可能注意到了，前面多次强调过，“在理想状态下”，为什么呢？ 现实中程序的指令序列之间往往存在各种各样的依赖和相关性，而 CPU 为了解决这种指令间的依赖和相关性，有时候不得不“停顿”下来，直到这些依赖得到解决，这就导致 CPU 指令流水线无法总是保持“全速运行”。\n这种现象被称之为 Pipeline Hazard，很多资料翻译为“流水线冒险”，我觉得“流水线冲突”更为贴切易懂。\n归结起来，有三种情况：\n数据冲突(Data Hazard) 控制冲突(Control Hazard) 结构冲突(Structure Hazard) 下面分别举例解释这三种类型的冲突。\n数据冲突 所谓数据冲突，简单讲，就是两条在流水线中并行执行的指令，第二条指令需要用到第一条指令的执行结果，因此第二条指令的执行不得不暂停，一直到可以获取到第一条指令的执行结果为止。\n比如，用伪代码举例：\n1 2 x = 1; y = x; 要对 y 进行赋值，必须要先得到 x 的值，因此这两条语句无法完全并行执行。 这只是其中的一种典型情况，其他情况不再赘述。\n控制冲突 所谓控制冲突，简单讲，就是在 CPU 在执行分支跳转时，无法预知下一条要执行的指令。 比如：\n1 2 3 4 5 if(a \u003e 100) { x = 1; } else { y = 2; } 在 CPU 计算出 a \u003e 100 这个条件是否成立之前，无法确定接下来是应该执行 x = 1 还是执行 y = 2。\n为了解决这个问题，CPU 可以简单的让流水线停顿一直到确定下一条要执行的指令，也可以采取如分支预测(branch prediction)和推测执行(speculation execution)等手段，但是，预测失败的话，流水线往往会受到比较严重的性能惩罚。之后会有专门的文章分析这个问题，感兴趣的话，可以右上角关注一下！\n结构冲突 结构冲突，简单来说，就是多条指令同时竞争同一个硬件资源，由于硬件资源短缺，无法同时满足所有指令的执行请求。如两条并行执行的命令需要同时访问内存，而内存地址译码单元可能只有一个，这就产生了结构冲突。\n有了上面这些基础知识做铺垫，接下来就可以开始真正分析这个问题了。\ntest.c 为什么性能最差？ 对于计算阶乘，test.c 可能是最简单直观、可读性最强的算法。不过可惜的是，它也是性能最差的。\n我们再看一下 test.c 的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 __attribute__((noinline)) int cacl(int n) { int fact = 1; for(int i =1; i\u003cn; i++) { fact *= 1; } return fact; } int main() { return cacl(1000000000); } 说它性能最差，主要有三点原因：\n热点路径无用指令太多。 热点路径跳转指令太多。 热点路径内存访问太多。 注意，这里说的无用指令，是指对计算阶乘本身不产生直接影响的指令，但是它们对整个算法的正确性仍然是必不可少的！\n为例方便理解，我们来分别看下 test.c 不加优化选项和加了-O3 编译之后的汇编代码。\ntest.c 不加优化选项时 绿色方框标注出来的 8 ~ 14 行是 for 循环，也就是主循环体。其中，蓝色方框标注出来的 8 ~ 11 行是真正计算阶乘的代码，12 ~ 14 行是循环控制代码，对计算阶乘来说，则是无用代码。\n不难看出：\n热点路径上，也就是循环体内无用指令占比是 3/7 = 42%！即便在不考虑其他因素的情况下，CPU 单单用来执行这些无用的指令，也是一笔不小的开销！ 整个阶乘计算过程中，循环体内需要执行 1000000000 次条件跳转指令！条件跳转又会造成控制冲突，使得流水线无法全速运行，从而造成巨大的性能损失。 整个函数一共有 10 个内存访问操作，而循环体内就有 6 个内存操作！尽管很多时候可以通过 Cache 来缓解，但相对于 CPU 计算速度来说，内存操作仍然是非常慢的，而且容易造成流水线冲突！ 那加了-O3 优化选项之后，编译器能不能帮我们解决这些问题呢？\ntest.c 加了-O3 优化选项后 首先，不得不感叹，现在的编译器的优化真的是太强大了！直接把整个 for 循环优化成了 4 条指令！\n不难看出，对于 test.c 而言，加了-O3 之后，GCC 做的最大的优化是把所有变量存放在寄存器中，消除了所有的内存访问操作！\n可以回过头去看下优化之前的汇编代码，整个函数一共有 10 个内存访问操作，其中 6 个是在循环体内，而加了-O3 之后，整个函数没有任何内存访问操作！难怪-O3 编译后性能提升那么多！由此可见，内存访问相对寄存器访问的开销实在是太大了！当然，即便不使用-O3，也有优化内存操作的办法，这个后面再讲。\n但是，也不难看出，对于其他两个问题，GCC 并没有帮我们解决：现在无用指令占比是 2/4 = 50%! 整个阶乘计算过程，仍然需要执行 1000000000 次条件跳转指令，仍然无法充分发挥流水线和 superscalar 的指令并行执行能力！\n知道了 test.c 性能差的原因之后，现在我们来看看，通过手动循环展开，test_2.c 又帮我们解决什么问题呢？\ntest_2.c 性能提升原因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __attribute__((noinline)) int cacl(int n) { int fact0=1, fact1=1, fact2=1, fact3=1; for(int i =1; i\u003cn; i += 4) { fact0 *= i; fact1 *= i+1; fact2 *= i+2; fact3 *= i+3; } return fact0 * fact1 * fact2 * fact3; } int main() { return cacl(1000000000); } 通过对循环进行 4 次展开，之前每次循环执行 1 次乘法，现在每次循环执行 4 次，这就带来了三点很重要的变化：\n循环次数减少 75%，无用指令减少了，相应的 CPU 执行这些指令本身的开销也少了。 计算过程中，热点路径的条件跳转指令少了 75%，这样就减少了由于控制相关引起的流水线冲突，提升了流水线执行的效率。 提升了指令的并行度，使得 CPU superscalar 的技术得到更充分的发挥，提高了每个时钟周期并行执行指令的条数。 这也就是为什么在使用同样的编译选项时，test_2.c 比 test.c 的性能提升了 200%！不过，热点路径上内存访问操作太多的问题仍然存在。其实，这个其实很好解决，我会在下文给出解决方法。我们先把注意力放在这里所说的三点变化上。\n对于第 1 点和第 2 点，有了前面介绍的指令流水线的背景知识，即便从 C 语言的角度也很好理解，不需要过多解释。\n至于第 3 点，为了便于理解，我们和 test_3.c 对比来看。\ntest_3.c 性能差的原因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __attribute__((noinline)) int cacl(int n) { int fact = 1; for(int i =1; i\u003cn; i += 4) { fact *= i; fact *= i+1; fact *= i+2; fact *= i+3; } return fact; } int main() { return cacl(1000000000); } 很明显，后面一条指令执行前，必须要先知道前面一条语句计算的结果。还记得前面讲过的造成流水线冲突的三个原因吗？这就是典型的数据依赖，会造成流水线冲突！\n可见，虽然 test_3.c 也通过循环展开，减少了无用指令，也减少了热点路径上分支跳转引起的流水线控制冲突，但它同时引入了数据依赖，进而导致流水线冲突，仍然无法发挥流水线和superscalar的指令级并行执行的能力！\n这就是为什么，用同样的选项编译时，test_3.c 虽然比未经过循环展开的 test.c 性能稍微提升了一点点，但相比同样循环展开且没有引入数据相关性的 test_2.c 来说，性能仍然是非常差的！\n讲到这里，本想演示下用 perf 测量出来的性能指标的，但由于篇幅过长，就不再展开讨论了，以后会专门更新文章介绍 perf 相关工具的使用！\n最后，来看一下前面遗留的那个问题：不加优化选项的情况下，怎么解决热点路径内存访问过多的问题。\n杀手锏：优化热点路径内存访问 其实很简单，只需要把 test_2.c 中定义局部变量的时候加上register关键字就可以了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 __attribute__((noinline)) int cacl(int n) { register int fact0=1, fact1=1, fact2=1, fact3=1; for(register int i =1; i\u003cn; i += 4) { fact0 *= i; fact1 *= i+1; fact2 *= i+2; fact3 *= i+3; } return fact0 * fact1 * fact2 * fact3; } int main() { return cacl(1000000000); } C语言中，register关键字的作用是建议编译器，尽可能地把变量存放在寄存器中，以加快其访问速度。\n我们现在看下，加了 register 关键字后，test_2.c 的性能如何呢？\n加了 register 后，几乎达到了和加-O3 优化选项一样的性能！\n当然，register 的使用还有很多限制，而且它只是给编译器的一种建议，不是强制要求，编译器只能尽量满足，当变量太多，寄存器不够用的时候，还是不得不把变量放到栈中，这和-O3 的行为是一样的。\nregister 不是本文重点，限于篇幅，不再赘述。\n小结 循环展开是一种非常重要的优化方法，也是编译器后端中常用的一种优化方式，它可以通过减少热点路径上的“无用指令”以及分支指令的个数，来更好地发挥 CPU 指令流水线的指令并行执行能力，从而提高程序整体性能。\n很多时候，我们可以借助编译器来帮我们实现这种优化，但编译器也有失效的时候，比如文中这个例子。这时，我们就不得不手动来进行循环展开来优化程序性能。循环展开时，必须尽量减少语句间的相互依赖。\n此外，循环展开的次数并没有一个固定的公式，需要根据具体代码和CPU来决定，通常需要多次尝试来找到一个最优值。\n不过，手动循环展开往往是以牺牲代码可读性为代价的，因此使用时也做好取舍。此外，循环展开还会在一定程度上增加程序代码段的大小，还可能会影响到程序局部性，对 cache 产生影响，因此使用时候，要仔细权衡。\n","wordCount":"883","inLanguage":"en","datePublished":"2023-12-26T10:09:28+08:00","dateModified":"2023-12-26T10:09:28+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/en/posts/os_network/for%E5%BE%AA%E7%8E%AF%E8%80%97%E6%97%B6%E4%BB%8E3.2%E7%A7%92%E9%99%8D%E5%88%B00.3%E7%A7%92/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/os_network/>操作系统，网络编程，架构相关的文章</a></div><h1 class=post-title>For循环耗时从3.2秒降到0.3秒</h1><div class=post-description>For循环耗时从3.2秒降到0.3秒</div><div class=post-meta>&lt;span title='2023-12-26 10:09:28 +0800 +0800'>2023-12-26&lt;/span>&amp;nbsp;·&amp;nbsp;5 min&amp;nbsp;·&amp;nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e9%81%93%e9%9d%a2%e8%af%95%e9%a2%98 aria-label=一道面试题>一道面试题</a><ul><li><a href=#%e6%b5%8b%e8%af%95%e7%a8%8b%e5%ba%8f aria-label=测试程序>测试程序</a></li><li><a href=#%e4%bc%98%e5%8c%96-%e5%85%b3%e4%ba%8e%e5%be%aa%e7%8e%af%e5%b1%95%e5%bc%80%e4%bd%a0%e7%9c%9f%e7%9a%84%e7%90%86%e8%a7%a3%e5%90%97 aria-label="优化： 关于循环展开：你真的理解吗？">优化： 关于循环展开：你真的理解吗？</a></li><li><a href=#%e5%be%aa%e7%8e%af%e9%9a%8f%e4%be%bf%e5%b1%95%e5%bc%80%e9%83%bd%e8%83%bd%e6%8f%90%e9%ab%98%e6%80%a7%e8%83%bd%e5%90%97 aria-label=循环随便展开都能提高性能吗？>循环随便展开都能提高性能吗？</a></li><li><a href=#-o3%e7%bc%96%e8%af%91%e5%99%a8%e4%b8%80%e5%ae%9a%e4%bc%9a%e5%be%aa%e7%8e%af%e5%b1%95%e5%bc%80%e5%90%97 aria-label=-O3，编译器一定会循环展开吗？>-O3，编译器一定会循环展开吗？</a></li></ul></li><li><a href=#%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86cpu-%e5%86%85%e9%83%a8%e6%9e%b6%e6%9e%84 aria-label="背景知识：CPU 内部架构">背景知识：CPU 内部架构</a><ul><li><a href=#%e6%8c%87%e4%bb%a4%e6%b5%81%e6%b0%b4%e7%ba%bfpipeline aria-label=指令流水线(pipeline)>指令流水线(pipeline)</a></li><li><a href=#%e8%b6%85%e6%a0%87%e9%87%8fsuperscalar aria-label=超标量(Superscalar)>超标量(Superscalar)</a></li><li><a href=#%e6%b5%81%e6%b0%b4%e7%ba%bf%e5%86%b2%e7%aa%81 aria-label=流水线冲突>流水线冲突</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%86%b2%e7%aa%81 aria-label=数据冲突>数据冲突</a></li><li><a href=#%e6%8e%a7%e5%88%b6%e5%86%b2%e7%aa%81 aria-label=控制冲突>控制冲突</a></li><li><a href=#%e7%bb%93%e6%9e%84%e5%86%b2%e7%aa%81 aria-label=结构冲突>结构冲突</a></li></ul></li><li><a href=#testc-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%80%a7%e8%83%bd%e6%9c%80%e5%b7%ae aria-label="test.c 为什么性能最差？">test.c 为什么性能最差？</a></li><li><a href=#testc-%e4%b8%8d%e5%8a%a0%e4%bc%98%e5%8c%96%e9%80%89%e9%a1%b9%e6%97%b6 aria-label="test.c 不加优化选项时">test.c 不加优化选项时</a></li><li><a href=#testc-%e5%8a%a0%e4%ba%86-o3-%e4%bc%98%e5%8c%96%e9%80%89%e9%a1%b9%e5%90%8e aria-label="test.c 加了-O3 优化选项后">test.c 加了-O3 优化选项后</a></li><li><a href=#test_2c-%e6%80%a7%e8%83%bd%e6%8f%90%e5%8d%87%e5%8e%9f%e5%9b%a0 aria-label="test_2.c 性能提升原因">test_2.c 性能提升原因</a></li><li><a href=#test_3c-%e6%80%a7%e8%83%bd%e5%b7%ae%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label="test_3.c 性能差的原因">test_3.c 性能差的原因</a></li><li><a href=#%e6%9d%80%e6%89%8b%e9%94%8f%e4%bc%98%e5%8c%96%e7%83%ad%e7%82%b9%e8%b7%af%e5%be%84%e5%86%85%e5%ad%98%e8%ae%bf%e9%97%ae aria-label=杀手锏：优化热点路径内存访问>杀手锏：优化热点路径内存访问</a></li></ul></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></div></details></div><div class=post-content><h1 id=一道面试题>一道面试题<a hidden class=anchor aria-hidden=true href=#一道面试题>#</a></h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>test</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fact</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>num</span> <span class=o>=</span> <span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>num</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>面试官：这段求阶乘的代码怎么样？
答：挺简洁的，简单易懂。不过如果参数 n 值比较大的话，会导致 fact 溢出，结果是错的。
面试官：嗯，是的。不过，咱们先不考虑溢出的问题，你觉得这段代码的性能怎么样？
答：时间复杂度是 O(n)，而且代码比较精炼，性能应该还挺不错的吧？(心虚 ing&mldr;)
面试官：你能想办法把它优化一下，让性能更好吗？
思考 ing&mldr;
答：在多 CPU 系统上，如果 n 的值比较大的话，可以考虑用多线程来实现。
面试官：嗯，这是一个思路。如果是单 CPU 呢？
再次思考 ing&mldr;
答：用 GCC 编译的话，可以加上优化选项-O3，应该能提高性能。
面试官：嗯，还有吗？
答：没了。
面试官：好了，感谢来参加面试，回去等通知吧！
思考一下，如果是你的话，会怎么回答呢？
下面，来深入讲解一下，隐藏在这道题背后的深层次知识！
本文较长，且涉及到 CPU 内部很底层的知识，请耐心看完，一定会有收获！</p><h2 id=测试程序>测试程序<a hidden class=anchor aria-hidden=true href=#测试程序>#</a></h2><p>测试程序 test.c 非常简单，计算 1000000000 的阶乘：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>noinline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>cacl</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fact</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>cacl</span><span class=p>(</span><span class=mi>1000000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>为方便分析，函数 calc()前面加上<strong>attribute</strong>((noinline))，禁止 GCC 把 calc 内联在 main()中。此外，calc()中，fact 类型是 int，main()中调用 calc(1000000000)，会导致 fact 溢出，但不影响测试，不用管它。</p><p>然后，把程序稍微改一下，命名为 test_2.c：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>noinline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>cacl</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fact0</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact1</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact2</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact3</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact0</span> <span class=o>*=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact1</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact2</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact3</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact0</span> <span class=o>*</span> <span class=n>fact1</span> <span class=o>*</span> <span class=n>fact2</span> <span class=o>*</span> <span class=n>fact3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>cacl</span><span class=p>(</span><span class=mi>1000000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>注意：这里为方便讲解，假设 n 总是 4 的倍数。如果要处理 n 不是 4 的倍数的情况，只需要在主循环体外，增加一个小的循环单独处理最后的 n%4 个数，也就是最多 3 个数即可，对整体性能影响几乎为 0.</p><p>运行耗时从原来的 3.29 秒降到了 1 秒，性能提升了 200%！你以为这就完了？</p><p>这还不是最终的结果，因为我们还有一个优化技巧还没加上，最终优化后的结果是 0.3 秒！文末会讲！先不着急，咱们一个一个来讲！</p><h2 id=优化-关于循环展开你真的理解吗>优化： 关于循环展开：你真的理解吗？<a hidden class=anchor aria-hidden=true href=#优化-关于循环展开你真的理解吗>#</a></h2><p>看到这里，有人会说，不就是循环展开嘛，很简单的，没什么好研究的，而且加了优化选项之后，编译器会自动进行循环展开的，没必要手动去展开，也就没有研究的价值了！</p><p>真的是这样吗？先尝试回答下面几个问题：</p><ol><li>循环展开为什么能提高程序性能，其背后的深层次原理是什么？</li><li>循环随便怎么展开都一定可以提高性能吗？</li><li>用了优化选项，编译器一定会帮我们自动进行循环展开优化吗？</li></ol><p>第一个问题后面会详细讲解，我们先用实例回答下第 2 个和第 3 个问题。</p><p>先看第 2 个问题。</p><h2 id=循环随便展开都能提高性能吗>循环随便展开都能提高性能吗？<a hidden class=anchor aria-hidden=true href=#循环随便展开都能提高性能吗>#</a></h2><p>答案是否定的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>noinline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>cacl</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fact</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>cacl</span><span class=p>(</span><span class=mi>1000000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>仍然是循环展开，只不过把循环展开的方式稍微改了一下。再编译一下，用 time 命令测量下运行耗时：
和 test.c 相比运行耗时只减少了 0.2 秒！为什么同样是循环展开，test_2.c 只需要 1.6 秒，而 test_3.c 却要 3 秒，为什么性能差异这么大呢？别着急，后面细讲。</p><p>再看第三个问题，加了优化选项，编译器一定会帮我们自动进行循环展开优化吗？一试便知</p><h2 id=-o3编译器一定会循环展开吗>-O3，编译器一定会循环展开吗？<a hidden class=anchor aria-hidden=true href=#-o3编译器一定会循环展开吗>#</a></h2><p>重新编译下 test.c, test_2.c, 和 test_3.c，只不过，这次我们加上-O3 优化选项，然后分别用 time 命令再测量下运行时间。</p><p>先是 test.c：
加了-O3 优化后，程序耗时从原来的 3.29 秒降到了 1.07 秒，性能提升确实非常明显！是否好奇，-O3 选项对 test.c 做了什么样的优化，能够把程序耗时降到三分之一？这个后面再讲。</p><p>现在，我们先试下 test_2.c：
同样，加了-O3 后，程序耗时从原来的 1 秒降到了 0.368 秒！此外，在同样加了-O3 的情况下，使用了循环展开的 test_2.c，程序耗时仍然是 test.c 的三分之一！可见，编译器确实优化了一些东西，但是，无论是否加-O3 优化选项，进行手动循环展开的 test.c 仍然是性能最好的！</p><p>最后，再试下 test_3.c:
看到了吧？同样加了-O3 优化选项的前提下，性能仍然与 test_2.c 相差甚远！</p><p>小结一下我们现在得到的几组测试结果：
<img loading=lazy src=https://github.com/Reid00/picx-images-hosting/raw/main/20231226/image.2me7flunrko0.png alt=perf></p><p>在解释这些性能差异的原因之前，必须要先补充一些 CPU 相关的基础知识，否则无法真正理解这背后的原因！所以，请务必认真看完！</p><p>这会涉及到 CPU 内部实现细节的知识，相对比较底层，而且对绝大多数程序员是透明的，因此很多人甚至都没听说过这些概念。不过，也不用担心，跟之前一样，我会尽量用通俗易懂的语言来解释这些概念。</p><h1 id=背景知识cpu-内部架构>背景知识：CPU 内部架构<a hidden class=anchor aria-hidden=true href=#背景知识cpu-内部架构>#</a></h1><h2 id=指令流水线pipeline>指令流水线(pipeline)<a hidden class=anchor aria-hidden=true href=#指令流水线pipeline>#</a></h2><p>所谓<code>流水线</code>，是把指令的执行过程分成多个阶段，每个阶段使用 CPU 内部不同的硬件资源来完成。以经典的 5 级流水线为例，一条指令的执行被分为 5 个阶段：</p><ul><li><code>取指(IF)</code>：从内存中取出一条指令。</li><li><code>译码(ID)</code>：对指令进行解码，确定该指令要执行的操作。</li><li><code>执行(EX)</code>：执行该指令要执行的操作。</li><li><code>访存(MEM)</code>：进行内存访问操作。</li><li><code>写回(WB)</code>：把执行的结果写回寄存器或内存。</li></ul><p>在时钟信号的驱动下，CPU 依次来执行这些步骤，这就构成了指令流水线(pipeline)。如下图所示：
<img loading=lazy src=https://github.com/Reid00/picx-images-hosting/raw/main/20231226/image.1r08epnr8n9c.webp alt=pipeline></p><p><code>在CPU内部，执行每个阶段使用不同的硬件资源，从而可以让多条指令的执行时间相互重叠</code>。当第一条指令完成取指，进入译码阶段时，第二条指令就可以进入取指阶段了。以此类推，在一个 5 级流水线中，理想情况下，可以有 5 条不同的指令的不同阶段在同时执行，因此每个时钟周期都会有一条指令完成执行，从而大大提高了 CPU 执行指令的吞吐率，从而提高 CPU 整体性能。这就叫做 ILP - 指令级并行（Instruction Level Parallelism）。如下图所示：
<img loading=lazy src=https://github.com/Reid00/picx-images-hosting/raw/main/20231226/image.5tb66f9cd0k0.webp alt=ilp></p><p>通过把指令执行分为多个阶段，CPU 每个时钟周期只处理一个阶段的工作，这样大大简化了 CPU 内部负责每个阶段的功能单元，每个时钟周期要做的事情少了，提高时钟频率也变得简单了。</p><p>前面说过，有了流水线技术，理想情况下，每个时钟周期，CPU 可以完成一条指令的执行。那有没有什么方法，可以让 CPU 在每个时钟周期，完成多条指令的执行呢，这岂不是会大大提高 CPU 整体性能吗？</p><p>当然有！这就是 Superscalar 技术！（除此之外还有 VLIW，不是本文重点，不再展开讨论。）</p><h2 id=超标量superscalar>超标量(Superscalar)<a hidden class=anchor aria-hidden=true href=#超标量superscalar>#</a></h2><p>Superscalar，通过在 CPU 内部实现多条指令流水线，可以真正实现多条命令并行执行，也被称为多发射数据通路技术。以双发射流水线为例，每个时钟周期，CPU 可以同时读取两条指令，然后同时对这两条指令进行译码，同时执行，然后同时写回。如下图所示：
<img loading=lazy src=https://github.com/Reid00/picx-images-hosting/raw/main/20231226/image.20wa24bzsdeo.png alt=superscalar></p><h2 id=流水线冲突>流水线冲突<a hidden class=anchor aria-hidden=true href=#流水线冲突>#</a></h2><p>大家可能注意到了，前面多次强调过，“在理想状态下”，为什么呢？
现实中程序的指令序列之间往往存在各种各样的依赖和相关性，而 CPU 为了解决这种指令间的依赖和相关性，有时候不得不“停顿”下来，直到这些依赖得到解决，这就导致 CPU 指令流水线无法总是保持“全速运行”。</p><p>这种现象被称之为 Pipeline Hazard，很多资料翻译为“流水线冒险”，我觉得“流水线冲突”更为贴切易懂。</p><p>归结起来，有三种情况：</p><ul><li>数据冲突(Data Hazard)</li><li>控制冲突(Control Hazard)</li><li>结构冲突(Structure Hazard)</li></ul><p>下面分别举例解释这三种类型的冲突。</p><h3 id=数据冲突>数据冲突<a hidden class=anchor aria-hidden=true href=#数据冲突>#</a></h3><p>所谓数据冲突，简单讲，就是两条在流水线中并行执行的指令，<code>第二条指令需要用到第一条指令的执行结果</code>，因此第二条指令的执行不得不暂停，一直到可以获取到第一条指令的执行结果为止。</p><p>比如，用伪代码举例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>要对 y 进行赋值，必须要先得到 x 的值，因此这两条语句无法完全并行执行。
这只是其中的一种典型情况，其他情况不再赘述。</p><h3 id=控制冲突>控制冲突<a hidden class=anchor aria-hidden=true href=#控制冲突>#</a></h3><p>所谓控制冲突，简单讲，就是在 CPU 在<code>执行分支跳转时，无法预知下一条要执行的指令</code>。
比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>a</span> <span class=o>&gt;</span> <span class=mi>100</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在 CPU 计算出 a > 100 这个条件是否成立之前，无法确定接下来是应该执行 x = 1 还是执行 y = 2。</p><p>为了解决这个问题，CPU 可以简单的让<code>流水线停顿</code>一直到确定下一条要执行的指令，也可以采取如<code>分支预测(branch prediction)和推测执行(speculation execution)</code>等手段，但是，预测失败的话，流水线往往会受到比较严重的性能惩罚。之后会有专门的文章分析这个问题，感兴趣的话，可以右上角关注一下！</p><h3 id=结构冲突>结构冲突<a hidden class=anchor aria-hidden=true href=#结构冲突>#</a></h3><p>结构冲突，简单来说，<code>就是多条指令同时竞争同一个硬件资源</code>，由于硬件资源短缺，无法同时满足所有指令的执行请求。如两条并行执行的命令需要同时访问内存，而内存地址译码单元可能只有一个，这就产生了结构冲突。</p><p>有了上面这些基础知识做铺垫，接下来就可以开始真正分析这个问题了。</p><h2 id=testc-为什么性能最差>test.c 为什么性能最差？<a hidden class=anchor aria-hidden=true href=#testc-为什么性能最差>#</a></h2><p>对于计算阶乘，test.c 可能是最简单直观、可读性最强的算法。不过可惜的是，它也是性能最差的。</p><p>我们再看一下 test.c 的源码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>noinline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>cacl</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fact</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>cacl</span><span class=p>(</span><span class=mi>1000000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>说它性能最差，主要有三点原因：</p><ol><li>热点路径无用指令太多。</li><li>热点路径跳转指令太多。</li><li>热点路径内存访问太多。</li></ol><p>注意，这里说的无用指令，是指对计算阶乘本身不产生直接影响的指令，但是它们对整个算法的正确性仍然是必不可少的！</p><p>为例方便理解，我们来分别看下 test.c 不加优化选项和加了-O3 编译之后的汇编代码。</p><h2 id=testc-不加优化选项时>test.c 不加优化选项时<a hidden class=anchor aria-hidden=true href=#testc-不加优化选项时>#</a></h2><p><img loading=lazy src=https://github.com/Reid00/picx-images-hosting/raw/main/20231226/image.q8386j66yyo.png alt=no-O3></p><p>绿色方框标注出来的 8 ~ 14 行是 for 循环，也就是主循环体。其中，蓝色方框标注出来的 8 ~ 11 行是真正计算阶乘的代码，12 ~ 14 行是循环控制代码，对计算阶乘来说，则是无用代码。</p><p>不难看出：</p><ol><li>热点路径上，也就是循环体内无用指令占比是 3/7 = 42%！即便在不考虑其他因素的情况下，CPU 单单用来执行这些无用的指令，也是一笔不小的开销！</li><li>整个阶乘计算过程中，循环体内需要执行 1000000000 次条件跳转指令！条件跳转又会造成控制冲突，使得流水线无法全速运行，从而造成巨大的性能损失。</li><li>整个函数一共有 10 个内存访问操作，而循环体内就有 6 个内存操作！尽管很多时候可以通过 Cache 来缓解，但相对于 CPU 计算速度来说，内存操作仍然是非常慢的，而且容易造成流水线冲突！</li></ol><p>那加了-O3 优化选项之后，编译器能不能帮我们解决这些问题呢？</p><h2 id=testc-加了-o3-优化选项后>test.c 加了-O3 优化选项后<a hidden class=anchor aria-hidden=true href=#testc-加了-o3-优化选项后>#</a></h2><p><img loading=lazy src=https://github.com/Reid00/picx-images-hosting/raw/main/20231226/image.7h3si0rrh5s0.png alt=-O3></p><p>首先，不得不感叹，现在的编译器的优化真的是太强大了！直接把整个 for 循环优化成了 4 条指令！</p><p>不难看出，对于 test.c 而言，加了-O3 之后，GCC 做的最大的优化是把所有变量存放在寄存器中，消除了所有的内存访问操作！</p><p>可以回过头去看下优化之前的汇编代码，整个函数一共有 10 个内存访问操作，其中 6 个是在循环体内，而加了-O3 之后，整个函数没有任何内存访问操作！难怪-O3 编译后性能提升那么多！由此可见，内存访问相对寄存器访问的开销实在是太大了！当然，即便不使用-O3，也有优化内存操作的办法，这个后面再讲。</p><p>但是，也不难看出，对于其他两个问题，GCC 并没有帮我们解决：现在无用指令占比是 2/4 = 50%! 整个阶乘计算过程，仍然需要执行 1000000000 次条件跳转指令，仍然无法充分发挥流水线和 superscalar 的指令并行执行能力！</p><p>知道了 test.c 性能差的原因之后，现在我们来看看，通过手动循环展开，test_2.c 又帮我们解决什么问题呢？</p><h2 id=test_2c-性能提升原因>test_2.c 性能提升原因<a hidden class=anchor aria-hidden=true href=#test_2c-性能提升原因>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>noinline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>cacl</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fact0</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact1</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact2</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact3</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact0</span> <span class=o>*=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact1</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact2</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact3</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact0</span> <span class=o>*</span> <span class=n>fact1</span> <span class=o>*</span> <span class=n>fact2</span> <span class=o>*</span> <span class=n>fact3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>cacl</span><span class=p>(</span><span class=mi>1000000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过对循环进行 4 次展开，之前每次循环执行 1 次乘法，现在每次循环执行 4 次，这就带来了三点很重要的变化：</p><ol><li>循环次数减少 75%，无用指令减少了，相应的 CPU 执行这些指令本身的开销也少了。</li><li>计算过程中，热点路径的条件跳转指令少了 75%，这样就减少了由于控制相关引起的流水线冲突，提升了流水线执行的效率。</li><li>提升了指令的并行度，使得 CPU superscalar 的技术得到更充分的发挥，提高了每个时钟周期并行执行指令的条数。</li></ol><p>这也就是为什么在使用同样的编译选项时，test_2.c 比 test.c 的性能提升了 200%！不过，热点路径上内存访问操作太多的问题仍然存在。其实，这个其实很好解决，我会在下文给出解决方法。我们先把注意力放在这里所说的三点变化上。</p><p>对于第 1 点和第 2 点，有了前面介绍的指令流水线的背景知识，即便从 C 语言的角度也很好理解，不需要过多解释。</p><p>至于第 3 点，为了便于理解，我们和 test_3.c 对比来看。</p><h2 id=test_3c-性能差的原因>test_3.c 性能差的原因<a hidden class=anchor aria-hidden=true href=#test_3c-性能差的原因>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>noinline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>cacl</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fact</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>cacl</span><span class=p>(</span><span class=mi>1000000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>很明显，后面一条指令执行前，必须要先知道前面一条语句计算的结果。还记得前面讲过的造成流水线冲突的三个原因吗？这就是典型的数据依赖，会造成<code>流水线冲突</code>！</p><p>可见，虽然 test_3.c 也通过循环展开，减少了无用指令，也减少了热点路径上分支跳转引起的流水线控制冲突，但它同时引入了数据依赖，进而导致流水线冲突，<code>仍然无法发挥流水线和superscalar的指令级并行执行的能力</code>！</p><p>这就是为什么，用同样的选项编译时，test_3.c 虽然比未经过循环展开的 test.c 性能稍微提升了一点点，但相比同样循环展开且没有引入数据相关性的 test_2.c 来说，性能仍然是非常差的！</p><p>讲到这里，本想演示下用 perf 测量出来的性能指标的，但由于篇幅过长，就不再展开讨论了，以后会专门更新文章介绍 perf 相关工具的使用！</p><p>最后，来看一下前面遗留的那个问题：<code>不加优化选项的情况下，怎么解决热点路径内存访问过多的问题</code>。</p><h2 id=杀手锏优化热点路径内存访问>杀手锏：优化热点路径内存访问<a hidden class=anchor aria-hidden=true href=#杀手锏优化热点路径内存访问>#</a></h2><p>其实很简单，只需要把 test_2.c 中定义局部变量的时候加上<code>register</code>关键字就可以了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>__attribute__</span><span class=p>((</span><span class=n>noinline</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>cacl</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>register</span> <span class=kt>int</span> <span class=n>fact0</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact1</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact2</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>fact3</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=k>register</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>4</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>fact0</span> <span class=o>*=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact1</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact2</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fact3</span> <span class=o>*=</span> <span class=n>i</span><span class=o>+</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fact0</span> <span class=o>*</span> <span class=n>fact1</span> <span class=o>*</span> <span class=n>fact2</span> <span class=o>*</span> <span class=n>fact3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>cacl</span><span class=p>(</span><span class=mi>1000000000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>C语言中，register关键字的作用是建议编译器，尽可能地把变量存放在寄存器中，以加快其访问速度。</code></p><p>我们现在看下，加了 register 关键字后，test_2.c 的性能如何呢？</p><p>加了 register 后，几乎达到了和加-O3 优化选项一样的性能！</p><p>当然，register 的使用还有很多限制，而且它只是给编译器的一种建议，不是强制要求，编译器只能尽量满足，当变量太多，寄存器不够用的时候，还是不得不把变量放到栈中，这和-O3 的行为是一样的。</p><p>register 不是本文重点，限于篇幅，不再赘述。</p><h1 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h1><p>循环展开是一种非常重要的优化方法，也是编译器后端中常用的一种优化方式，它可以通过减少热点路径上的“无用指令”以及分支指令的个数，来更好地发挥 CPU 指令流水线的指令并行执行能力，从而提高程序整体性能。</p><p>很多时候，我们可以借助编译器来帮我们实现这种优化，但编译器也有失效的时候，比如文中这个例子。这时，我们就不得不手动来进行循环展开来优化程序性能。循环展开时，必须尽量减少语句间的相互依赖。</p><p>此外，<code>循环展开的次数并没有一个固定的公式，需要根据具体代码和CPU来决定，通常需要多次尝试来找到一个最优值</code>。</p><p>不过，手动循环展开往往是以牺牲代码可读性为代价的，因此使用时也做好取舍。此外，循环展开还会在一定程度上增加程序代码段的大小，还可能会影响到程序局部性，对 cache 产生影响，因此使用时候，要仔细权衡。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/cpu/>CPU</a></li><li><a href=https://reid00.github.io/en/tags/%E5%BE%AA%E7%8E%AF/>循环</a></li><li><a href=https://reid00.github.io/en/tags/%E4%BC%98%E5%8C%96/>优化</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/langs_linux/rust-leetcode%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/><span class=title>« Prev</span><br><span>Rust Leetcode链表实现</span>
</a><a class=next href=https://reid00.github.io/en/posts/storage/b+%E6%A0%91/><span class=title>Next »</span><br><span>B+树</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://reid00.github.io/en/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>