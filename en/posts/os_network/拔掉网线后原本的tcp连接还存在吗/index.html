<!doctype html><html lang=en dir=auto><head><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/en/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://reid00.github.io/en/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/en/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/en/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/en/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/en/posts/os_network/>操作系统，网络编程，架构相关的文章</a></div><h1 class=post-title>拔掉网线后,原本的TCP连接还存在吗？</h1><div class=post-description>拔掉网线后,原本的TCP连接还存在吗？</div><div class=post-meta><span title='2023-03-16 19:35:12 +0800 +0800'>2023-03-16 19:35</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;424 words&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a></li><li><a href=#%e6%8b%94%e6%8e%89%e7%bd%91%e7%ba%bf%e5%90%8e%e6%9c%89%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93 aria-label=拔掉网线后，有数据传输>拔掉网线后，有数据传输</a><ul><li><a href=#%e9%82%a3-tcp-%e7%9a%84%e6%95%b0%e6%8d%ae%e6%8a%a5%e6%96%87%e5%85%b7%e4%bd%93%e9%87%8d%e4%bc%a0%e5%87%a0%e6%ac%a1%e5%91%a2 aria-label="那 TCP 的数据报文具体重传几次呢？">那 TCP 的数据报文具体重传几次呢？</a></li></ul></li><li><a href=#%e6%8b%94%e6%8e%89%e7%bd%91%e7%ba%bf%e5%90%8e%e6%b2%a1%e6%9c%89%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93 aria-label=拔掉网线后，没有数据传输。>拔掉网线后，没有数据传输。</a><ul><li><a href=#tcp-keepalive-%e6%9c%ba%e5%88%b6%e5%85%b7%e4%bd%93%e6%98%af%e6%80%8e%e4%b9%88%e6%a0%b7%e7%9a%84 aria-label="TCP keepalive 机制具体是怎么样的？">TCP keepalive 机制具体是怎么样的？</a></li><li><a href=#tcp-keepalive-%e6%9c%ba%e5%88%b6%e6%8e%a2%e6%b5%8b%e7%9a%84%e6%97%b6%e9%97%b4%e4%b9%9f%e5%a4%aa%e9%95%bf%e4%ba%86%e5%90%a7 aria-label="TCP keepalive 机制探测的时间也太长了吧？">TCP keepalive 机制探测的时间也太长了吧？</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a><ul><li><a href=#%e6%89%a9%e5%b1%95 aria-label=扩展>扩展</a></li><li><a href=#tcp%e9%87%8d%e7%bd%ae%e6%8a%a5%e6%96%87%e6%ae%b5%e5%8f%8arst%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af%e5%88%86%e6%9e%90 aria-label=TCP重置报文段及RST常见场景分析>TCP重置报文段及RST常见场景分析</a></li><li><a href=#connection-reset-%e4%b8%8e-connection-reset-by-peer aria-label="Connection reset 与 Connection reset by peer">Connection reset 与 Connection reset by peer</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？</p><p>可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的传输层理应也会断开，所以原本的 TCP 连接就不会存在了。就好像， 我们拨打有线电话的时候，如果某一方的电话线被拔了，那么本次通话就彻底断了。</p><p>真的是这样吗？</p><p>上面这个逻辑就有问题。问题在于，错误地认为拔掉网线这个动作会影响传输层，事实上并不会影响。</p><p>实际上，TCP 连接在 Linux 内核中是一个名为 struct socket 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p><p>我在我的电脑上做了个小实验，我用 ssh 终端连接了我的云服务器，然后我通过断开 wifi 的方式来模拟拔掉网线的场景，此时查看 TCP 连接的状态没有发生变化，还是处于 ESTABLISHED 状态。
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220318/image.26jpebl7l45c.webp alt=disconnect></p><p>通过上面这个实验结果，我们知道了，拔掉网线这个动作并不会影响 TCP 连接的状态。
接下来，要看拔掉网线后，双方做了什么动作。
针对这个问题，要分场景来讨论：</p><ul><li>拔掉网线后，有数据传输；</li><li>拔掉网线后，没有数据传输。</li></ul><hr><h2 id=拔掉网线后有数据传输>拔掉网线后，有数据传输<a hidden class=anchor aria-hidden=true href=#拔掉网线后有数据传输>#</a></h2><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p><p><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，<strong>然后客户端就会回 ACK 响应报文</strong>。</p><p>此时，客户端和服务端的 TCP 连接依然存在，就感觉什么事情都没有发生。</p><p>但是，如<strong>果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的<strong>次数达到一定阈值后</strong>，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p><p>而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元组的 TCP 连接了，因此<strong>服务端内核就会回复 RST 报文</strong>，客户端收到后就会释放该 TCP 连接。</p><p>此时，客户端和服务端的 TCP 连接都已经断开了。</p><h3 id=那-tcp-的数据报文具体重传几次呢>那 TCP 的数据报文具体重传几次呢？<a hidden class=anchor aria-hidden=true href=#那-tcp-的数据报文具体重传几次呢>#</a></h3><p>在 Linux 系统中，提供了一个叫 tcp_retries2 配置项，默认值是 15，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@nebula-server-6 shell<span class=o>]</span><span class=c1># cat /proc/sys/net/ipv4/tcp_retries2</span>
</span></span><span class=line><span class=cl><span class=m>15</span>
</span></span></code></pre></td></tr></table></div></div><p>这个内核参数是控制，在 TCP <strong>连接建立的情况下，超时重传的最大次数。</strong></p><p>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核还会基于「<strong>最大超时时间</strong>」来判定。</p><p>每一轮的超时时间都是倍数增长的，比如第一次触发超时重传是在 2s 后，第二次则是在 4s 后，第三次则是 8s 后，以此类推。</p><p>内核会根据 tcp_retries2 设置的值，计算出一个最大超时时间。</p><p>在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传，然后就会断开 TCP 连接。</p><hr><h2 id=拔掉网线后没有数据传输>拔掉网线后，没有数据传输。<a hidden class=anchor aria-hidden=true href=#拔掉网线后没有数据传输>#</a></h2><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p><p>如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。</p><p>而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：</p><ul><li><strong>如果对端是正常工作的</strong>。当 TCP 保活的探测报文发送给对端，对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li><li><strong>如果对端主机崩溃</strong>，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</li></ul><h3 id=tcp-keepalive-机制具体是怎么样的>TCP keepalive 机制具体是怎么样的？<a hidden class=anchor aria-hidden=true href=#tcp-keepalive-机制具体是怎么样的>#</a></h3><p>这个机制的原理是这样的：
定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>在 Linux 内核有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>net.ipv4.tcp_keepalive_time<span class=o>=</span><span class=m>7200</span>
</span></span><span class=line><span class=cl>net.ipv4.tcp_keepalive_intvl<span class=o>=</span><span class=m>75</span>  
</span></span><span class=line><span class=cl>net.ipv4.tcp_keepalive_probes<span class=o>=</span><span class=m>9</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制；</li><li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li><li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p><blockquote><p>tcp_keepalive_time + tcp_keepalive_intvl * tcp_keepalive_probes
==>
7200 + 75 * 9 =7879s (2h11min15s)</p></blockquote><p>注意，应用程序若想使用 TCP 保活机制，需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><h3 id=tcp-keepalive-机制探测的时间也太长了吧>TCP keepalive 机制探测的时间也太长了吧？<a hidden class=anchor aria-hidden=true href=#tcp-keepalive-机制探测的时间也太长了吧>#</a></h3><p>对的，是有点长。</p><p>TCP keepalive 是 <code>TCP 层（内核态）</code> 实现的，它是给所有基于 TCP 传输协议的程序一个兜底的方案。</p><p>实际上，我们应用层可以自己实现一套探测机制，可以在较短的时间内，探测到对方是否存活。</p><p>比如，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会启动一个<strong>定时器</strong>，如果客户端在发完一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接</strong>。
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220318/image.4fzyoqy0bee0.webp alt=img></p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。</p><p>有数据传输的情况：</p><ul><li><p>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。</p></li><li><p>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。</p></li></ul><p>没有数据传输的情况：</p><ul><li>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li><li>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li></ul><p>除了客户端拔掉网线的场景，还有客户端「<strong>宕机和杀死进程</strong>」的两种场景。</p><p>第一个场景，客户端宕机这件事跟拔掉网线是一样无法被服务端感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p><p>所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。</p><p>第二个场景，杀死客户端的进程后，客户端的内核就会向服务端发送 <strong>FIN 报文</strong>，与客户端进行四次挥手。</p><p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知得到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><hr><h3 id=扩展>扩展<a hidden class=anchor aria-hidden=true href=#扩展>#</a></h3><h3 id=tcp重置报文段及rst常见场景分析>TCP重置报文段及RST常见场景分析<a hidden class=anchor aria-hidden=true href=#tcp重置报文段及rst常见场景分析>#</a></h3><p><code>RST</code>表示连接重置，用于关闭那些已经没有必要继续存在的连接。一般情况下表示异常关闭连接，区别与四次分手正常关闭连接。</p><p>我们知道TCP建立连接的时候需要三次连接，TCP释放连接的时候需要四次挥手，在这个过程中，出现了很多特殊的标志报文段，例如SYN ACK FIN，在TCP协议中，除了上面说了那些标志报文段之外，还有其他的报文段，如PUSH标志报文段以及今天需要重点讲解的RST报文段。</p><p>RST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误；</p><p>发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST；接收端收到RST包后，也不必发送ACK包来确认。</p><p>“Connection reset”的原因是服务器关闭了Connection[调用了Socket.close()方法]。大家可能有疑问了：服务器关闭了Connection为什么会返回“RST”而不是返回“FIN”标志。原因在于Socket.close()方法的语义和TCP的“FIN”标志语义不一样：
发送TCP的“FIN”标志表示我不再发送数据了，而Socket.close()表示我不在发送也不接受数据了。问题就出在“我不接受数据” 上，如果此时客户端还往服务器发送数据，服务器内核接收到数据，但是发现此时Socket已经close了，则会返回“RST”标志给客户端。当然，此时客户端就会提示：“Connection reset”。</p><p><strong>产生RST的三个条件是：</strong></p><ol><li>目的地 为某端口的SYN到达，然而在该端口上并没有正在监听的服务器；</li><li>TCP想取消一个已有连接；</li><li>TCP接收到一个根本不存在的连接上的分节。</li></ol><hr><h3 id=connection-reset-与-connection-reset-by-peer>Connection reset 与 Connection reset by peer<a hidden class=anchor aria-hidden=true href=#connection-reset-与-connection-reset-by-peer>#</a></h3><ul><li>服务器返回了 “RST” 时，如果此时客户端正在从 Socket 套接字的输出流中读数据则会提示 Connection reset ；</li></ul><blockquote><p>A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的 TCP 处理程序会发 RST 包。</p></blockquote><ul><li>服务器返回了 “RST” 时，如果此时客户端正在往 Socket 套接字的输入流中写数据则会提示 Connection reset by peer 。</li></ul><blockquote><p>AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。
等网络恢复之后，B又开始发数据包（客户端并不知道，服务器已经忘记三次握手了），A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现 connect reset by peer 错误。</p></blockquote><p><strong>需要注意的是，服务端有两种情况不会发送RST：</strong></p><ol><li><p>服务器关机：
会断开 TCP 连接，会发送 FIN 数据报</p></li><li><p>服务器主机崩溃的状态
如果，客户端和服务器已经建立了连接的时候，此时服务器崩溃（达到这一标准可以把服务器的网线拔掉，这个时候，服务器就不能发送 FIN 数据报了，和关机不一样的）</p></li></ol><p>此时如果客户端向服务器发送数据的时候，因为服务器已经不存在了，那么客户端就不能接受到服务器给客户端的 ack 信息，这个时候，客户端建立的是 TCP 连接，就会重发数据报，发送多少次之后就会返回超时，也就是 ETIMEOUT 。</p><p>ETIMEOUT：当connect调用的时候会进行三次握手，如果客户端没有收到服务器对SYN的ACK数据报，就会返回ETIMEOUT（客户端在返回这个错误之前会重发SYN数据报）</p><p>前面谈到了导致 “Connection reset” 的原因，而具体的<strong>解决方案</strong>有如下几种：</p><ol><li>出错了重试；</li><li>客户端和服务器统一使用TCP长连接；</li><li>客户端和服务器统一使用TCP短连接。</li></ol><ul><li><p>首先是出错了重试：这种方案可以简单防止 “Connection reset” 错误，然后如果服务不是 “幂等” 的则不能使用该方法；比如提交订单操作就不是幂等的，如果使用重试则可能造成重复提单。</p></li><li><p>然后是客户端和服务器统一使用 TCP 长连接：客户端使用 TCP 长连接很容易配置（直接设置HttpClient就好），而服务器配置长连接就比较麻烦了，就拿tomcat来说，需要设置 tomcat 的 maxKeepAliveRequests 、connectionTimeout 等参数。另外如果使用了 nginx 进行反向代理或负载均衡，此时也需要配置 nginx 以支持长连接（nginx默认是对客户端使用长连接，对服务器使用短连接，详见 keepalived 相关指令）。</p></li><li><p>使用长连接可以避免每次建立 TCP 连接的三次握手而节约一定的时间，但是我这边由于是内网，客户端和服务器的 3 次握手很快，大约只需1ms。ping一下大约0.93ms（一次往返）；三次握手也是一次往返（第三次握手不用返回）。根据80/20原理，1ms可以忽略不计；又考虑到长连接的扩展性不如短连接好、修改nginx和tomcat的配置代价很大（所有后台服务都需要修改）；所以这里并没有使用长连接。</p></li></ul><p>小结</p><ol><li>Connection reset，远程主机没有监听这个端口、连接，可以是：</li></ol><ul><li>服务端已关闭，客户端仍旧请求，服务端返回Rst；</li><li>服务端未监听该端口，客户端请求，服务端返回Rst；</li></ul><ol start=2><li>Connection reset by peer，是远程主机强迫关闭了一个现有的连接，可以是：</li></ol><ul><li>客户端断网重连，服务端返回Rst；</li><li>服务端进程崩溃后重启，向先前的客户端返回Rst，并等待下次重新与客户端建连；</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/en/tags/tcp/>TCP</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/en/posts/algo/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8C%E8%BF%9B%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/><span class=title>« Prev</span><br><span>常见的二进位运算技巧</span>
</a><a class=next href=https://reid00.github.io/en/posts/other/utterances-%E7%BB%99-hugo-papermod-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/><span class=title>Next »</span><br><span>Utterances 给 Hugo PaperMod 主题添加评论系统</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><span id=busuanzi_container_site_pv>访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>访客数<span id=busuanzi_value_site_uv></span>人次</span></body></html>