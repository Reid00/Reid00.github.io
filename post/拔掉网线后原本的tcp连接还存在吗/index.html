<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>拔掉网线后,原本的TCP连接还存在吗？ | Reid's Blog</title><meta name=keywords content="TCP"><meta name=description content="背景 今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？ 可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/post/%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%E5%8E%9F%E6%9C%AC%E7%9A%84tcp%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="拔掉网线后,原本的TCP连接还存在吗？"><meta property="og:description" content="背景 今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？ 可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/post/%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%E5%8E%9F%E6%9C%AC%E7%9A%84tcp%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-06-08T14:26:19+08:00"><meta property="article:modified_time" content="2022-06-08T14:26:19+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="拔掉网线后,原本的TCP连接还存在吗？"><meta name=twitter:description content="背景 今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？ 可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/post/"},{"@type":"ListItem","position":2,"name":"拔掉网线后,原本的TCP连接还存在吗？","item":"https://reid00.github.io/post/%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%E5%8E%9F%E6%9C%AC%E7%9A%84tcp%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"拔掉网线后,原本的TCP连接还存在吗？","name":"拔掉网线后,原本的TCP连接还存在吗？","description":"背景 今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？ 可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的","keywords":["TCP"],"articleBody":"背景 今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？\n可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的传输层理应也会断开，所以原本的 TCP 连接就不会存在了。就好像， 我们拨打有线电话的时候，如果某一方的电话线被拔了，那么本次通话就彻底断了。\n真的是这样吗？\n上面这个逻辑就有问题。问题在于，错误地认为拔掉网线这个动作会影响传输层，事实上并不会影响。\n实际上，TCP 连接在 Linux 内核中是一个名为 struct socket 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。\n我在我的电脑上做了个小实验，我用 ssh 终端连接了我的云服务器，然后我通过断开 wifi 的方式来模拟拔掉网线的场景，此时查看 TCP 连接的状态没有发生变化，还是处于 ESTABLISHED 状态。 通过上面这个实验结果，我们知道了，拔掉网线这个动作并不会影响 TCP 连接的状态。 接下来，要看拔掉网线后，双方做了什么动作。 针对这个问题，要分场景来讨论：\n拔掉网线后，有数据传输； 拔掉网线后，没有数据传输。 拔掉网线后，有数据传输 在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发超时重传机制，重传未得到响应的数据报文。\n如果在服务端重传报文的过程中，客户端刚好把网线插回去了，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。\n此时，客户端和服务端的 TCP 连接依然存在，就感觉什么事情都没有发生。\n但是，如果在服务端重传报文的过程中，客户端一直没有将网线插回去，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。\n而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元组的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。\n此时，客户端和服务端的 TCP 连接都已经断开了。\n那 TCP 的数据报文具体重传几次呢？ 在 Linux 系统中，提供了一个叫 tcp_retries2 配置项，默认值是 15，如下：\n1 2 [root@nebula-server-6 shell]# cat /proc/sys/net/ipv4/tcp_retries2 15 这个内核参数是控制，在 TCP 连接建立的情况下，超时重传的最大次数。\n不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核还会基于「最大超时时间」来判定。\n每一轮的超时时间都是倍数增长的，比如第一次触发超时重传是在 2s 后，第二次则是在 4s 后，第三次则是 8s 后，以此类推。\n内核会根据 tcp_retries2 设置的值，计算出一个最大超时时间。\n在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传，然后就会断开 TCP 连接。\n拔掉网线后，没有数据传输。 针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。\n如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。\n而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：\n如果对端是正常工作的。当 TCP 保活的探测报文发送给对端，对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。 如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。 所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。 TCP keepalive 机制具体是怎么样的？ 这个机制的原理是这样的： 定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。\n在 Linux 内核有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：\n1 2 3 net.ipv4.tcp_keepalive_time=7200 net.ipv4.tcp_keepalive_intvl=75 net.ipv4.tcp_keepalive_probes=9 tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制； tcp_keepalive_intvl=75：表示每次检测间隔 75 秒； tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。 也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。\ntcp_keepalive_time + tcp_keepalive_intvl * tcp_keepalive_probes ==\u003e 7200 + 75 * 9 =7879s (2h11min15s)\n注意，应用程序若想使用 TCP 保活机制，需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。\nTCP keepalive 机制探测的时间也太长了吧？ 对的，是有点长。\nTCP keepalive 是 TCP 层（内核态） 实现的，它是给所有基于 TCP 传输协议的程序一个兜底的方案。\n实际上，我们应用层可以自己实现一套探测机制，可以在较短的时间内，探测到对方是否存活。\n比如，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会启动一个定时器，如果客户端在发完一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，就会触发回调函数来释放该连接。 总结 客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。\n有数据传输的情况：\n在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。\n在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。\n没有数据传输的情况：\n如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。 如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。 除了客户端拔掉网线的场景，还有客户端「宕机和杀死进程」的两种场景。\n第一个场景，客户端宕机这件事跟拔掉网线是一样无法被服务端感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。\n所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。\n第二个场景，杀死客户端的进程后，客户端的内核就会向服务端发送 FIN 报文，与客户端进行四次挥手。\n所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知得到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。\n扩展 TCP重置报文段及RST常见场景分析 RST表示连接重置，用于关闭那些已经没有必要继续存在的连接。一般情况下表示异常关闭连接，区别与四次分手正常关闭连接。\n我们知道TCP建立连接的时候需要三次连接，TCP释放连接的时候需要四次挥手，在这个过程中，出现了很多特殊的标志报文段，例如SYN ACK FIN，在TCP协议中，除了上面说了那些标志报文段之外，还有其他的报文段，如PUSH标志报文段以及今天需要重点讲解的RST报文段。\nRST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误；\n发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST；接收端收到RST包后，也不必发送ACK包来确认。\n“Connection reset”的原因是服务器关闭了Connection[调用了Socket.close()方法]。大家可能有疑问了：服务器关闭了Connection为什么会返回“RST”而不是返回“FIN”标志。原因在于Socket.close()方法的语义和TCP的“FIN”标志语义不一样： 发送TCP的“FIN”标志表示我不再发送数据了，而Socket.close()表示我不在发送也不接受数据了。问题就出在“我不接受数据” 上，如果此时客户端还往服务器发送数据，服务器内核接收到数据，但是发现此时Socket已经close了，则会返回“RST”标志给客户端。当然，此时客户端就会提示：“Connection reset”。\n产生RST的三个条件是：\n目的地 为某端口的SYN到达，然而在该端口上并没有正在监听的服务器； TCP想取消一个已有连接； TCP接收到一个根本不存在的连接上的分节。 Connection reset 与 Connection reset by peer 服务器返回了 “RST” 时，如果此时客户端正在从 Socket 套接字的输出流中读数据则会提示 Connection reset ； A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的 TCP 处理程序会发 RST 包。\n服务器返回了 “RST” 时，如果此时客户端正在往 Socket 套接字的输入流中写数据则会提示 Connection reset by peer 。 AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。 等网络恢复之后，B又开始发数据包（客户端并不知道，服务器已经忘记三次握手了），A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现 connect reset by peer 错误。\n需要注意的是，服务端有两种情况不会发送RST：\n服务器关机： 会断开 TCP 连接，会发送 FIN 数据报\n服务器主机崩溃的状态 如果，客户端和服务器已经建立了连接的时候，此时服务器崩溃（达到这一标准可以把服务器的网线拔掉，这个时候，服务器就不能发送 FIN 数据报了，和关机不一样的）\n此时如果客户端向服务器发送数据的时候，因为服务器已经不存在了，那么客户端就不能接受到服务器给客户端的 ack 信息，这个时候，客户端建立的是 TCP 连接，就会重发数据报，发送多少次之后就会返回超时，也就是 ETIMEOUT 。\nETIMEOUT：当connect调用的时候会进行三次握手，如果客户端没有收到服务器对SYN的ACK数据报，就会返回ETIMEOUT（客户端在返回这个错误之前会重发SYN数据报）\n前面谈到了导致 “Connection reset” 的原因，而具体的解决方案有如下几种：\n出错了重试； 客户端和服务器统一使用TCP长连接； 客户端和服务器统一使用TCP短连接。 首先是出错了重试：这种方案可以简单防止 “Connection reset” 错误，然后如果服务不是 “幂等” 的则不能使用该方法；比如提交订单操作就不是幂等的，如果使用重试则可能造成重复提单。\n然后是客户端和服务器统一使用 TCP 长连接：客户端使用 TCP 长连接很容易配置（直接设置HttpClient就好），而服务器配置长连接就比较麻烦了，就拿tomcat来说，需要设置 tomcat 的 maxKeepAliveRequests 、connectionTimeout 等参数。另外如果使用了 nginx 进行反向代理或负载均衡，此时也需要配置 nginx 以支持长连接（nginx默认是对客户端使用长连接，对服务器使用短连接，详见 keepalived 相关指令）。\n使用长连接可以避免每次建立 TCP 连接的三次握手而节约一定的时间，但是我这边由于是内网，客户端和服务器的 3 次握手很快，大约只需1ms。ping一下大约0.93ms（一次往返）；三次握手也是一次往返（第三次握手不用返回）。根据80/20原理，1ms可以忽略不计；又考虑到长连接的扩展性不如短连接好、修改nginx和tomcat的配置代价很大（所有后台服务都需要修改）；所以这里并没有使用长连接。\n小结\nConnection reset，远程主机没有监听这个端口、连接，可以是： 服务端已关闭，客户端仍旧请求，服务端返回Rst； 服务端未监听该端口，客户端请求，服务端返回Rst； Connection reset by peer，是远程主机强迫关闭了一个现有的连接，可以是： 客户端断网重连，服务端返回Rst； 服务端进程崩溃后重启，向先前的客户端返回Rst，并等待下次重新与客户端建连； ","wordCount":"5053","inLanguage":"en","datePublished":"2022-06-08T14:26:19+08:00","dateModified":"2022-06-08T14:26:19+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/post/%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E%E5%8E%9F%E6%9C%AC%E7%9A%84tcp%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/post/>Posts</a></div><h1 class=post-title>拔掉网线后,原本的TCP连接还存在吗？</h1><div class=post-meta><span title='2022-06-08 14:26:19 +0800 +0800'>2022-06-08</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a></li><li><a href=#%e6%8b%94%e6%8e%89%e7%bd%91%e7%ba%bf%e5%90%8e%e6%9c%89%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93 aria-label=拔掉网线后，有数据传输>拔掉网线后，有数据传输</a><ul><li><a href=#%e9%82%a3-tcp-%e7%9a%84%e6%95%b0%e6%8d%ae%e6%8a%a5%e6%96%87%e5%85%b7%e4%bd%93%e9%87%8d%e4%bc%a0%e5%87%a0%e6%ac%a1%e5%91%a2 aria-label="那 TCP 的数据报文具体重传几次呢？">那 TCP 的数据报文具体重传几次呢？</a></li></ul></li><li><a href=#%e6%8b%94%e6%8e%89%e7%bd%91%e7%ba%bf%e5%90%8e%e6%b2%a1%e6%9c%89%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93 aria-label=拔掉网线后，没有数据传输。>拔掉网线后，没有数据传输。</a><ul><li><a href=#tcp-keepalive-%e6%9c%ba%e5%88%b6%e5%85%b7%e4%bd%93%e6%98%af%e6%80%8e%e4%b9%88%e6%a0%b7%e7%9a%84 aria-label="TCP keepalive 机制具体是怎么样的？">TCP keepalive 机制具体是怎么样的？</a></li><li><a href=#tcp-keepalive-%e6%9c%ba%e5%88%b6%e6%8e%a2%e6%b5%8b%e7%9a%84%e6%97%b6%e9%97%b4%e4%b9%9f%e5%a4%aa%e9%95%bf%e4%ba%86%e5%90%a7 aria-label="TCP keepalive 机制探测的时间也太长了吧？">TCP keepalive 机制探测的时间也太长了吧？</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a><ul><li><a href=#%e6%89%a9%e5%b1%95 aria-label=扩展>扩展</a></li><li><a href=#tcp%e9%87%8d%e7%bd%ae%e6%8a%a5%e6%96%87%e6%ae%b5%e5%8f%8arst%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af%e5%88%86%e6%9e%90 aria-label=TCP重置报文段及RST常见场景分析>TCP重置报文段及RST常见场景分析</a></li><li><a href=#connection-reset-%e4%b8%8e-connection-reset-by-peer aria-label="Connection reset 与 Connection reset by peer">Connection reset 与 Connection reset by peer</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>今天，聊一个有趣的问题：拔掉网线几秒，再插回去，原本的 TCP 连接还存在吗？</p><p>可能有的同学会说，网线都被拔掉了，那说明物理层被断开了，那在上层的传输层理应也会断开，所以原本的 TCP 连接就不会存在了。就好像， 我们拨打有线电话的时候，如果某一方的电话线被拔了，那么本次通话就彻底断了。</p><p>真的是这样吗？</p><p>上面这个逻辑就有问题。问题在于，错误地认为拔掉网线这个动作会影响传输层，事实上并不会影响。</p><p>实际上，TCP 连接在 Linux 内核中是一个名为 struct socket 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p><p>我在我的电脑上做了个小实验，我用 ssh 终端连接了我的云服务器，然后我通过断开 wifi 的方式来模拟拔掉网线的场景，此时查看 TCP 连接的状态没有发生变化，还是处于 ESTABLISHED 状态。
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220318/image.26jpebl7l45c.webp alt=disconnect></p><p>通过上面这个实验结果，我们知道了，拔掉网线这个动作并不会影响 TCP 连接的状态。
接下来，要看拔掉网线后，双方做了什么动作。
针对这个问题，要分场景来讨论：</p><ul><li>拔掉网线后，有数据传输；</li><li>拔掉网线后，没有数据传输。</li></ul><hr><h2 id=拔掉网线后有数据传输>拔掉网线后，有数据传输<a hidden class=anchor aria-hidden=true href=#拔掉网线后有数据传输>#</a></h2><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p><p><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，<strong>然后客户端就会回 ACK 响应报文</strong>。</p><p>此时，客户端和服务端的 TCP 连接依然存在，就感觉什么事情都没有发生。</p><p>但是，如<strong>果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的<strong>次数达到一定阈值后</strong>，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p><p>而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元组的 TCP 连接了，因此<strong>服务端内核就会回复 RST 报文</strong>，客户端收到后就会释放该 TCP 连接。</p><p>此时，客户端和服务端的 TCP 连接都已经断开了。</p><h3 id=那-tcp-的数据报文具体重传几次呢>那 TCP 的数据报文具体重传几次呢？<a hidden class=anchor aria-hidden=true href=#那-tcp-的数据报文具体重传几次呢>#</a></h3><p>在 Linux 系统中，提供了一个叫 tcp_retries2 配置项，默认值是 15，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>root@nebula-server-6 shell<span class=o>]</span><span class=c1># cat /proc/sys/net/ipv4/tcp_retries2</span>
</span></span><span class=line><span class=cl><span class=m>15</span>
</span></span></code></pre></td></tr></table></div></div><p>这个内核参数是控制，在 TCP <strong>连接建立的情况下，超时重传的最大次数。</strong></p><p>不过 tcp_retries2 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接，内核还会基于「<strong>最大超时时间</strong>」来判定。</p><p>每一轮的超时时间都是倍数增长的，比如第一次触发超时重传是在 2s 后，第二次则是在 4s 后，第三次则是 8s 后，以此类推。</p><p>内核会根据 tcp_retries2 设置的值，计算出一个最大超时时间。</p><p>在重传报文且一直没有收到对方响应的情况时，先达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传，然后就会断开 TCP 连接。</p><hr><h2 id=拔掉网线后没有数据传输>拔掉网线后，没有数据传输。<a hidden class=anchor aria-hidden=true href=#拔掉网线后没有数据传输>#</a></h2><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p><p>如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。</p><p>而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：</p><ul><li><strong>如果对端是正常工作的</strong>。当 TCP 保活的探测报文发送给对端，对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li><li><strong>如果对端主机崩溃</strong>，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</li></ul><h3 id=tcp-keepalive-机制具体是怎么样的>TCP keepalive 机制具体是怎么样的？<a hidden class=anchor aria-hidden=true href=#tcp-keepalive-机制具体是怎么样的>#</a></h3><p>这个机制的原理是这样的：
定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>在 Linux 内核有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>net.ipv4.tcp_keepalive_time<span class=o>=</span><span class=m>7200</span>
</span></span><span class=line><span class=cl>net.ipv4.tcp_keepalive_intvl<span class=o>=</span><span class=m>75</span>  
</span></span><span class=line><span class=cl>net.ipv4.tcp_keepalive_probes<span class=o>=</span><span class=m>9</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制；</li><li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li><li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p><blockquote><p>tcp_keepalive_time + tcp_keepalive_intvl * tcp_keepalive_probes
==>
7200 + 75 * 9 =7879s (2h11min15s)</p></blockquote><p>注意，应用程序若想使用 TCP 保活机制，需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。</p><h3 id=tcp-keepalive-机制探测的时间也太长了吧>TCP keepalive 机制探测的时间也太长了吧？<a hidden class=anchor aria-hidden=true href=#tcp-keepalive-机制探测的时间也太长了吧>#</a></h3><p>对的，是有点长。</p><p>TCP keepalive 是 <code>TCP 层（内核态）</code> 实现的，它是给所有基于 TCP 传输协议的程序一个兜底的方案。</p><p>实际上，我们应用层可以自己实现一套探测机制，可以在较短的时间内，探测到对方是否存活。</p><p>比如，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会启动一个<strong>定时器</strong>，如果客户端在发完一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接</strong>。
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220318/image.4fzyoqy0bee0.webp alt=img></p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。</p><p>有数据传输的情况：</p><ul><li><p>在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。</p></li><li><p>在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。</p></li></ul><p>没有数据传输的情况：</p><ul><li>如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li><li>如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li></ul><p>除了客户端拔掉网线的场景，还有客户端「<strong>宕机和杀死进程</strong>」的两种场景。</p><p>第一个场景，客户端宕机这件事跟拔掉网线是一样无法被服务端感知的，所以如果在没有数据传输，并且没有开启 TCP keepalive 机制时，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p><p>所以，我们可以得知一个点。在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。</p><p>第二个场景，杀死客户端的进程后，客户端的内核就会向服务端发送 <strong>FIN 报文</strong>，与客户端进行四次挥手。</p><p>所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知得到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><hr><h3 id=扩展>扩展<a hidden class=anchor aria-hidden=true href=#扩展>#</a></h3><h3 id=tcp重置报文段及rst常见场景分析>TCP重置报文段及RST常见场景分析<a hidden class=anchor aria-hidden=true href=#tcp重置报文段及rst常见场景分析>#</a></h3><p><code>RST</code>表示连接重置，用于关闭那些已经没有必要继续存在的连接。一般情况下表示异常关闭连接，区别与四次分手正常关闭连接。</p><p>我们知道TCP建立连接的时候需要三次连接，TCP释放连接的时候需要四次挥手，在这个过程中，出现了很多特殊的标志报文段，例如SYN ACK FIN，在TCP协议中，除了上面说了那些标志报文段之外，还有其他的报文段，如PUSH标志报文段以及今天需要重点讲解的RST报文段。</p><p>RST：（Reset the connection）用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求。如果接收到RST位时候，通常发生了某些错误；</p><p>发送RST包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃缓冲区中的包，发送RST；接收端收到RST包后，也不必发送ACK包来确认。</p><p>“Connection reset”的原因是服务器关闭了Connection[调用了Socket.close()方法]。大家可能有疑问了：服务器关闭了Connection为什么会返回“RST”而不是返回“FIN”标志。原因在于Socket.close()方法的语义和TCP的“FIN”标志语义不一样：
发送TCP的“FIN”标志表示我不再发送数据了，而Socket.close()表示我不在发送也不接受数据了。问题就出在“我不接受数据” 上，如果此时客户端还往服务器发送数据，服务器内核接收到数据，但是发现此时Socket已经close了，则会返回“RST”标志给客户端。当然，此时客户端就会提示：“Connection reset”。</p><p><strong>产生RST的三个条件是：</strong></p><ol><li>目的地 为某端口的SYN到达，然而在该端口上并没有正在监听的服务器；</li><li>TCP想取消一个已有连接；</li><li>TCP接收到一个根本不存在的连接上的分节。</li></ol><hr><h3 id=connection-reset-与-connection-reset-by-peer>Connection reset 与 Connection reset by peer<a hidden class=anchor aria-hidden=true href=#connection-reset-与-connection-reset-by-peer>#</a></h3><ul><li>服务器返回了 “RST” 时，如果此时客户端正在从 Socket 套接字的输出流中读数据则会提示 Connection reset ；</li></ul><blockquote><p>A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的 TCP 处理程序会发 RST 包。</p></blockquote><ul><li>服务器返回了 “RST” 时，如果此时客户端正在往 Socket 套接字的输入流中写数据则会提示 Connection reset by peer 。</li></ul><blockquote><p>AB正常建立连接了，正在通讯时，A向B发送了FIN包要求关连接，B发送ACK后，网断了，A通过若干原因放弃了这个连接（例如进程重启）。
等网络恢复之后，B又开始发数据包（客户端并不知道，服务器已经忘记三次握手了），A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现 connect reset by peer 错误。</p></blockquote><p><strong>需要注意的是，服务端有两种情况不会发送RST：</strong></p><ol><li><p>服务器关机：
会断开 TCP 连接，会发送 FIN 数据报</p></li><li><p>服务器主机崩溃的状态
如果，客户端和服务器已经建立了连接的时候，此时服务器崩溃（达到这一标准可以把服务器的网线拔掉，这个时候，服务器就不能发送 FIN 数据报了，和关机不一样的）</p></li></ol><p>此时如果客户端向服务器发送数据的时候，因为服务器已经不存在了，那么客户端就不能接受到服务器给客户端的 ack 信息，这个时候，客户端建立的是 TCP 连接，就会重发数据报，发送多少次之后就会返回超时，也就是 ETIMEOUT 。</p><p>ETIMEOUT：当connect调用的时候会进行三次握手，如果客户端没有收到服务器对SYN的ACK数据报，就会返回ETIMEOUT（客户端在返回这个错误之前会重发SYN数据报）</p><p>前面谈到了导致 “Connection reset” 的原因，而具体的<strong>解决方案</strong>有如下几种：</p><ol><li>出错了重试；</li><li>客户端和服务器统一使用TCP长连接；</li><li>客户端和服务器统一使用TCP短连接。</li></ol><ul><li><p>首先是出错了重试：这种方案可以简单防止 “Connection reset” 错误，然后如果服务不是 “幂等” 的则不能使用该方法；比如提交订单操作就不是幂等的，如果使用重试则可能造成重复提单。</p></li><li><p>然后是客户端和服务器统一使用 TCP 长连接：客户端使用 TCP 长连接很容易配置（直接设置HttpClient就好），而服务器配置长连接就比较麻烦了，就拿tomcat来说，需要设置 tomcat 的 maxKeepAliveRequests 、connectionTimeout 等参数。另外如果使用了 nginx 进行反向代理或负载均衡，此时也需要配置 nginx 以支持长连接（nginx默认是对客户端使用长连接，对服务器使用短连接，详见 keepalived 相关指令）。</p></li><li><p>使用长连接可以避免每次建立 TCP 连接的三次握手而节约一定的时间，但是我这边由于是内网，客户端和服务器的 3 次握手很快，大约只需1ms。ping一下大约0.93ms（一次往返）；三次握手也是一次往返（第三次握手不用返回）。根据80/20原理，1ms可以忽略不计；又考虑到长连接的扩展性不如短连接好、修改nginx和tomcat的配置代价很大（所有后台服务都需要修改）；所以这里并没有使用长连接。</p></li></ul><p>小结</p><ol><li>Connection reset，远程主机没有监听这个端口、连接，可以是：</li></ol><ul><li>服务端已关闭，客户端仍旧请求，服务端返回Rst；</li><li>服务端未监听该端口，客户端请求，服务端返回Rst；</li></ul><ol start=2><li>Connection reset by peer，是远程主机强迫关闭了一个现有的连接，可以是：</li></ol><ul><li>客户端断网重连，服务端返回Rst；</li><li>服务端进程崩溃后重启，向先前的客户端返回Rst，并等待下次重新与客户端建连；</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/tags/tcp/>TCP</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/post/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84/><span class=title>« Prev</span><br><span>高并发架构</span></a>
<a class=next href=https://reid00.github.io/post/linux%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B/><span class=title>Next »</span><br><span>Linux性能检测</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/Reid00.github.io issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://reid00.github.io/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement('button');e.classList.add('copy-code'),e.innerHTML='copy';function s(){e.innerHTML='copied!',setTimeout(()=>{e.innerHTML='copy'},2e3)}e.addEventListener('click',o=>{if('clipboard'in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand('copy'),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>