<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker笔记 | Reid's Blog</title><meta name=keywords content="Docker"><meta name=description content="一、概述 1.1 基本概念： Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。
1.2 对比虚拟机与Docker Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。
说了这么多Docker的优势，大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。
1.3 与传统VM特性对比： 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于原生 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 1.4 Docker组件 docker Client客户端————>向docker服务器进程发起请求，如:创建、停止、销毁容器等操作
docker Server服务器进程—–>处理所有docker的请求，管理所有容器
docker Registry镜像仓库——>镜像存放的中央仓库，可看作是存放二进制的scm
1.5 Docker的三个概念 镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 二、安装Docker 2.1 Ubuntu 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：
1 $ sudo apt-get remove docker docker-engine docker.io 使用 APT 安装 1 2 3 $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common Docker CE 镜像源站 使用官方安装脚本自动安装 （仅适用于公网环境） 1 curl -fsSL https://get."><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/posts/docker%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker笔记"><meta property="og:description" content="一、概述 1.1 基本概念： Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。
1.2 对比虚拟机与Docker Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。
说了这么多Docker的优势，大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。
1.3 与传统VM特性对比： 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于原生 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 1.4 Docker组件 docker Client客户端————>向docker服务器进程发起请求，如:创建、停止、销毁容器等操作
docker Server服务器进程—–>处理所有docker的请求，管理所有容器
docker Registry镜像仓库——>镜像存放的中央仓库，可看作是存放二进制的scm
1.5 Docker的三个概念 镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 二、安装Docker 2.1 Ubuntu 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：
1 $ sudo apt-get remove docker docker-engine docker.io 使用 APT 安装 1 2 3 $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common Docker CE 镜像源站 使用官方安装脚本自动安装 （仅适用于公网环境） 1 curl -fsSL https://get."><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/posts/docker%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-08T11:26:10+08:00"><meta property="article:modified_time" content="2022-06-08T11:26:10+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="Docker笔记"><meta name=twitter:description content="一、概述 1.1 基本概念： Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。
1.2 对比虚拟机与Docker Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。
说了这么多Docker的优势，大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。
1.3 与传统VM特性对比： 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于原生 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 1.4 Docker组件 docker Client客户端————>向docker服务器进程发起请求，如:创建、停止、销毁容器等操作
docker Server服务器进程—–>处理所有docker的请求，管理所有容器
docker Registry镜像仓库——>镜像存放的中央仓库，可看作是存放二进制的scm
1.5 Docker的三个概念 镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 二、安装Docker 2.1 Ubuntu 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：
1 $ sudo apt-get remove docker docker-engine docker.io 使用 APT 安装 1 2 3 $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common Docker CE 镜像源站 使用官方安装脚本自动安装 （仅适用于公网环境） 1 curl -fsSL https://get."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Docker笔记","item":"https://reid00.github.io/posts/docker%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker笔记","name":"Docker笔记","description":"一、概述 1.1 基本概念： Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。\n1.2 对比虚拟机与Docker Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。\n说了这么多Docker的优势，大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。\n1.3 与传统VM特性对比： 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于原生 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 1.4 Docker组件 docker Client客户端————\u0026gt;向docker服务器进程发起请求，如:创建、停止、销毁容器等操作\ndocker Server服务器进程—–\u0026gt;处理所有docker的请求，管理所有容器\ndocker Registry镜像仓库——\u0026gt;镜像存放的中央仓库，可看作是存放二进制的scm\n1.5 Docker的三个概念 镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 二、安装Docker 2.1 Ubuntu 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：\n1 $ sudo apt-get remove docker docker-engine docker.io 使用 APT 安装 1 2 3 $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common Docker CE 镜像源站 使用官方安装脚本自动安装 （仅适用于公网环境） 1 curl -fsSL https://get.","keywords":["Docker"],"articleBody":"一、概述 1.1 基本概念： Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。\n1.2 对比虚拟机与Docker Docker守护进程可以直接与主操作系统进行通信，为各个Docker容器分配资源；它还可以将容器与主操作系统隔离，并将各个容器互相隔离。虚拟机启动需要数分钟，而Docker容器可以在数毫秒内启动。由于没有臃肿的从操作系统，Docker可以节省大量的磁盘空间以及其他系统资源。\n说了这么多Docker的优势，大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。虚拟机更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而Docker通常用于隔离不同的应用，例如前端，后端以及数据库。\n1.3 与传统VM特性对比： 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于原生 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 1.4 Docker组件 docker Client客户端————\u003e向docker服务器进程发起请求，如:创建、停止、销毁容器等操作\ndocker Server服务器进程—–\u003e处理所有docker的请求，管理所有容器\ndocker Registry镜像仓库——\u003e镜像存放的中央仓库，可看作是存放二进制的scm\n1.5 Docker的三个概念 镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。 容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。 仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。 二、安装Docker 2.1 Ubuntu 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：\n1 $ sudo apt-get remove docker docker-engine docker.io 使用 APT 安装 1 2 3 $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common Docker CE 镜像源站 使用官方安装脚本自动安装 （仅适用于公网环境） 1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 手动安装帮助 (阿里云ECS可以通过内网安装，见注释部分内容) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # step 1: 安装必要的一些系统工具 sudo apt-get update sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common # step 2: 安装GPG证书 curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # Step 3: 写入软件源信息 sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" # Step 4: 更新并安装 Docker-CE sudo apt-get -y update sudo apt-get -y install docker-ce 注意：其他注意事项在下面的注释中 # 安装指定版本的Docker-CE: # Step 1: 查找Docker-CE的版本: # apt-cache madison docker-ce # docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages # docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages # Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial) # sudo apt-get -y install docker-ce=[VERSION] # 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2、Step 3中的命令 # 经典网络： # curl -fsSL http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" # VPC网络： # curl -fsSL http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # sudo add-apt-repository \"deb [arch=amd64] http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"\t2.2 CentOS 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # step 1: 安装必要的一些系统工具 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 # Step 2: 添加软件源信息 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # Step 3: 更新并安装 Docker-CE sudo yum makecache fast sudo yum -y install docker-ce # Step 4: 开启Docker服务 sudo service docker start 注意：其他注意事项在下面的注释中 # 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。 # vim /etc/yum.repos.d/docker-ce.repo # 将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1 # # 安装指定版本的Docker-CE: # Step 1: 查找Docker-CE的版本: # yum list docker-ce.x86_64 --showduplicates | sort -r # Loading mirror speeds from cached hostfile # Loaded plugins: branch, fastestmirror, langpacks # docker-ce.x86_64 17.03.1.ce-1.el7.centos docker-ce-stable # docker-ce.x86_64 17.03.1.ce-1.el7.centos @docker-ce-stable # docker-ce.x86_64 17.03.0.ce-1.el7.centos docker-ce-stable # Available Packages # Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos) # sudo yum -y install docker-ce-[VERSION] # 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。 # yum list docker-ce-selinux- --showduplicates | sort -r # sudo yum -y install docker-ce-selinux-[VERSION] # 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令 # 经典网络： # sudo yum-config-manager --add-repo http://mirrors.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo # VPC网络： # sudo yum-config-manager --add-repo http://mirrors.could.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo 2.3 安装校验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 root@iZbp12adskpuoxodbkqzjfZ:$ docker version Client: Version: 17.03.0-ce API version: 1.26 Go version: go1.7.5 Git commit: 3a232c8 Built: Tue Feb 28 07:52:04 2017 OS/Arch: linux/amd64 Server: Version: 17.03.0-ce API version: 1.26 (minimum version 1.12) Go version: go1.7.5 Git commit: 3a232c8 Built: Tue Feb 28 07:52:04 2017 OS/Arch: linux/amd64 Experimental: false 三、镜像加速器 网易云加速器 https://hub-mirror.c.163.com\n百度云加速器 https://mirror.baidubce.com\n阿里云加速器(需登录账号获取)\n3.1 Ubuntu 16.04+、Debian 8+、CentOS 7 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\n1 2 3 4 5 6 { \"registry-mirrors\": [ \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\" ] } 之后重新启动服务。\n1 2 $ sudo systemctl daemon-reload $ sudo systemctl restart docker 四、命令整理 4.1 容器操作 1 2 3 4 5 6 7 8 9 docker create # 创建一个容器但是不启动它 docker run # 创建并启动一个容器 docker stop # 停止容器运行，发送信号SIGTERM docker start # 启动一个停止状态的容器 docker restart # 重启一个容器 docker rm # 删除一个容器 docker kill # 发送信号给容器，默认SIGKILL docker attach # 连接(进入)到一个正在运行的容器 docker wait # 阻塞一个容器，直到容器停止运行 4.2 获取容器信息 1 2 3 4 5 6 7 8 docker ps # 显示状态为运行（Up）的容器 docker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited) docker inspect # 深入容器内部获取容器所有信息 docker logs # 查看容器的日志(stdout/stderr) docker events # 得到docker服务器的实时的事件 docker port # 显示容器的端口映射 docker top # 显示容器的进程信息 docker diff # 显示容器文件系统的前后变化 4.3 导出容器 1 2 docker cp # 从容器里向外拷贝文件或目录 docker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息 4.4 执行 1 docker exec # 在容器里执行一个命令，可以执行bash进入交互式 4.5 镜像操作 1 2 3 4 5 6 7 8 9 docker images # 显示本地所有的镜像列表 docker import # 从一个tar包创建一个镜像，往往和export结合使用 docker build # 使用Dockerfile创建镜像（推荐） docker commit # 从容器创建镜像 docker rmi or docker image rm [name:tag] # 删除一个镜像 docker load # 从一个tar包创建一个镜像，和save配合使用 docker save # 将一个镜像保存为一个tar包，带layers和tag信息 docker history # 显示生成一个镜像的历史命令 docker tag # 为镜像起一个别名 4.6 镜像仓库(registry)操作 1 2 3 4 docker login # 登录到一个registry docker search # 从registry仓库搜索镜像 docker pull # 从仓库下载镜像到本地 docker push # 将一个镜像push到registry仓库中 4.7 数据券操作 1 2 3 4 5 # docker -it -v /宿主机绝对路径:/容器内的目录 镜像名称 docker run -it -v /myDataVolume:/dataVolumeContainter centos # docker -it -v /宿主机绝对路径:/容器内的目录:ro 镜像名称 容器内的文件只读权限, 不可以写文件 docker run -it -v /myDataVolume:/dataVolumeContainter:ro centos 五、实例操作 source：https://yeasy.gitbook.io/docker_practice/install/mirror\n现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。\n1 docker run --name webserver -d -p 80:80 nginx 这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。\n如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker Desktop for Mac/Windows，那么可以直接访问：http://localhost；如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。\n直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。\n现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 docker exec 命令进入容器，修改其内容。\n1 2 3 4 $ docker exec -it webserver bash root@3729b97e8226:/# echo 'Hello, Docker!' \u003e /usr/share/nginx/html/index.html root@3729b97e8226:/# exit exit 我们以交互式终端方式进入 webserver 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。\n然后，我们用 Hello, Docker! 覆盖了 /usr/share/nginx/html/index.html 的内容。\n现在我们再刷新浏览器的话，会发现内容被改变了。\n我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff 命令看到具体的改动。\n1 docker diff webserver 现在我们定制好了变化，我们希望能将其保存下来形成镜像。\n要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。\ndocker commit 的语法格式为：\n1 docker commit [选项] \u003c容器ID或容器名\u003e [\u003c仓库名\u003e[:\u003c标签\u003e]] 我们可以用下面的命令将容器保存为镜像：\n1 2 3 4 5 6 $ docker commit \\ --author \"Tao Wang \" \\ --message \"修改了默认网页\" \\ webserver \\ nginx:v2 sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214 其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。\n我们可以在 docker image ls 中看到这个新定制的镜像：\n1 docker images or docker image ls 我们还可以用 docker history 具体查看镜像内的历史记录，如果比较 nginx:latest 的历史记录，我们会发现新增了我们刚刚提交的这一层.\n1 2 3 4 5 6 7 8 9 10 11 $ docker history nginx:v2 IMAGE CREATED CREATED BY SIZE COMMENT 07e334659748 54 seconds ago nginx -g daemon off; 95 B 修改了默认网页 e43d811ce2f4 4 weeks ago /bin/sh -c #(nop) CMD [\"nginx\" \"-g\" \"daemon 0 B 4 weeks ago /bin/sh -c #(nop) EXPOSE 443/tcp 80/tcp 0 B 4 weeks ago /bin/sh -c ln -sf /dev/stdout /var/log/nginx/ 22 B 4 weeks ago /bin/sh -c apt-key adv --keyserver hkp://pgp. 58.46 MB 4 weeks ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.11.5-1 0 B 4 weeks ago /bin/sh -c #(nop) MAINTAINER NGINX Docker Ma 0 B 4 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0 B 4 weeks ago /bin/sh -c #(nop) ADD file:23aa4f893e3288698c 123 MB 新的镜像定制好后，我们可以来运行这个镜像。\n1 docker run --name web2 -d -p 81:80 nginx:v2 这里我们命名为新的服务为 web2，并且映射到 81 端口。如果是 Docker Desktop for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 http://localhost:81 看到结果，其内容应该和之前修改后的 webserver 一样。\n至此，我们第一次完成了定制镜像，使用的是 docker commit 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。\n慎用 docker commit 使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。\n首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。\n此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。\n而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。\n","wordCount":"1096","inLanguage":"en","datePublished":"2022-06-08T11:26:10+08:00","dateModified":"2022-06-08T11:26:10+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/posts/docker%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><meta name=referrer content="no-referrer"><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/posts/>Posts</a></div><h1 class=post-title>Docker笔记</h1><div class=post-meta><span title='2022-06-08 11:26:10 +0800 +0800'>2022-06-08</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e6%a6%82%e8%bf%b0 aria-label=一、概述><strong>一、概述</strong></a><ul><li><a href=#11-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="1.1 基本概念：">1.1 基本概念：</a></li><li><a href=#12-%e5%af%b9%e6%af%94%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%8edocker aria-label="1.2 对比虚拟机与Docker">1.2 对比虚拟机与Docker</a></li><li><a href=#13-%e4%b8%8e%e4%bc%a0%e7%bb%9fvm%e7%89%b9%e6%80%a7%e5%af%b9%e6%af%94 aria-label="1.3 与传统VM特性对比：">1.3 与传统VM特性对比：</a></li><li><a href=#14-docker%e7%bb%84%e4%bb%b6 aria-label="1.4 Docker组件">1.4 Docker组件</a></li><li><a href=#15-docker%e7%9a%84%e4%b8%89%e4%b8%aa%e6%a6%82%e5%bf%b5 aria-label="1.5 Docker的三个概念">1.5 Docker的三个概念</a></li></ul></li><li><a href=#%e4%ba%8c%e5%ae%89%e8%a3%85docker aria-label=二、安装Docker>二、安装Docker</a><ul><li><a href=#21-ubuntu aria-label="2.1 Ubuntu">2.1 Ubuntu</a><ul><li><a href=#%e4%bd%bf%e7%94%a8-apt-%e5%ae%89%e8%a3%85 aria-label="使用 APT 安装">使用 APT 安装</a></li><li><a href=#docker-ce-%e9%95%9c%e5%83%8f%e6%ba%90%e7%ab%99 aria-label="Docker CE 镜像源站">Docker CE 镜像源站</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e5%ae%98%e6%96%b9%e5%ae%89%e8%a3%85%e8%84%9a%e6%9c%ac%e8%87%aa%e5%8a%a8%e5%ae%89%e8%a3%85-%e4%bb%85%e9%80%82%e7%94%a8%e4%ba%8e%e5%85%ac%e7%bd%91%e7%8e%af%e5%a2%83 aria-label="使用官方安装脚本自动安装 （仅适用于公网环境）">使用官方安装脚本自动安装 （仅适用于公网环境）</a></li><li><a href=#%e6%89%8b%e5%8a%a8%e5%ae%89%e8%a3%85%e5%b8%ae%e5%8a%a9-%e9%98%bf%e9%87%8c%e4%ba%91ecs%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e5%86%85%e7%bd%91%e5%ae%89%e8%a3%85%e8%a7%81%e6%b3%a8%e9%87%8a%e9%83%a8%e5%88%86%e5%86%85%e5%ae%b9 aria-label="手动安装帮助 (阿里云ECS可以通过内网安装，见注释部分内容)">手动安装帮助 (阿里云ECS可以通过内网安装，见注释部分内容)</a></li></ul></li></ul></li><li><a href=#22-centos-7 aria-label="2.2 CentOS 7">2.2 CentOS 7</a></li><li><a href=#23-%e5%ae%89%e8%a3%85%e6%a0%a1%e9%aa%8c aria-label="2.3 安装校验">2.3 安装校验</a></li></ul></li><li><a href=#%e4%b8%89%e9%95%9c%e5%83%8f%e5%8a%a0%e9%80%9f%e5%99%a8 aria-label=三、镜像加速器>三、镜像加速器</a><ul><li><a href=#31-ubuntu-1604debian-8centos-7 aria-label="3.1 Ubuntu 16.04+、Debian 8+、CentOS 7">3.1 Ubuntu 16.04+、Debian 8+、CentOS 7</a></li></ul></li><li><a href=#%e5%9b%9b%e5%91%bd%e4%bb%a4%e6%95%b4%e7%90%86 aria-label=四、命令整理>四、命令整理</a><ul><li><a href=#41-%e5%ae%b9%e5%99%a8%e6%93%8d%e4%bd%9c aria-label="4.1 容器操作">4.1 容器操作</a></li><li><a href=#42-%e8%8e%b7%e5%8f%96%e5%ae%b9%e5%99%a8%e4%bf%a1%e6%81%af aria-label="4.2 获取容器信息">4.2 获取容器信息</a></li><li><a href=#43-%e5%af%bc%e5%87%ba%e5%ae%b9%e5%99%a8 aria-label="4.3 导出容器">4.3 导出容器</a></li><li><a href=#44-%e6%89%a7%e8%a1%8c aria-label="4.4 执行">4.4 执行</a></li><li><a href=#45-%e9%95%9c%e5%83%8f%e6%93%8d%e4%bd%9c aria-label="4.5 镜像操作">4.5 镜像操作</a></li><li><a href=#46-%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93registry%e6%93%8d%e4%bd%9c aria-label="4.6 镜像仓库(registry)操作">4.6 镜像仓库(registry)操作</a></li><li><a href=#47-%e6%95%b0%e6%8d%ae%e5%88%b8%e6%93%8d%e4%bd%9c aria-label="4.7 数据券操作">4.7 数据券操作</a></li></ul></li><li><a href=#%e4%ba%94%e5%ae%9e%e4%be%8b%e6%93%8d%e4%bd%9c aria-label=五、实例操作>五、实例操作</a><ul><ul><li><a href=#%e6%85%8e%e7%94%a8-docker-commit aria-label="慎用 docker commit">慎用 <code>docker commit</code></a></li></ul></ul></li></ul></div></details></div><div class=post-content><h2 id=一概述><strong>一、概述</strong><a hidden class=anchor aria-hidden=true href=#一概述>#</a></h2><h3 id=11-基本概念>1.1 基本概念：<a hidden class=anchor aria-hidden=true href=#11-基本概念>#</a></h3><blockquote><p>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。</p></blockquote><h3 id=12-对比虚拟机与docker>1.2 对比虚拟机与Docker<a hidden class=anchor aria-hidden=true href=#12-对比虚拟机与docker>#</a></h3><blockquote><p><strong>Docker守护进程</strong>可以直接与<strong>主操作系统</strong>进行通信，为各个<strong>Docker容器</strong>分配资源；它还可以将容器与<strong>主操作系统</strong>隔离，并将各个容器互相隔离。<strong>虚拟机</strong>启动需要数分钟，而<strong>Docker容器</strong>可以在数毫秒内启动。由于没有臃肿的<strong>从操作系统</strong>，Docker可以节省大量的磁盘空间以及其他系统资源。</p><p>说了这么多Docker的优势，大家也没有必要完全否定<strong>虚拟机</strong>技术，因为两者有不同的使用场景。<strong>虚拟机</strong>更擅长于彻底隔离整个运行环境。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而<strong>Docker</strong>通常用于隔离不同的应用，例如<strong>前端</strong>，<strong>后端</strong>以及<strong>数据库</strong>。</p></blockquote><h3 id=13-与传统vm特性对比>1.3 与传统VM特性对比：<a hidden class=anchor aria-hidden=true href=#13-与传统vm特性对比>#</a></h3><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr><tr><td>隔离性</td><td>安全隔离</td><td>完全隔离</td></tr></tbody></table><h3 id=14-docker组件>1.4 Docker组件<a hidden class=anchor aria-hidden=true href=#14-docker组件>#</a></h3><blockquote><p>docker Client客户端————>向docker服务器进程发起请求，如:创建、停止、销毁容器等操作</p><p>docker Server服务器进程—–>处理所有docker的请求，管理所有容器</p><p>docker Registry镜像仓库——>镜像存放的中央仓库，可看作是存放二进制的scm</p></blockquote><h3 id=15-docker的三个概念>1.5 Docker的三个概念<a hidden class=anchor aria-hidden=true href=#15-docker的三个概念>#</a></h3><ol><li>镜像（Image）：类似于虚拟机中的镜像，是一个包含有文件系统的面向Docker引擎的只读模板。任何应用程序运行都需要环境，而镜像就是用来提供这种运行环境的。例如一个Ubuntu镜像就是一个包含Ubuntu操作系统环境的模板，同理在该镜像上装上Apache软件，就可以称为Apache镜像。</li><li>容器（Container）：类似于一个轻量级的沙盒，可以将其看作一个极简的Linux系统环境（包括root权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序。Docker引擎利用容器来运行、隔离各个应用。容器是镜像创建的应用实例，可以创建、启动、停止、删除容器，各个容器之间是是相互隔离的，互不影响。注意：镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。</li><li>仓库（Repository）：类似于代码仓库，这里是镜像仓库，是Docker用来集中存放镜像文件的地方。注意与注册服务器（Registry）的区别：注册服务器是存放仓库的地方，一般会有多个仓库；而仓库是存放镜像的地方，一般每个仓库存放一类镜像，每个镜像利用tag进行区分，比如Ubuntu仓库存放有多个版本（12.04、14.04等）的Ubuntu镜像。</li></ol><h2 id=二安装docker>二、安装Docker<a hidden class=anchor aria-hidden=true href=#二安装docker>#</a></h2><h3 id=21-ubuntu>2.1 Ubuntu<a hidden class=anchor aria-hidden=true href=#21-ubuntu>#</a></h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo apt-get remove docker docker-engine docker.io
</span></span></code></pre></td></tr></table></div></div><h4 id=使用-apt-安装>使用 APT 安装<a hidden class=anchor aria-hidden=true href=#使用-apt-安装>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sudo apt-get update
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
</span></span></code></pre></td></tr></table></div></div><h4 id=docker-ce-镜像源站>Docker CE 镜像源站<a hidden class=anchor aria-hidden=true href=#docker-ce-镜像源站>#</a></h4><h5 id=使用官方安装脚本自动安装-仅适用于公网环境>使用官方安装脚本自动安装 （仅适用于公网环境）<a hidden class=anchor aria-hidden=true href=#使用官方安装脚本自动安装-仅适用于公网环境>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>curl -fsSL https://get.docker.com <span class=p>|</span> bash -s docker --mirror Aliyun
</span></span></code></pre></td></tr></table></div></div><h5 id=手动安装帮助-阿里云ecs可以通过内网安装见注释部分内容>手动安装帮助 (阿里云ECS可以通过内网安装，见注释部分内容)<a hidden class=anchor aria-hidden=true href=#手动安装帮助-阿里云ecs可以通过内网安装见注释部分内容>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># step 1: 安装必要的一些系统工具</span>
</span></span><span class=line><span class=cl>sudo apt-get update
</span></span><span class=line><span class=cl>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
</span></span><span class=line><span class=cl><span class=c1># step 2: 安装GPG证书</span>
</span></span><span class=line><span class=cl>curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg <span class=p>|</span> sudo apt-key add -
</span></span><span class=line><span class=cl><span class=c1># Step 3: 写入软件源信息</span>
</span></span><span class=line><span class=cl>sudo add-apt-repository <span class=s2>&#34;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu </span><span class=k>$(</span>lsb_release -cs<span class=k>)</span><span class=s2> stable&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># Step 4: 更新并安装 Docker-CE</span>
</span></span><span class=line><span class=cl>sudo apt-get -y update
</span></span><span class=line><span class=cl>sudo apt-get -y install docker-ce
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>注意：其他注意事项在下面的注释中
</span></span><span class=line><span class=cl><span class=c1># 安装指定版本的Docker-CE:</span>
</span></span><span class=line><span class=cl><span class=c1># Step 1: 查找Docker-CE的版本:</span>
</span></span><span class=line><span class=cl><span class=c1># apt-cache madison docker-ce</span>
</span></span><span class=line><span class=cl><span class=c1>#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span>
</span></span><span class=line><span class=cl><span class=c1>#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span>
</span></span><span class=line><span class=cl><span class=c1># Step 2: 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)</span>
</span></span><span class=line><span class=cl><span class=c1># sudo apt-get -y install docker-ce=[VERSION]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2、Step 3中的命令</span>
</span></span><span class=line><span class=cl><span class=c1># 经典网络：</span>
</span></span><span class=line><span class=cl><span class=c1># curl -fsSL http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span>
</span></span><span class=line><span class=cl><span class=c1># sudo add-apt-repository &#34;deb [arch=amd64] http://mirrors.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># VPC网络：</span>
</span></span><span class=line><span class=cl><span class=c1># curl -fsSL http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span>
</span></span><span class=line><span class=cl><span class=c1># sudo add-apt-repository &#34;deb [arch=amd64] http://mirrors.cloud.aliyuncs.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&#34;		</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=22-centos-7>2.2 CentOS 7<a hidden class=anchor aria-hidden=true href=#22-centos-7>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># step 1: 安装必要的一些系统工具</span>
</span></span><span class=line><span class=cl>sudo yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span><span class=line><span class=cl><span class=c1># Step 2: 添加软件源信息</span>
</span></span><span class=line><span class=cl>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</span></span><span class=line><span class=cl><span class=c1># Step 3: 更新并安装 Docker-CE</span>
</span></span><span class=line><span class=cl>sudo yum makecache fast
</span></span><span class=line><span class=cl>sudo yum -y install docker-ce
</span></span><span class=line><span class=cl><span class=c1># Step 4: 开启Docker服务</span>
</span></span><span class=line><span class=cl>sudo service docker start
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>注意：其他注意事项在下面的注释中
</span></span><span class=line><span class=cl><span class=c1># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。</span>
</span></span><span class=line><span class=cl><span class=c1># vim /etc/yum.repos.d/docker-ce.repo</span>
</span></span><span class=line><span class=cl><span class=c1>#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># 安装指定版本的Docker-CE:</span>
</span></span><span class=line><span class=cl><span class=c1># Step 1: 查找Docker-CE的版本:</span>
</span></span><span class=line><span class=cl><span class=c1># yum list docker-ce.x86_64 --showduplicates | sort -r</span>
</span></span><span class=line><span class=cl><span class=c1>#   Loading mirror speeds from cached hostfile</span>
</span></span><span class=line><span class=cl><span class=c1>#   Loaded plugins: branch, fastestmirror, langpacks</span>
</span></span><span class=line><span class=cl><span class=c1>#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span>
</span></span><span class=line><span class=cl><span class=c1>#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span>
</span></span><span class=line><span class=cl><span class=c1>#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span>
</span></span><span class=line><span class=cl><span class=c1>#   Available Packages</span>
</span></span><span class=line><span class=cl><span class=c1># Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)</span>
</span></span><span class=line><span class=cl><span class=c1># sudo yum -y install docker-ce-[VERSION]</span>
</span></span><span class=line><span class=cl><span class=c1># 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。</span>
</span></span><span class=line><span class=cl><span class=c1># yum list docker-ce-selinux- --showduplicates | sort -r</span>
</span></span><span class=line><span class=cl><span class=c1># sudo yum -y install docker-ce-selinux-[VERSION]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令</span>
</span></span><span class=line><span class=cl><span class=c1># 经典网络：</span>
</span></span><span class=line><span class=cl><span class=c1># sudo yum-config-manager --add-repo http://mirrors.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo</span>
</span></span><span class=line><span class=cl><span class=c1># VPC网络：</span>
</span></span><span class=line><span class=cl><span class=c1># sudo yum-config-manager --add-repo http://mirrors.could.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=23-安装校验>2.3 安装校验<a hidden class=anchor aria-hidden=true href=#23-安装校验>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@iZbp12adskpuoxodbkqzjfZ:$ docker version
</span></span><span class=line><span class=cl>Client:
</span></span><span class=line><span class=cl> Version:      17.03.0-ce
</span></span><span class=line><span class=cl> API version:  1.26
</span></span><span class=line><span class=cl> Go version:   go1.7.5
</span></span><span class=line><span class=cl> Git commit:   3a232c8
</span></span><span class=line><span class=cl> Built:        Tue Feb <span class=m>28</span> 07:52:04 <span class=m>2017</span>
</span></span><span class=line><span class=cl> OS/Arch:      linux/amd64
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Server:
</span></span><span class=line><span class=cl> Version:      17.03.0-ce
</span></span><span class=line><span class=cl> API version:  1.26 <span class=o>(</span>minimum version 1.12<span class=o>)</span>
</span></span><span class=line><span class=cl> Go version:   go1.7.5
</span></span><span class=line><span class=cl> Git commit:   3a232c8
</span></span><span class=line><span class=cl> Built:        Tue Feb <span class=m>28</span> 07:52:04 <span class=m>2017</span>
</span></span><span class=line><span class=cl> OS/Arch:      linux/amd64
</span></span><span class=line><span class=cl> Experimental: <span class=nb>false</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=三镜像加速器>三、镜像加速器<a hidden class=anchor aria-hidden=true href=#三镜像加速器>#</a></h2><p><a href=https://www.163yun.com/help/documents/56918246390157312>网易云加速器 <code>https://hub-mirror.c.163.com</code></a></p><p><a href=https://cloud.baidu.com/doc/CCE/s/Yjxppt74z#%E4%BD%BF%E7%94%A8dockerhub%E5%8A%A0%E9%80%9F%E5%99%A8>百度云加速器 <code>https://mirror.baidubce.com</code></a></p><p><a href=https://cr.console.aliyun.com/cn-hangzhou/mirrors>阿里云加速器(需登录账号获取)</a></p><h3 id=31-ubuntu-1604debian-8centos-7>3.1 Ubuntu 16.04+、Debian 8+、CentOS 7<a hidden class=anchor aria-hidden=true href=#31-ubuntu-1604debian-8centos-7>#</a></h3><p>对于使用 <a href=https://www.freedesktop.org/wiki/Software/systemd/>systemd</a> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;registry-mirrors&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;https://hub-mirror.c.163.com&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;https://mirror.baidubce.com&#34;</span>
</span></span><span class=line><span class=cl>  <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>之后重新启动服务。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo systemctl daemon-reload
</span></span><span class=line><span class=cl>$ sudo systemctl restart docker
</span></span></code></pre></td></tr></table></div></div><h2 id=四命令整理>四、命令整理<a hidden class=anchor aria-hidden=true href=#四命令整理>#</a></h2><h3 id=41-容器操作>4.1 容器操作<a hidden class=anchor aria-hidden=true href=#41-容器操作>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker create <span class=c1># 创建一个容器但是不启动它</span>
</span></span><span class=line><span class=cl>docker run <span class=c1># 创建并启动一个容器</span>
</span></span><span class=line><span class=cl>docker stop <span class=c1># 停止容器运行，发送信号SIGTERM</span>
</span></span><span class=line><span class=cl>docker start <span class=c1># 启动一个停止状态的容器</span>
</span></span><span class=line><span class=cl>docker restart <span class=c1># 重启一个容器</span>
</span></span><span class=line><span class=cl>docker rm <span class=c1># 删除一个容器</span>
</span></span><span class=line><span class=cl>docker <span class=nb>kill</span> <span class=c1># 发送信号给容器，默认SIGKILL</span>
</span></span><span class=line><span class=cl>docker attach <span class=c1># 连接(进入)到一个正在运行的容器</span>
</span></span><span class=line><span class=cl>docker <span class=nb>wait</span> <span class=c1># 阻塞一个容器，直到容器停止运行</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=42-获取容器信息>4.2 获取容器信息<a hidden class=anchor aria-hidden=true href=#42-获取容器信息>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker ps <span class=c1># 显示状态为运行（Up）的容器</span>
</span></span><span class=line><span class=cl>docker ps -a <span class=c1># 显示所有容器,包括运行中（Up）的和退出的(Exited)</span>
</span></span><span class=line><span class=cl>docker inspect <span class=c1># 深入容器内部获取容器所有信息</span>
</span></span><span class=line><span class=cl>docker logs <span class=c1># 查看容器的日志(stdout/stderr)</span>
</span></span><span class=line><span class=cl>docker events <span class=c1># 得到docker服务器的实时的事件</span>
</span></span><span class=line><span class=cl>docker port <span class=c1># 显示容器的端口映射</span>
</span></span><span class=line><span class=cl>docker top <span class=c1># 显示容器的进程信息</span>
</span></span><span class=line><span class=cl>docker diff <span class=c1># 显示容器文件系统的前后变化</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=43-导出容器>4.3 导出容器<a hidden class=anchor aria-hidden=true href=#43-导出容器>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker cp <span class=c1># 从容器里向外拷贝文件或目录</span>
</span></span><span class=line><span class=cl>docker <span class=nb>export</span> <span class=c1># 将容器整个文件系统导出为一个tar包，不带layers、tag等信息</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=44-执行>4.4 执行<a hidden class=anchor aria-hidden=true href=#44-执行>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker <span class=nb>exec</span> <span class=c1># 在容器里执行一个命令，可以执行bash进入交互式</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=45-镜像操作>4.5 镜像操作<a hidden class=anchor aria-hidden=true href=#45-镜像操作>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker images <span class=c1># 显示本地所有的镜像列表</span>
</span></span><span class=line><span class=cl>docker import <span class=c1># 从一个tar包创建一个镜像，往往和export结合使用</span>
</span></span><span class=line><span class=cl>docker build <span class=c1># 使用Dockerfile创建镜像（推荐）</span>
</span></span><span class=line><span class=cl>docker commit <span class=c1># 从容器创建镜像</span>
</span></span><span class=line><span class=cl>docker rmi or docker image rm <span class=o>[</span>name:tag<span class=o>]</span> <span class=c1># 删除一个镜像</span>
</span></span><span class=line><span class=cl>docker load <span class=c1># 从一个tar包创建一个镜像，和save配合使用</span>
</span></span><span class=line><span class=cl>docker save <span class=c1># 将一个镜像保存为一个tar包，带layers和tag信息</span>
</span></span><span class=line><span class=cl>docker <span class=nb>history</span> <span class=c1># 显示生成一个镜像的历史命令</span>
</span></span><span class=line><span class=cl>docker tag <span class=c1># 为镜像起一个别名</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=46-镜像仓库registry操作>4.6 镜像仓库(registry)操作<a hidden class=anchor aria-hidden=true href=#46-镜像仓库registry操作>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker login <span class=c1># 登录到一个registry</span>
</span></span><span class=line><span class=cl>docker search <span class=c1># 从registry仓库搜索镜像</span>
</span></span><span class=line><span class=cl>docker pull <span class=c1># 从仓库下载镜像到本地</span>
</span></span><span class=line><span class=cl>docker push <span class=c1># 将一个镜像push到registry仓库中</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=47-数据券操作>4.7 数据券操作<a hidden class=anchor aria-hidden=true href=#47-数据券操作>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># docker -it -v /宿主机绝对路径:/容器内的目录 镜像名称</span>
</span></span><span class=line><span class=cl>docker run -it -v /myDataVolume:/dataVolumeContainter centos
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># docker -it -v /宿主机绝对路径:/容器内的目录:ro 镜像名称  容器内的文件只读权限, 不可以写文件</span>
</span></span><span class=line><span class=cl>docker run -it -v /myDataVolume:/dataVolumeContainter:ro centos
</span></span></code></pre></td></tr></table></div></div><h2 id=五实例操作>五、实例操作<a hidden class=anchor aria-hidden=true href=#五实例操作>#</a></h2><blockquote><p>source：https://yeasy.gitbook.io/docker_practice/install/mirror</p></blockquote><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker run --name webserver -d -p 80:80 nginx
</span></span></code></pre></td></tr></table></div></div><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker Desktop for Mac/Windows，那么可以直接访问：<a href=http://localhost/>http://localhost</a>；如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker <span class=nb>exec</span> -it webserver bash
</span></span><span class=line><span class=cl>root@3729b97e8226:/# <span class=nb>echo</span> <span class=s1>&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span><span class=line><span class=cl>root@3729b97e8226:/# <span class=nb>exit</span>
</span></span><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></td></tr></table></div></div><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>Hello, Docker!</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker diff webserver
</span></span></code></pre></td></tr></table></div></div><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker commit <span class=o>[</span>选项<span class=o>]</span> &lt;容器ID或容器名&gt; <span class=o>[</span>&lt;仓库名&gt;<span class=o>[</span>:&lt;标签&gt;<span class=o>]]</span>
</span></span></code></pre></td></tr></table></div></div><p>我们可以用下面的命令将容器保存为镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker commit <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --author <span class=s2>&#34;Tao Wang &lt;twang2218@gmail.com&gt;&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --message <span class=s2>&#34;修改了默认网页&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    webserver <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:v2
</span></span><span class=line><span class=cl>sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214
</span></span></code></pre></td></tr></table></div></div><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker images or docker image ls
</span></span></code></pre></td></tr></table></div></div><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker <span class=nb>history</span> nginx:v2
</span></span><span class=line><span class=cl>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
</span></span><span class=line><span class=cl>07e334659748        <span class=m>54</span> seconds ago      nginx -g daemon off<span class=p>;</span>                            <span class=m>95</span> B                修改了默认网页
</span></span><span class=line><span class=cl>e43d811ce2f4        <span class=m>4</span> weeks ago         /bin/sh -c <span class=c1>#(nop)  CMD [&#34;nginx&#34; &#34;-g&#34; &#34;daemon    0 B</span>
</span></span><span class=line><span class=cl>&lt;missing&gt;           <span class=m>4</span> weeks ago         /bin/sh -c <span class=c1>#(nop)  EXPOSE 443/tcp 80/tcp        0 B</span>
</span></span><span class=line><span class=cl>&lt;missing&gt;           <span class=m>4</span> weeks ago         /bin/sh -c ln -sf /dev/stdout /var/log/nginx/   <span class=m>22</span> B
</span></span><span class=line><span class=cl>&lt;missing&gt;           <span class=m>4</span> weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   58.46 MB
</span></span><span class=line><span class=cl>&lt;missing&gt;           <span class=m>4</span> weeks ago         /bin/sh -c <span class=c1>#(nop)  ENV NGINX_VERSION=1.11.5-1   0 B</span>
</span></span><span class=line><span class=cl>&lt;missing&gt;           <span class=m>4</span> weeks ago         /bin/sh -c <span class=c1>#(nop)  MAINTAINER NGINX Docker Ma   0 B</span>
</span></span><span class=line><span class=cl>&lt;missing&gt;           <span class=m>4</span> weeks ago         /bin/sh -c <span class=c1>#(nop)  CMD [&#34;/bin/bash&#34;]            0 B</span>
</span></span><span class=line><span class=cl>&lt;missing&gt;           <span class=m>4</span> weeks ago         /bin/sh -c <span class=c1>#(nop) ADD file:23aa4f893e3288698c   123 MB</span>
</span></span></code></pre></td></tr></table></div></div><p>新的镜像定制好后，我们可以来运行这个镜像。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>docker run --name web2 -d -p 81:80 nginx:v2
</span></span></code></pre></td></tr></table></div></div><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker Desktop for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href=http://localhost:81/>http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h4 id=慎用-docker-commit>慎用 <code>docker commit</code><a hidden class=anchor aria-hidden=true href=#慎用-docker-commit>#</a></h4><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/tags/docker/>Docker</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/posts/dockerfile%E6%A1%88%E4%BE%8B/><span class=title>« Prev</span><br><span>Dockerfile案例</span></a>
<a class=next href=https://reid00.github.io/posts/unicode%E7%BC%96%E7%A0%81%E4%B8%8Epython/><span class=title>Next »</span><br><span>Unicode编码与Python</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://reid00.github.io/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>