<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>操作系统之文件系统 | Reid's Blog</title><meta name=keywords content="文件系统,FS,Inode"><meta name=description content="操作系统之文件系统"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK",{anonymize_ip:!1})}</script><meta property="og:title" content="操作系统之文件系统"><meta property="og:description" content="操作系统之文件系统"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-23T14:04:18+08:00"><meta property="article:modified_time" content="2023-04-23T14:04:18+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="操作系统之文件系统"><meta name=twitter:description content="操作系统之文件系统"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/posts/"},{"@type":"ListItem","position":2,"name":"操作系统，网络编程，架构相关的文章","item":"https://reid00.github.io/posts/os_network/"},{"@type":"ListItem","position":3,"name":"操作系统之文件系统","item":"https://reid00.github.io/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"操作系统之文件系统","name":"操作系统之文件系统","description":"操作系统之文件系统","keywords":["文件系统","FS","Inode"],"articleBody":"文件系统 文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。\n文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。\nLinux 最经典的一句话是：「一切皆文件」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。\nLinux 文件系统会为每个文件分配两个数据结构：Inode（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。\nInode，也就是inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。Inode是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以Inode同样占用磁盘空间。\n目录项，也就是dentry，用来记录文件的名字、Inode指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与Inode不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。\n由于Inode唯一标识一个文件，而目录项记录着文件的名，所以目录项和Inode的关系是多对一，也就是说，一个文件可以有多个目录。比如，硬链接的实现就是多个目录项中的Inode指向同一个文件。\n注意，目录也是文件，也是用Inode唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。\n目录项和目录是一个东西吗？ 虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。\n如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。\n注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。\n##　文件数据是如何存储在磁盘的呢？ 磁盘读写的最小单位是扇区，扇区的大小只有 512字节，那么如果数据大于512字节时候，磁盘需要不停地移动磁头来查找数据，我们知道一般的文件很容易超过512字节那么如果把多个扇区合并为一个块，那么磁盘就可以提高效率了。那么磁头一次读取多个扇区就为一个块“block”（Linux上称为块，Windows上称为簇）。所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。 sector size \u003c= block size \u003c= memory page size\n文件系统记录的数据，除了其自身外，还有数据的权限信息，所有者等属性，这些信息都保存在inode中，那么谁来记录inode信息和文件系统本身的信息呢，比如说文件系统的格式，inode与data的数量呢？那么就有一个超级区块（supper block）来记录这些信息了。\nsuperblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等 inode：记录文件的属性信息，可以使用stat命令查看inode信息。 block：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个block，但是一个块只能存放一个文件。（因为数据是由inode指向的，如果有两个文件的数据存放在同一个块中，就会乱套了） Inode用来指向数据block，那么只要找到inode，再由inode找到block编号，那么实际数据就能找出来了。\nInode是存储在硬盘上的数据，为了加速文件的访问，通常会把Inode加载到内存中。我们不可能把超级块和Inode区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：\n超级块：当文件系统挂载时进入内存； Inode区：当文件被访问时进入内存； 虚拟文件系统 文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图： Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：\n磁盘的文件系统，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。 内存的文件系统，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的/proc 和 /sys 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。 网络的文件系统，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。 文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。\nLinux 采用为分层的体系结构，将用户接口层、文件系统实现和存储设备的驱动程序分隔开，进而兼容不同的文件系统。虚拟文件系统（Virtual File System, VFS）是 Linux 内核中的软件层，它在内核中提供了一组标准的、抽象的文件操作，允许不同的文件系统实现共存，并向用户空间程序提供统一的文件系统接口。下面这张图展示了 Linux 虚拟文件系统的整体结构： 从上图可以看出，用户空间的应用程序直接、或是通过编程语言提供的库函数间接调用内核提供的 System Call 接口（如open()、write()等）执行文件操作。System Call 接口再将应用程序的参数传递给虚拟文件系统进行处理。\n每个文件系统都为 VFS 实现了一组通用接口，具体的文件系统根据自己对磁盘上数据的组织方式操作相应的数据。当应用程序操作某个文件时，VFS 会根据文件路径找到相应的挂载点，得到具体的文件系统信息，然后调用该文件系统的对应操作函数。\nVFS 提供了两个针对文件系统对象的缓存 INode Cache 和 DEntry Cache，它们缓存最近使用过的文件系统对象，用来加快对 INode 和 DEntry 的访问。Linux 内核还提供了 Buffer Cache 缓冲区，用来缓存文件系统和相关块设备之间的请求，减少访问物理设备的次数，加快访问速度。Buffer Cache 以 LRU 列表的形式管理缓冲区。\nVFS 的好处是实现了应用程序的文件操作与具体的文件系统的解耦，使得编程更加容易：\n应用层程序只要使用 VFS 对外提供的read()、write()等接口就可以执行文件操作，不需要关心底层文件系统的实现细节； 文件系统只需要实现 VFS 接口就可以兼容 Linux，方便移植与维护； 无需关注具体的实现细节，就实现跨文件系统的文件操作。 了解 Linux 文件系统的整体结构后，下面主要分析 Linux VFS 的技术原理。由于文件系统与设备驱动的实现非常复杂，笔者也未接触过这方面的内容，因此文中不会涉及具体文件系统的实现。\nVFS 接口 Linux 以一组通用对象的角度看待所有文件系统，每一级对象之间的关系如下图所示： fd 和 file 每个进程都持有一个fd[]数组，数组里面存放的是指向file结构体的指针，同一进程的不同fd可以指向同一个file对象；\nfile是内核中的数据结构，表示一个被进程打开的文件，和进程相关联。当应用程序调用open()函数的时候，VFS 就会创建相应的file对象。它会保存打开文件的状态，例如文件权限、路径、偏移量等等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L936 结构体已删减 struct file { struct path f_path; struct inode *f_inode; const struct file_operations *f_op; unsigned int f_flags; fmode_t f_mode; loff_t f_pos; struct fown_struct f_owner; } // https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/path.h#L8 struct path { struct vfsmount *mnt; struct dentry *dentry; } 从上面的代码可以看出，文件的路径实际上是一个指向 DEntry 结构体的指针，VFS 通过 DEntry 索引到文件的位置。\n除了文件偏移量f_pos是进程私有的数据外，其他的数据都来自于 INode 和 DEntry，和所有进程共享。不同进程的file对象可以指向同一个 DEntry 和 Inode，从而实现文件的共享。\nDEntry Inode Linux文件系统会为每个文件都分配两个数据结构，目录项（DEntry, Directory Entry）和索引节点（INode, Index Node）。\nDEntry 用来保存文件路径和 INode 之间的映射，从而支持在文件系统中移动。DEntry 由 VFS 维护，所有文件系统共享，不和具体的进程关联。dentry对象从根目录“/”开始，每个dentry对象都会持有自己的子目录和文件，这样就形成了文件树。举例来说，如果要访问”/home/beihai/a.txt”文件并对他操作，系统会解析文件路径，首先从“/”根目录的dentry对象开始访问，然后找到”home/“目录，其次是“beihai/”，最后找到“a.txt”的dentry结构体，该结构体里面d_inode字段就对应着该文件。\n1 2 3 4 5 6 7 8 // https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/dcache.h#L89 结构体已删减 struct dentry { struct dentry *d_parent; // 父目录 struct qstr d_name; // 文件名称 struct inode *d_inode; // 关联的 inode struct list_head d_child; // 父目录中的子目录和文件 struct list_head d_subdirs; // 当前目录中的子目录和文件 } 每一个dentry对象都持有一个对应的inode对象，表示 Linux 中一个具体的目录项或文件。INode 包含管理文件系统中的对象所需的所有元数据，以及可以在该文件对象上执行的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L628 结构体已删减 struct inode { umode_t i_mode; // 文件权限及类型 kuid_t i_uid; // user id kgid_t i_gid; // group id const struct inode_operations *i_op; // inode 操作函数，如 create，mkdir，lookup，rename 等 struct super_block *i_sb; // 所属的 SuperBlock loff_t i_size; // 文件大小 struct timespec i_atime; // 文件最后访问时间 struct timespec i_mtime; // 文件最后修改时间 struct timespec i_ctime; // 文件元数据最后修改时间（包括文件名称） const struct file_operations *i_fop; // 文件操作函数，open、write 等 void *i_private; // 文件系统的私有数据 } 虚拟文件系统维护了一个 DEntry Cache 缓存，用来保存最近使用的 DEntry，加速查询操作。当调用open()函数打开一个文件时，内核会第一时间根据文件路径到 DEntry Cache 里面寻找相应的 DEntry，找到了就直接构造一个file对象并返回。如果该文件不在缓存中，那么 VFS 会根据找到的最近目录一级一级地向下加载，直到找到相应的文件。期间 VFS 会缓存所有被加载生成的dentry。\nINode 存储的数据存放在磁盘上，由具体的文件系统进行组织，当需要访问一个 INode 时，会由文件系统从磁盘上加载相应的数据并构造 INode。一个 INode 可能被多个 DEntry 所关联，即相当于为某一文件创建了多个文件路径（通常是为文件建立硬链接）。\nSuperBlock SuperBlock 表示特定加载的文件系统，用于描述和维护文件系统的状态，由 VFS 定义，但里面的数据根据具体的文件系统填充。每个 SuperBlock 代表了一个具体的磁盘分区，里面包含了当前磁盘分区的信息，如文件系统类型、剩余空间等。SuperBlock 的一个重要成员是链表s_list，包含所有修改过的 INode，使用该链表很容易区分出来哪个文件被修改过，并配合内核线程将数据写回磁盘。SuperBlock 的另一个重要成员是s_op，定义了针对其 INode 的所有操作方法，例如标记、释放索引节点等一系列操作。\n1 2 3 4 5 6 7 8 9 10 11 // https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L1425 结构体已删减 struct super_block { struct list_head s_list; // 指向链表的指针 dev_t s_dev; // 设备标识符 unsigned long s_blocksize; // 以字节为单位的块大小 loff_t s_maxbytes; // 文件大小上限 struct file_system_type *s_type; // 文件系统类型 const struct super_operations *s_op; // SuperBlock 操作函数，write_inode、put_inode 等 const struct dquot_operations *dq_op; // 磁盘限额函数 struct dentry *s_root; // 根目录 } SuperBlock 是一个非常复杂的结构，通过 SuperBlock 我们可以将一个实体文件系统挂载到 Linux 上，或者对 INode 进行增删改查操作。所以一般文件系统都会在磁盘上存储多份 SuperBlock，防止数据意外损坏导致整个分区无法读取。\nInode Inode包含很多的文件元信息，但不包含文件名，例如：字节数、属主UserID、属组GroupID、读写执行权限、时间戳等。而文件名存放在目录当中，但Linux系统内部不使用文件名，而是使用inode号码识别文件。对于系统来说文件名只是inode号码便于识别的别称。\nStat 查看Inode\n1 2 3 4 5 6 7 8 9 10 11 12 [root@localhost ~]# mkdir test [root@localhost ~]# echo \"this is test file\" \u003e test.txt [root@localhost ~]# stat test.txt File: ‘test.txt’ Size: 18 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 33574994 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Context: unconfined_u:object_r:admin_home_t:s0 Access: 2019-08-28 19:55:05.920240744 +0800 Modify: 2019-08-28 19:55:05.920240744 +0800 Change: 2019-08-28 19:55:05.920240744 +0800 Birth: - 三个主要的时间属性：\nctime：change time是最后一次改变文件或目录（属性）的时间，例如执行chmod，chown等命令。 atime：access time是最后一次访问文件或目录的时间。 mtime：modify time是最后一次修改文件或目录（内容）的时间。 file 1 2 3 4 [root@localhost ~]# file test test: directory [root@localhost ~]# file test.txt test.txt: ASCII text Inode Number 表面上，用户通过文件名打开文件，实际上，系统内部将这个过程分为三步：\n系统找到这个文件名对应的inode号码； 通过inode号码，获取inode信息； 根据inode信息，找到文件数据所在的block，并读出数据。 其实系统还要根据inode信息，看用户是否具有访问的权限，有就指向对应的数据block，没有就返回权限拒绝。\n直接查看文件i节点号，也可以通过stat查看文件inode信息查看i节点号。\n1 2 [root@localhost ~]# ls -i 33574991 anaconda-ks.cfg 2086 test 33574994 test.txt Inode 大小 inode也会消耗硬盘空间，所以格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区，存放inode所包含的信息。每个inode的大小，一般是128字节或256字节。通常情况下不需要关注单个inode的大小，而是需要重点关注inode总数。inode总数在格式化的时候就确定了。\ndf -i 查看硬盘分区的inode总数和已使用情况\n1 2 3 4 5 6 7 8 9 10 11 [root@***]# df -i Filesystem Inodes IUsed IFree IUse% Mounted on devtmpfs 16219999 413 16219586 1% /dev tmpfs 16222589 2 16222587 1% /dev/shm tmpfs 16222589 602 16221987 1% /run tmpfs 16222589 16 16222573 1% /sys/fs/cgroup /dev/vda1 2621440 122606 2498834 5% / /dev/vdb1 131072000 134633 130937367 1% /mnt tmpfs 16222589 22 16222567 1% /run/user/0 overlay 2621440 122606 2498834 5% /var/lib/docker/overlay2/2e836ead8a69c7413ec89faecf1357479a6df9ba1e515056d9c89bb121e6fba1/merged shm 16222589 1 16222588 1% /var/lib/docker/containers/1713b72ff979243ef1d36d0a5aaf6c79989a75b267531d341665a7e432fd5a09/shm 文件的读写 文件系统在打开一个文件时，要做的有：\n系统找到这个文件名对应的inode：在目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 号 通过inode号，获取到磁盘中的inode信息，其中最重要的内容是磁盘地址表 通过inode信息中的磁盘地址表，文件系统把分散存放的文件物理块链接成文件的逻辑结构。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。找到文件数据所在的block，读出数据。 根据以上流程，我们可以发现，inode应该是有一个专门的存储区域的，以方便系统快速查找。事实上，一块磁盘创建的时候，操作系统自动将硬盘分成两个区域：存放文件数据的数据区，与存放inode信息的inode区（inode table）。\n每个inode的大小一般是128B或者256B。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。\n也就是说，每个分区的inode总数从格式化之后就固定了，因此有可能会出现存储空间没有占满，但因为小文件太多而耗尽了inode的情况。这个时候就只能清除inode占用高的文件或者目录或修改inode数量了，当然，inode的调整需要重新格式化磁盘，需要确保数据已经得到有效备份后，再进行此操作。\n这时候又产生了新的问题：文件创建时要为文件分配哪一个inode号呢？即如何保证分配的inode号没有被占用？ 既然是”是否被占用”的问题，使用位图是最佳方案，像bmap记录block的占用情况一样。标识inode号是否被分配的位图称为inodemap简称为imap。这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。\n(位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。) 类似bmap块位图一样，inode号是预先规划好的。inode号分配后，文件删除也会释放inode号。分配和释放的inode号，像是在一个地图上挖掉一块，用完再补回来一样。 imap存在着和bmap和inode table一样需要解决的问题：如果文件系统比较大，imap本身就会很大，每次存储文件都要进行扫描，会导致效率不够高。同样，优化的方式是将文件系统占用的block划分成块组，每个块组有自己的imap范围，以减少检索时间。\n文件系统使用block group来组织block的原因有以下几点：\n把每个区进一步分为多个块组 (block group)，每个块组有独立的inode/block体系 如果文件系统高达数百 GB 时，把所有的 inode 和block 通通放在一起会因为 inode 和 block的数量太庞大，不容易管理 这其实很好理解，因为分区是用户的分区，实际计算机管理时还有个最适合的大小，于是计算机会进一步的在分区中分块 （但这样岂不是可能出现大文件放不了的问题？有什么机制善后吗？） 每个块组实际还会分为分为6个部分，除了inode table 和 data block外还有4个附属模块，起到优化和完善系统性能的作用 利用df -i命令可以查看inode数量方面的信息\n文件操作 系统对文件的操作会可能影响inode：\n复制：创建一个包含全部数据与新inode号的新文件 移动：在同一磁盘下移动时，所在目录改变，inode号与实际数据存储的块的位置都不会变化。跨磁盘移动当然会删除本磁盘的数据并创建一条新的数据在另一块磁盘中。 硬链接： 同一个inode号代表的文件有多个文件名，即可以用不同的文件名访问同一份数据，但是它们指向的inode编号是相同的，并且文件元数据中链接数会增加。不可以对目录创建硬链接。 软链接： 软链接的本质是一个链接文件，其中存储的了对另一个文件的指针。所以对一个文件创建软链接，inode号不相同，创建软链接文件的链接数不会增加。可以对目录创建软链接。 删除：当删除文件时，会先检查inode中的链接数。如果链接数大于1，就只会删掉一个硬链接，不影响数据。如果链接数等于1，那么这个inode就会被释放掉，对应的inode指向的块也会被标记为空闲的（数据不会被置零，所以硬盘数据被误删除后，若没有新数据写入可恢复）。如果是软链接，原文件被删除后链接文件就变成了悬挂链接（dangling link），无法正常访问了。 利用inode还可以删除一些文件名中有转义字符或控制字符的文件，最典型的就是开头为减号-的文件。这种无法直接用rm命令来搞，就可以先查出它们的inode编号再删除： find ./ -inum 10086 -exec rm {} \\\n特有现象 由于inode号码与文件名分离，导致一些Unix/Linux系统具备以下几种特有的现象。\n文件名包含特殊字符，可能无法正常删除。这时直接删除inode，能够起到删除文件的作用；find ./* -inum 节点号 -delete 移动文件或重命名文件，只是改变文件名，不影响inode号码； 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。 这种情况使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。\ninode 耗尽故障 由于硬盘分区的inode总数在格式化后就已经固定，而每个文件必须有一个inode，因此就有可能发生inode节点用光，但硬盘空间还剩不少，却无法创建新文件。同时这也是一种攻击的方式，所以一些公用的文件系统就要做磁盘限额，以防止影响到系统的正常运行。至于修复，很简单，只要找出哪些大量占用i节点的文件删除就可以了。\n硬链接和软链接 Linux系统中有一种比较特殊的文件称之为链接（link）。通俗地说，链接就是从一个文件指向另外一个文件的路径。linux中链接分为俩种，硬链接和软链接。简单来说，硬链接相当于源文件和链接文件在磁盘和内存中共享一个inode，因此，链接文件和源文件有不同的dentry，因此，这个特性决定了硬链接无法跨越文件系统，而且我们无法为目录创建硬链接。软链接和硬链接不同，首先软链接可以跨越文件系统，其次，链接文件和源文件有着不同的inode和dentry，因此，两个文件的属性和内容也截然不同，软链接文件的文件内容是源文件的文件名。 硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。 软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。 软硬链接实现的原理不同\n硬链接是建立一个目录项，包含文件名和文件的inode，但inode是原来文件的inode号，并不建立其所对应得数据。所以硬链接并不占用inode。 软链接也创建一个目录项，也包含文件名和文件的inode，但它的inode指向的并不是原来文件名所指向的数据的inode，而是新建一个inode，并建立数据，数据指向的是原来文件名，所以原来文件名的字符数，即为软链接所占字节数 软硬链接所能创建的目标有区别\n因为每个分区各有一套不同的inode表，所以硬链接不能跨分区创建而软链接可以,因为软链接指向的是文件名。 硬链接不能指向目录 如果说目录有硬链接那么可能引入死循环，但是你可能会疑问软链接也会陷入循环啊，答案当然不是，因为软链接是存在自己的数据的，可以查看自己的文件属性，既然可以判断出来软链接，那么自然不会陷入循环，并且系统在连续遇到8个符号链接后就停止遍历。但是硬链接可就不行了，因为他的inode号一致，所以就判断不出是硬链接，所以就会陷入死循环了。\n","wordCount":"745","inLanguage":"en","datePublished":"2023-04-23T14:04:18+08:00","dateModified":"2023-04-23T14:04:18+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/posts/os_network/>操作系统，网络编程，架构相关的文章</a></div><h1 class=post-title>操作系统之文件系统</h1><div class=post-description>操作系统之文件系统</div><div class=post-meta><span title='2023-04-23 14:04:18 +0800 +0800'>2023-04-23</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-label=文件系统>文件系统</a><ul><li><a href=#%e7%9b%ae%e5%bd%95%e9%a1%b9%e5%92%8c%e7%9b%ae%e5%bd%95%e6%98%af%e4%b8%80%e4%b8%aa%e4%b8%9c%e8%a5%bf%e5%90%97 aria-label=目录项和目录是一个东西吗？>目录项和目录是一个东西吗？</a></li></ul></li><li><a href=#%e8%99%9a%e6%8b%9f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-label=虚拟文件系统>虚拟文件系统</a></li><li><a href=#vfs-%e6%8e%a5%e5%8f%a3 aria-label="VFS 接口">VFS 接口</a><ul><li><a href=#fd-%e5%92%8c-file aria-label="fd 和 file">fd 和 file</a></li><li><a href=#dentry-inode aria-label="DEntry Inode">DEntry Inode</a></li><li><a href=#superblock aria-label=SuperBlock>SuperBlock</a></li><li><a href=#inode aria-label=Inode>Inode</a><ul><li><a href=#stat aria-label=Stat>Stat</a></li><li><a href=#file aria-label=file>file</a></li><li><a href=#inode-number aria-label="Inode Number">Inode Number</a></li><li><a href=#inode-%e5%a4%a7%e5%b0%8f aria-label="Inode 大小">Inode 大小</a></li><li><a href=#df--i aria-label="df -i">df -i</a></li><li><a href=#%e6%96%87%e4%bb%b6%e7%9a%84%e8%af%bb%e5%86%99 aria-label=文件的读写>文件的读写</a></li><li><a href=#%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c aria-label=文件操作>文件操作</a></li><li><a href=#%e7%89%b9%e6%9c%89%e7%8e%b0%e8%b1%a1 aria-label=特有现象>特有现象</a></li><li><a href=#inode-%e8%80%97%e5%b0%bd%e6%95%85%e9%9a%9c aria-label="inode 耗尽故障">inode 耗尽故障</a></li></ul></li><li><a href=#%e7%a1%ac%e9%93%be%e6%8e%a5%e5%92%8c%e8%bd%af%e9%93%be%e6%8e%a5 aria-label=硬链接和软链接>硬链接和软链接</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=文件系统>文件系统<a hidden class=anchor aria-hidden=true href=#文件系统>#</a></h1><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p><p>文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。</p><p>Linux 最经典的一句话是：「一切皆文件」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。</p><p>Linux 文件系统会为每个文件分配两个数据结构：Inode（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。</p><p><img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.31of8dnve3g0.webp alt=fs></p><ul><li><p><code>Inode</code>，也就是inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。Inode是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以Inode同样占用磁盘空间。</p></li><li><p><code>目录项</code>，也就是dentry，用来记录文件的名字、Inode指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与Inode不同的是，<code>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</code>。</p></li></ul><p>由于Inode唯一标识一个文件，而目录项记录着文件的名，所以目录项和Inode的关系是多对一，也就是说，一个文件可以有多个目录。比如，硬链接的实现就是多个目录项中的Inode指向同一个文件。</p><p>注意，<strong>目录也是文件</strong>，也是用Inode唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p><h2 id=目录项和目录是一个东西吗>目录项和目录是一个东西吗？<a hidden class=anchor aria-hidden=true href=#目录项和目录是一个东西吗>#</a></h2><p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p><p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。</p><p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。</p><p>##　文件数据是如何存储在磁盘的呢？
磁盘读写的最小单位是扇区，扇区的大小只有 512字节，那么如果数据大于512字节时候，磁盘需要不停地移动磁头来查找数据，我们知道一般的文件很容易超过512字节那么如果把多个扇区合并为一个块，那么磁盘就可以提高效率了。那么磁头一次读取多个扇区就为一个块“block”（Linux上称为块，Windows上称为簇）。所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。
<code>sector size &lt;= block size &lt;= memory page size</code></p><p><img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.4mc3s1x130k0.webp alt=fs></p><p>文件系统记录的数据，除了其自身外，还有数据的权限信息，所有者等属性，这些信息都保存在inode中，那么谁来记录inode信息和文件系统本身的信息呢，比如说文件系统的格式，inode与data的数量呢？那么就有一个超级区块（supper block）来记录这些信息了。</p><p><img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.2yycpgtv7r20.webp alt=disk></p><ul><li><code>superblock</code>：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等</li><li><code>inode</code>：记录文件的属性信息，可以使用stat命令查看inode信息。</li><li><code>block</code>：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个block，但是一个块只能存放一个文件。（因为数据是由inode指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li></ul><p>Inode用来指向数据block，那么只要找到inode，再由inode找到block编号，那么实际数据就能找出来了。</p><p>Inode是存储在硬盘上的数据，为了加速文件的访问，通常会把Inode加载到内存中。我们不可能把超级块和Inode区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：</p><ul><li>超级块：当文件系统挂载时进入内存；</li><li>Inode区：当文件被访问时进入内存；</li></ul><h1 id=虚拟文件系统>虚拟文件系统<a hidden class=anchor aria-hidden=true href=#虚拟文件系统>#</a></h1><p>文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.2lq6inj2co40.png alt=vfs></p><p>Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：</p><ul><li><code>磁盘的文件系统</code>，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。</li><li><code>内存的文件系统</code>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的/proc 和 /sys 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。</li><li><code>网络的文件系统</code>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li></ul><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><p>Linux 采用为分层的体系结构，将用户接口层、文件系统实现和存储设备的驱动程序分隔开，进而兼容不同的文件系统。虚拟文件系统（Virtual File System, VFS）是 Linux 内核中的软件层，它在内核中提供了一组标准的、抽象的文件操作，允许不同的文件系统实现共存，并向用户空间程序提供统一的文件系统接口。下面这张图展示了 Linux 虚拟文件系统的整体结构：
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.1dpaykc6fvgg.png alt=vfs-a></p><p>从上图可以看出，用户空间的应用程序直接、或是通过编程语言提供的库函数间接调用内核提供的 System Call 接口（如open()、write()等）执行文件操作。System Call 接口再将应用程序的参数传递给虚拟文件系统进行处理。</p><p>每个文件系统都为 VFS 实现了一组通用接口，具体的文件系统根据自己对磁盘上数据的组织方式操作相应的数据。当应用程序操作某个文件时，VFS 会根据文件路径找到相应的挂载点，得到具体的文件系统信息，然后调用该文件系统的对应操作函数。</p><p>VFS 提供了两个针对文件系统对象的缓存 INode Cache 和 DEntry Cache，它们缓存最近使用过的文件系统对象，用来加快对 INode 和 DEntry 的访问。Linux 内核还提供了 Buffer Cache 缓冲区，用来缓存文件系统和相关块设备之间的请求，减少访问物理设备的次数，加快访问速度。Buffer Cache 以 LRU 列表的形式管理缓冲区。</p><p>VFS 的好处是实现了应用程序的文件操作与具体的文件系统的解耦，使得编程更加容易：</p><ul><li>应用层程序只要使用 VFS 对外提供的read()、write()等接口就可以执行文件操作，不需要关心底层文件系统的实现细节；</li><li>文件系统只需要实现 VFS 接口就可以兼容 Linux，方便移植与维护；</li><li>无需关注具体的实现细节，就实现跨文件系统的文件操作。</li></ul><p>了解 Linux 文件系统的整体结构后，下面主要分析 Linux VFS 的技术原理。由于文件系统与设备驱动的实现非常复杂，笔者也未接触过这方面的内容，因此文中不会涉及具体文件系统的实现。</p><h1 id=vfs-接口>VFS 接口<a hidden class=anchor aria-hidden=true href=#vfs-接口>#</a></h1><p>Linux 以一组通用对象的角度看待所有文件系统，每一级对象之间的关系如下图所示：
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.73m9k1p5f3s0.png alt=vfs-object></p><h2 id=fd-和-file>fd 和 file<a hidden class=anchor aria-hidden=true href=#fd-和-file>#</a></h2><p>每个进程都持有一个fd[]数组，数组里面存放的是指向<code>file结构体</code>的指针，同一进程的不同fd可以指向同一个file对象；</p><p>file是<code>内核中的数据结构</code>，表示一个被进程打开的文件，和进程相关联。当应用程序调用open()函数的时候，VFS 就会创建相应的file对象。它会保存打开文件的状态，例如文件权限、路径、偏移量等等。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L936 结构体已删减
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>file</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>path</span>                   <span class=n>f_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span>                  <span class=o>*</span><span class=n>f_inode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span>  <span class=o>*</span><span class=n>f_op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span>                  <span class=n>f_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>fmode_t</span>                       <span class=n>f_mode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>loff_t</span>                        <span class=n>f_pos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>fown_struct</span>            <span class=n>f_owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/path.h#L8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>path</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>vfsmount</span>  <span class=o>*</span><span class=n>mnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>dentry</span>    <span class=o>*</span><span class=n>dentry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>从上面的代码可以看出，文件的路径实际上是一个指向 DEntry 结构体的指针，VFS 通过 DEntry 索引到文件的位置。</p><p>除了文件偏移量f_pos是进程私有的数据外，其他的数据都来自于 INode 和 DEntry，和所有进程共享。不同进程的file对象可以指向同一个 DEntry 和 Inode，从而实现文件的共享。</p><h2 id=dentry-inode>DEntry Inode<a hidden class=anchor aria-hidden=true href=#dentry-inode>#</a></h2><p>Linux文件系统会为每个文件都分配两个数据结构，目录项（DEntry, Directory Entry）和索引节点（INode, Index Node）。</p><p>DEntry 用来保存文件路径和 INode 之间的映射，从而支持在文件系统中移动。DEntry 由 VFS 维护，所有文件系统共享，不和具体的进程关联。dentry对象从根目录“/”开始，每个dentry对象都会持有自己的子目录和文件，这样就形成了文件树。举例来说，如果要访问”/home/beihai/a.txt”文件并对他操作，系统会解析文件路径，首先从“/”根目录的dentry对象开始访问，然后找到”home/“目录，其次是“beihai/”，最后找到“a.txt”的dentry结构体，该结构体里面d_inode字段就对应着该文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/dcache.h#L89 结构体已删减
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>dentry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=n>d_parent</span><span class=p>;</span>     <span class=c1>// 父目录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>qstr</span> <span class=n>d_name</span><span class=p>;</span>          <span class=c1>// 文件名称
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>d_inode</span><span class=p>;</span>       <span class=c1>// 关联的 inode
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>list_head</span> <span class=n>d_child</span><span class=p>;</span>    <span class=c1>// 父目录中的子目录和文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>list_head</span> <span class=n>d_subdirs</span><span class=p>;</span>  <span class=c1>// 当前目录中的子目录和文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>每一个dentry对象都持有一个对应的inode对象，表示 Linux 中一个具体的目录项或文件。INode 包含管理文件系统中的对象所需的所有元数据，以及可以在该文件对象上执行的操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L628 结构体已删减
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>inode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>umode_t</span>                 <span class=n>i_mode</span><span class=p>;</span>          <span class=c1>// 文件权限及类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>kuid_t</span>                  <span class=n>i_uid</span><span class=p>;</span>           <span class=c1>// user id
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>kgid_t</span>                  <span class=n>i_gid</span><span class=p>;</span>           <span class=c1>// group id
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>inode_operations</span>    <span class=o>*</span><span class=n>i_op</span><span class=p>;</span>  <span class=c1>// inode 操作函数，如 create，mkdir，lookup，rename 等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>super_block</span>      <span class=o>*</span><span class=n>i_sb</span><span class=p>;</span>           <span class=c1>// 所属的 SuperBlock
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>loff_t</span>                  <span class=n>i_size</span><span class=p>;</span>          <span class=c1>// 文件大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>timespec</span>         <span class=n>i_atime</span><span class=p>;</span>         <span class=c1>// 文件最后访问时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>timespec</span>         <span class=n>i_mtime</span><span class=p>;</span>         <span class=c1>// 文件最后修改时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>timespec</span>         <span class=n>i_ctime</span><span class=p>;</span>         <span class=c1>// 文件元数据最后修改时间（包括文件名称）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span>    <span class=o>*</span><span class=n>i_fop</span><span class=p>;</span>  <span class=c1>// 文件操作函数，open、write 等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span>                    <span class=o>*</span><span class=n>i_private</span><span class=p>;</span>      <span class=c1>// 文件系统的私有数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>虚拟文件系统维护了一个 DEntry Cache 缓存，用来保存最近使用的 DEntry，加速查询操作。当调用open()函数打开一个文件时，内核会第一时间根据文件路径到 DEntry Cache 里面寻找相应的 DEntry，找到了就直接构造一个file对象并返回。如果该文件不在缓存中，那么 VFS 会根据找到的最近目录一级一级地向下加载，直到找到相应的文件。期间 VFS 会缓存所有被加载生成的dentry。</p><p>INode 存储的数据存放在磁盘上，由具体的文件系统进行组织，当需要访问一个 INode 时，会由文件系统从磁盘上加载相应的数据并构造 INode。一个 INode 可能被多个 DEntry 所关联，即相当于为某一文件创建了多个文件路径（通常是为文件建立硬链接）。</p><h2 id=superblock>SuperBlock<a hidden class=anchor aria-hidden=true href=#superblock>#</a></h2><p>SuperBlock 表示特定加载的文件系统，用于描述和维护文件系统的状态，由 VFS 定义，但里面的数据根据具体的文件系统填充。每个 SuperBlock 代表了一个具体的磁盘分区，里面包含了当前磁盘分区的信息，如文件系统类型、剩余空间等。SuperBlock 的一个重要成员是链表s_list，包含所有修改过的 INode，使用该链表很容易区分出来哪个文件被修改过，并配合内核线程将数据写回磁盘。SuperBlock 的另一个重要成员是s_op，定义了针对其 INode 的所有操作方法，例如标记、释放索引节点等一系列操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L1425 结构体已删减
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>super_block</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>list_head</span>    <span class=n>s_list</span><span class=p>;</span>               <span class=c1>// 指向链表的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>dev_t</span>               <span class=n>s_dev</span><span class=p>;</span>                <span class=c1>// 设备标识符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span>       <span class=n>s_blocksize</span><span class=p>;</span>          <span class=c1>// 以字节为单位的块大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>loff_t</span>              <span class=n>s_maxbytes</span><span class=p>;</span>           <span class=c1>// 文件大小上限
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>file_system_type</span>    <span class=o>*</span><span class=n>s_type</span><span class=p>;</span>       <span class=c1>// 文件系统类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>super_operations</span>    <span class=o>*</span><span class=n>s_op</span><span class=p>;</span>   <span class=c1>// SuperBlock 操作函数，write_inode、put_inode 等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>dquot_operations</span>    <span class=o>*</span><span class=n>dq_op</span><span class=p>;</span>  <span class=c1>// 磁盘限额函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>dentry</span>        <span class=o>*</span><span class=n>s_root</span><span class=p>;</span>             <span class=c1>// 根目录
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>SuperBlock 是一个非常复杂的结构，通过 SuperBlock 我们可以将一个实体文件系统挂载到 Linux 上，或者对 INode 进行增删改查操作。所以一般文件系统都会在磁盘上<code>存储多份 SuperBlock</code>，防止数据意外损坏导致整个分区无法读取。</p><h2 id=inode>Inode<a hidden class=anchor aria-hidden=true href=#inode>#</a></h2><p>Inode包含很多的文件元信息，但不包含文件名，例如：字节数、属主UserID、属组GroupID、读写执行权限、时间戳等。而文件名存放在目录当中，但Linux系统内部不使用文件名，而是使用inode号码识别文件。对于系统来说文件名只是inode号码便于识别的别称。</p><h3 id=stat>Stat<a hidden class=anchor aria-hidden=true href=#stat>#</a></h3><p>查看Inode</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># mkdir test</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># echo &#34;this is test file&#34; &gt; test.txt</span>
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># stat test.txt</span>
</span></span><span class=line><span class=cl>  File: ‘test.txt’
</span></span><span class=line><span class=cl>  Size: <span class=m>18</span>              Blocks: <span class=m>8</span>          IO Block: <span class=m>4096</span>   regular file
</span></span><span class=line><span class=cl>Device: fd00h/64768d    Inode: <span class=m>33574994</span>    Links: <span class=m>1</span>
</span></span><span class=line><span class=cl>Access: <span class=o>(</span>0644/-rw-r--r--<span class=o>)</span>  Uid: <span class=o>(</span>    0/    root<span class=o>)</span>   Gid: <span class=o>(</span>    0/    root<span class=o>)</span>
</span></span><span class=line><span class=cl>Context: unconfined_u:object_r:admin_home_t:s0
</span></span><span class=line><span class=cl>Access: 2019-08-28 19:55:05.920240744 +0800
</span></span><span class=line><span class=cl>Modify: 2019-08-28 19:55:05.920240744 +0800
</span></span><span class=line><span class=cl>Change: 2019-08-28 19:55:05.920240744 +0800
</span></span><span class=line><span class=cl> Birth: -
</span></span></code></pre></td></tr></table></div></div><p>三个主要的时间属性：</p><ul><li>ctime：change time是最后一次改变文件或目录（属性）的时间，例如执行chmod，chown等命令。</li><li>atime：access time是最后一次访问文件或目录的时间。</li><li>mtime：modify time是最后一次修改文件或目录（内容）的时间。</li></ul><h3 id=file>file<a hidden class=anchor aria-hidden=true href=#file>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># file test</span>
</span></span><span class=line><span class=cl>test: directory
</span></span><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># file test.txt</span>
</span></span><span class=line><span class=cl>test.txt: ASCII text
</span></span></code></pre></td></tr></table></div></div><h3 id=inode-number>Inode Number<a hidden class=anchor aria-hidden=true href=#inode-number>#</a></h3><p>表面上，用户通过文件名打开文件，实际上，系统内部将这个过程分为三步：</p><ul><li>系统找到这个文件名对应的inode号码；</li><li>通过inode号码，获取inode信息；</li><li>根据inode信息，找到文件数据所在的block，并读出数据。</li></ul><p>其实系统还要根据inode信息，看用户是否具有访问的权限，有就指向对应的数据block，没有就返回权限拒绝。</p><p>直接查看文件i节点号，也可以通过stat查看文件inode信息查看i节点号。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>root@localhost ~<span class=o>]</span><span class=c1># ls -i</span>
</span></span><span class=line><span class=cl><span class=m>33574991</span> anaconda-ks.cfg      <span class=m>2086</span> <span class=nb>test</span>  <span class=m>33574994</span> test.txt
</span></span></code></pre></td></tr></table></div></div><h3 id=inode-大小>Inode 大小<a hidden class=anchor aria-hidden=true href=#inode-大小>#</a></h3><p>inode也会消耗硬盘空间，所以格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区，存放inode所包含的信息。每个inode的大小，一般是128字节或256字节。通常情况下不需要关注单个inode的大小，而是需要重点关注inode总数。inode总数在格式化的时候就确定了。</p><h3 id=df--i>df -i<a hidden class=anchor aria-hidden=true href=#df--i>#</a></h3><p>查看硬盘分区的inode总数和已使用情况</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>root@***<span class=o>]</span><span class=c1># df -i</span>
</span></span><span class=line><span class=cl>Filesystem        Inodes  IUsed     IFree IUse% Mounted on
</span></span><span class=line><span class=cl>devtmpfs        <span class=m>16219999</span>    <span class=m>413</span>  <span class=m>16219586</span>    1% /dev
</span></span><span class=line><span class=cl>tmpfs           <span class=m>16222589</span>      <span class=m>2</span>  <span class=m>16222587</span>    1% /dev/shm
</span></span><span class=line><span class=cl>tmpfs           <span class=m>16222589</span>    <span class=m>602</span>  <span class=m>16221987</span>    1% /run
</span></span><span class=line><span class=cl>tmpfs           <span class=m>16222589</span>     <span class=m>16</span>  <span class=m>16222573</span>    1% /sys/fs/cgroup
</span></span><span class=line><span class=cl>/dev/vda1        <span class=m>2621440</span> <span class=m>122606</span>   <span class=m>2498834</span>    5% /
</span></span><span class=line><span class=cl>/dev/vdb1      <span class=m>131072000</span> <span class=m>134633</span> <span class=m>130937367</span>    1% /mnt
</span></span><span class=line><span class=cl>tmpfs           <span class=m>16222589</span>     <span class=m>22</span>  <span class=m>16222567</span>    1% /run/user/0
</span></span><span class=line><span class=cl>overlay          <span class=m>2621440</span> <span class=m>122606</span>   <span class=m>2498834</span>    5% /var/lib/docker/overlay2/2e836ead8a69c7413ec89faecf1357479a6df9ba1e515056d9c89bb121e6fba1/merged
</span></span><span class=line><span class=cl>shm             <span class=m>16222589</span>      <span class=m>1</span>  <span class=m>16222588</span>    1% /var/lib/docker/containers/1713b72ff979243ef1d36d0a5aaf6c79989a75b267531d341665a7e432fd5a09/shm
</span></span></code></pre></td></tr></table></div></div><h3 id=文件的读写>文件的读写<a hidden class=anchor aria-hidden=true href=#文件的读写>#</a></h3><p>文件系统在打开一个文件时，要做的有：</p><ul><li>系统找到这个文件名对应的inode：在目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 号</li><li>通过inode号，获取到磁盘中的inode信息，其中最重要的内容是磁盘地址表</li><li>通过inode信息中的磁盘地址表，文件系统把分散存放的文件物理块链接成文件的逻辑结构。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。找到文件数据所在的block，读出数据。</li></ul><p>根据以上流程，我们可以发现，inode应该是有一个专门的存储区域的，以方便系统快速查找。事实上，一块磁盘创建的时候，操作系统自动将硬盘分成两个区域：存放文件数据的数据区，与存放inode信息的inode区（inode table）。</p><p>每个inode的大小一般是128B或者256B。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>也就是说，每个分区的inode总数从格式化之后就固定了，因此有可能会出现存储空间没有占满，但因为小文件太多而耗尽了inode的情况。这个时候就只能清除inode占用高的文件或者目录或修改inode数量了，当然，inode的调整需要重新格式化磁盘，需要确保数据已经得到有效备份后，再进行此操作。</p><p>这时候又产生了新的问题：文件创建时要为文件分配哪一个inode号呢？即如何保证分配的inode号没有被占用？
既然是”是否被占用”的问题，使用<code>位图</code>是最佳方案，像bmap记录block的占用情况一样。标识inode号是否被分配的位图称为inodemap简称为imap。这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。</p><p>(位图法就是bitmap的缩写。所谓bitmap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。)
类似bmap块位图一样，inode号是预先规划好的。inode号分配后，文件删除也会释放inode号。分配和释放的inode号，像是在一个地图上挖掉一块，用完再补回来一样。
imap存在着和bmap和inode table一样需要解决的问题：如果文件系统比较大，imap本身就会很大，每次存储文件都要进行扫描，会导致效率不够高。同样，优化的方式是将文件系统占用的<code>block划分成块组</code>，每个块组有自己的imap范围，<code>以减少检索时间</code>。</p><p>文件系统使用block group来组织block的原因有以下几点：</p><ul><li>把每个区进一步分为多个块组 (block group)，每个块组有独立的inode/block体系</li><li>如果文件系统高达数百 GB 时，把所有的 inode 和block 通通放在一起会因为 inode 和 block的数量太庞大，不容易管理
这其实很好理解，因为分区是用户的分区，实际计算机管理时还有个最适合的大小，于是计算机会进一步的在分区中分块
（但这样岂不是可能出现大文件放不了的问题？有什么机制善后吗？）</li><li>每个块组实际还会分为分为6个部分，除了inode table 和 data block外还有4个附属模块，起到优化和完善系统性能的作用
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.2s3i4ttpncm0.png alt=blockgroup></li></ul><p>利用df -i命令可以查看inode数量方面的信息</p><h3 id=文件操作>文件操作<a hidden class=anchor aria-hidden=true href=#文件操作>#</a></h3><p>系统对文件的操作会可能影响inode：</p><ul><li>复制：创建一个包含全部数据与新inode号的新文件</li><li>移动：在同一磁盘下移动时，所在目录改变，inode号与实际数据存储的块的位置都不会变化。跨磁盘移动当然会删除本磁盘的数据并创建一条新的数据在另一块磁盘中。</li><li>硬链接： 同一个inode号代表的文件有多个文件名，即可以用不同的文件名访问同一份数据，但是它们指向的inode编号是相同的，并且文件元数据中链接数会增加。不可以对目录创建硬链接。</li><li>软链接： 软链接的本质是一个链接文件，其中存储的了对另一个文件的指针。所以对一个文件创建软链接，inode号不相同，创建软链接文件的链接数不会增加。可以对目录创建软链接。</li><li>删除：当删除文件时，会先检查inode中的链接数。如果链接数大于1，就只会删掉一个硬链接，不影响数据。如果链接数等于1，那么这个inode就会被释放掉，对应的inode指向的块也会被标记为空闲的（数据不会被置零，所以硬盘数据被误删除后，若没有新数据写入可恢复）。如果是软链接，原文件被删除后链接文件就变成了悬挂链接（dangling link），无法正常访问了。</li></ul><p>利用inode还可以删除一些文件名中有转义字符或控制字符的文件，最典型的就是开头为减号-的文件。这种无法直接用rm命令来搞，就可以先查出它们的inode编号再删除： find ./ -inum 10086 -exec rm {} \</p><h3 id=特有现象>特有现象<a hidden class=anchor aria-hidden=true href=#特有现象>#</a></h3><p>由于inode号码与文件名分离，导致一些Unix/Linux系统具备以下几种特有的现象。</p><ul><li>文件名包含特殊字符，可能无法正常删除。这时直接删除inode，能够起到删除文件的作用；find ./* -inum 节点号 -delete</li><li>移动文件或重命名文件，只是改变文件名，不影响inode号码；</li><li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。</li></ul><p>这种情况使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><h3 id=inode-耗尽故障>inode 耗尽故障<a hidden class=anchor aria-hidden=true href=#inode-耗尽故障>#</a></h3><p>由于硬盘分区的inode总数在格式化后就已经固定，而每个文件必须有一个inode，因此就有可能发生inode节点用光，但硬盘空间还剩不少，却无法创建新文件。同时这也是一种攻击的方式，所以一些公用的文件系统就要做磁盘限额，以防止影响到系统的正常运行。至于修复，很简单，只要找出哪些大量占用i节点的文件删除就可以了。</p><h2 id=硬链接和软链接>硬链接和软链接<a hidden class=anchor aria-hidden=true href=#硬链接和软链接>#</a></h2><p>Linux系统中有一种比较特殊的文件称之为链接（link）。通俗地说，链接就是从一个文件指向另外一个文件的路径。linux中链接分为俩种，硬链接和软链接。简单来说，硬链接相当于源文件和链接文件在磁盘和内存中共享一个inode，因此，链接文件和源文件有不同的dentry，因此，这个特性决定了硬链接无法跨越文件系统，而且我们无法为目录创建硬链接。软链接和硬链接不同，首先软链接可以跨越文件系统，其次，链接文件和源文件有着不同的inode和dentry，因此，两个文件的属性和内容也截然不同，软链接文件的文件内容是源文件的文件名。
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.1g86pzswf70g.png alt=hl-sl></p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.6whkih1aa000.webp alt=hard-link></p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230423/image.5ymdziavyao0.webp alt=soft-link></p><ul><li><p>软硬链接实现的原理不同</p><ul><li>硬链接是建立一个目录项，包含文件名和文件的inode，但inode是原来文件的inode号，并不建立其所对应得数据。所以硬链接并不占用inode。</li><li>软链接也创建一个目录项，也包含文件名和文件的inode，但它的inode指向的并不是原来文件名所指向的数据的inode，而是新建一个inode，并建立数据，数据指向的是原来文件名，所以原来文件名的字符数，即为软链接所占字节数</li></ul></li><li><p>软硬链接所能创建的目标有区别</p><ul><li>因为每个分区各有一套不同的inode表，所以硬链接不能跨分区创建而软链接可以,因为软链接指向的是文件名。</li></ul></li><li><p>硬链接不能指向目录
如果说目录有硬链接那么可能引入死循环，但是你可能会疑问软链接也会陷入循环啊，答案当然不是，因为软链接是存在自己的数据的，可以查看自己的文件属性，既然可以判断出来软链接，那么自然不会陷入循环，并且系统在连续遇到8个符号链接后就停止遍历。但是硬链接可就不行了，因为他的inode号一致，所以就判断不出是硬链接，所以就会陷入死循环了。</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/>文件系统</a></li><li><a href=https://reid00.github.io/tags/fs/>FS</a></li><li><a href=https://reid00.github.io/tags/inode/>Inode</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/posts/other/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E7%94%A8githubaction%E9%83%A8%E7%BD%B2/><span class=title>« Prev</span><br><span>Hugo搭建博客并用GitHubAction部署</span></a>
<a class=next href=https://reid00.github.io/posts/os_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/><span class=title>Next »</span><br><span>操作系统之内存管理</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://reid00.github.io/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>