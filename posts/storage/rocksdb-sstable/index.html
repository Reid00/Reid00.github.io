<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RocksDB Sstable | Reid's Blog</title><meta name=keywords content="SST,RocksDB,LevelDB"><meta name=description content="RocksDB Sstable"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/posts/storage/rocksdb-sstable/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK",{anonymize_ip:!1})}</script><meta property="og:title" content="RocksDB Sstable"><meta property="og:description" content="RocksDB Sstable"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/posts/storage/rocksdb-sstable/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:35:09+08:00"><meta property="article:modified_time" content="2023-03-16T19:35:09+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="RocksDB Sstable"><meta name=twitter:description content="RocksDB Sstable"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"未分类文章","item":"https://reid00.github.io/posts/"},{"@type":"ListItem","position":2,"name":"存储, 分布式相关的文章","item":"https://reid00.github.io/posts/storage/"},{"@type":"ListItem","position":3,"name":"RocksDB Sstable","item":"https://reid00.github.io/posts/storage/rocksdb-sstable/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RocksDB Sstable","name":"RocksDB Sstable","description":"RocksDB Sstable","keywords":["SST","RocksDB","LevelDB"],"articleBody":"概述 如我们之前提到的，leveldb是典型的LSM树(Log Structured-Merge Tree)实现，即一次leveldb的写入过程并不是直接将数据持久化到磁盘文件中，而是将写操作首先写入日志文件中，其次将写操作应用在memtable上。\n当leveldb达到checkpoint点（memtable中的数据量超过了预设的阈值），会将当前memtable冻结成一个不可更改的内存数据库（immutable memory db），并且创建一个新的memtable供系统继续使用。\nimmutable memory db会在后台进行一次minor compaction，即将内存数据库中的数据持久化到磁盘文件中。\n在这里我们暂时不展开讨论minor compaction相关的内容，读者可以简单地理解为将内存中的数据持久化到文件\nleveldb（或者说LSM树）设计Minor Compaction的目的是为了：\n有效地降低内存的使用率； 避免日志文件过大，系统恢复时间过长； 当memory db的数据被持久化到文件中时，leveldb将以一定规则进行文件组织，这种文件格式成为sstable。在本文中将详细地介绍sstable的文件格式以及相关读写操作。\nSStable文件格式 物理结构 为了提高整体的读写效率，一个sstable文件按照固定大小进行块划分，默认每个块的大小为4KiB。每个Block中，除了存储数据以外，还会存储两个额外的辅助字段：\n压缩类型 CRC校验码 压缩类型说明了Block中存储的数据是否进行了数据压缩，若是，采用了哪种算法进行压缩。leveldb中默认采用Snappy算法进行压缩。 CRC校验码是循环冗余校验校验码，校验范围包括数据以及压缩类型。 逻辑结构 在逻辑上，根据功能不同，leveldb在逻辑上又将sstable分为：\ndata block: 用来存储key value数据对； filter block: 用来存储一些过滤器相关的数据（布隆过滤器），但是若用户不指定leveldb使用过滤器，leveldb在该block中不会存储任何内容； meta Index block: 用来存储filter block的索引信息（索引信息指在该sstable文件中的偏移量以及数据长度）； index block：index block中用来存储每个data block的索引信息； footer: 用来存储meta index block及index block的索引信息； 注意，1-4类型的区块，其物理结构都是如1.1节所示，每个区块都会有自己的压缩信息以及CRC校验码信息。\ndata block结构 data block中存储的数据是leveldb中的keyvalue键值对。其中一个data block中的数据部分（不包括压缩类型、CRC校验码）按逻辑又以下图进行划分： 第一部分用来存储keyvalue数据。由于sstable中所有的keyvalue对都是严格按序存储的，为了节省存储空间，leveldb并不会为每一对keyvalue对都存储完整的key值，而是存储与上一个key非共享的部分，避免了key重复内容的存储。\n每间隔若干个keyvalue对，将为该条记录重新存储一个完整的key。重复该过程（默认间隔值为16），每个重新存储完整key的点称之为Restart point。\n每间隔若干个keyvalue对，将为该条记录重新存储一个完整的key。重复该过程（默认间隔值为16），每个重新存储完整key的点称之为Restart point。\n每个数据项的格式如下图所示： 一个entry分为5部分内容：\n与前一条记录key共享部分的长度； 与前一条记录key不共享部分的长度； value长度； 与前一条记录key非共享的内容； value内容； 例如：\n1 2 3 4 restart_interval=2 entry one : key=deck,value=v1 entry two : key=dock,value=v2 entry three: key=duck,value=v3 三组entry按上图的格式进行存储。值得注意的是restart_interval为2，因此每隔两个entry都会有一条数据作为restart point点的数据项，存储完整key值。因此entry3存储了完整的key。\n此外，第一个restart point为0（偏移量），第二个restart point为16，restart point共有两个，因此一个datablock数据段的末尾添加了下图所示的数据： 尾部数据记录了每一个restart point的值，以及所有restart point的个数。\nfilter block结构 讲完了data block，在这一章节将展开讲述filter block的结构。\n为了加快sstable中数据查询的效率，在直接查询datablock中的内容之前，leveldb首先根据filter block中的过滤数据判断指定的datablock中是否有需要查询的数据，若判断不存在，则无需对这个datablock进行数据查找。\nfilter block存储的是data block数据的一些过滤信息。这些过滤数据一般指代布隆过滤器的数据，用于加快查询的速度，关于布隆过滤器的详细内容，可以见《Leveldb源码分析 - 布隆过滤器》。 filter block存储的数据主要可以分为两部分：（1）过滤数据（2）索引数据。\n其中索引数据中，filter i offset表示第i个filter data在整个filter block中的起始偏移量，filter offset’s offset表示filter block的索引数据在filter block中的偏移量。\n在读取filter block中的内容时，可以首先读出filter offset’s offset的值，然后依次读取filter i offset，根据这些offset分别读出filter data。\nBase Lg默认值为11，表示每2KB的数据，创建一个新的过滤器来存放过滤数据。\n一个sstable只有一个filter block，其内存储了所有block的filter数据. 具体来说，filter_data_k 包含了所有起始位置处于 [basek, base(k+1)]范围内的block的key的集合的filter数据，按数据大小而非block切分主要是为了尽量均匀，以应对存在一些block的key很多，另一些block的key很少的情况。\nleveldb中，特殊的sstable文件格式设计简化了许多操作，例如： 索引和BloomFilter等元数据可随文件一起创建和销毁，即直接存在文件里，不用加载时动态计算，不用维护更新\nmeta index block结构 meta index block用来存储filter block在整个sstable中的索引信息。\nmeta index block只存储一条记录：\n该记录的key为：“filter.“与过滤器名字组成的常量字符串\n该记录的value为：filter block在sstable中的索引信息序列化后的内容，索引信息包括：（1）在sstable中的偏移量（2）数据长度。\nindex block结构 与meta index block类似，index block用来存储所有data block的相关索引信息。\nindexblock包含若干条记录，每一条记录代表一个data block的索引信息。\n一条索引包括以下内容：\ndata block i 中最大的key值； 该data block起始地址在sstable中的偏移量； 该data block的大小； 其中，data block i最大的key值还是index block中该条记录的key值。 如此设计的目的是，依次比较index block中记录信息的key值即可实现快速定位目标数据在哪个data block中。\nfooter结构 footer大小固定，为48字节，用来存储meta index block与index block在sstable中的索引信息，另外尾部还会存储一个magic word，内容为：“http://code.google.com/p/leveldb/\"字符串sha1哈希的前8个字节。 读写操作 在介绍完sstable文件具体的组织方式之后，我们再来介绍一下相关的读写操作。为了便于读者理解，将首先介绍写操作。\n写操作 sstable的写操作通常发生在：\nmemory db将内容持久化到磁盘文件中时，会创建一个sstable进行写入； leveldb后台进行文件compaction时，会将若干个sstable文件的内容重新组织，输出到若干个新的sstable文件中； 对sstable进行写操作的数据结构为tWriter，具体定义如下：\n1 2 3 4 5 6 7 8 9 10 11 // tWriter wraps the table writer. It keep track of file descriptor // and added key range. type tWriter struct { t *tOps fd storage.FileDesc // 文件描述符 w storage.Writer // 文件系统writer tw *table.Writer first, last []byte } 主要包括了一个sstable的文件描述符，底层文件系统的writer，该sstable中所有数据项最大最小的key值以及一个内嵌的tableWriter。\n一次sstable的写入为一次不断利用迭代器读取需要写入的数据，并不断调用tableWriter的Append函数，直至所有有效数据读取完毕，为该sstable文件附上元数据的过程。\n该迭代器可以是一个内存数据库的迭代器，写入情景对应着上述的第一种情况；\n该迭代器也可以是一个sstable文件的迭代器，写入情景对应着上述的第二种情况；\nsstable的元数据包括：（1）文件编码（2）大小（3）最大key值（4）最小key值\n故，理解tableWriter的Append函数是理解整个写入过程的关键。\ntableWriter 在介绍append函数之前，首先介绍一下tableWriter这个数据结构。主要的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Writer is a table writer. type Writer struct { writer io.Writer // Options blockSize int // 默认是4KiB dataBlock blockWriter // data块Writer indexBlock blockWriter // indexBlock块Writer filterBlock filterWriter // filter块Writer pendingBH blockHandle offset uint64 nEntries int // key-value键值对个数 } 其中blockWriter与filterWriter表示底层的两种不同的writer，blockWriter负责写入data数据的写入，而filterWriter负责写入过滤数据。\npendingBH记录了上一个dataBlock的索引信息，当下一个dataBlock的数据开始写入时，将该索引信息写入indexBlock中。\nAppend 一次append函数的主要逻辑如下：\n若本次写入为新dataBlock的第一次写入，则将上一个dataBlock的索引信息写入； 将keyvalue数据写入datablock; 将过滤信息写入filterBlock； 若datablock中的数据超过预定上限，则标志着本次datablock写入结束，将内容刷新到磁盘文件中； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (w *Writer) Append(key, value []byte) error { w.flushPendingBH(key) // Append key/value pair to the data block. w.dataBlock.append(key, value) // Add key to the filter block. w.filterBlock.add(key) // Finish the data block if block size target reached. if w.dataBlock.bytesLen() \u003e= w.blockSize { if err := w.finishBlock(); err != nil { w.err = err return w.err } } w.nEntries++ return nil } dataBlock.append 该函数将编码后的kv数据写入到dataBlock对应的buffer中，编码的格式如上文中提到的数据项的格式。此外，在写入的过程中，若该数据项为restart点，则会添加相应的restart point信息。\nfilterBlock.append 该函数将kv数据项的key值加入到过滤信息中，具体可见《Leveldb源码解析 - 布隆过滤器》\nfinishBlock 若一个datablock中的数据超过了固定上限，则需要将相关数据写入到磁盘文件中。\n在写入时，需要做以下工作：\n封装dataBlock，记录restart point的个数； 若dataBlock的数据需要进行压缩（例如snappy压缩算法），则对dataBlock中的数据进行压缩； 计算checksum； 封装dataBlock索引信息（offset，length）； 将datablock的buffer中的数据写入磁盘文件； 利用这段时间里维护的过滤信息生成过滤数据，放入filterBlock对用的buffer中； Close 当迭代器取出所有数据并完成写入后，调用tableWriter的Close函数完成最后的收尾工作：\n若buffer中仍有未写入的数据，封装成一个datablock写入； 将filterBlock的内容写入磁盘文件； 将filterBlock的索引信息写入metaIndexBlock中，写入到磁盘文件； 写入indexBlock的数据； 写入footer数据； 至此为止，所有的数据已经被写入到一个sstable中了，由于一个sstable是作为一个memory db或者Compaction的结果原子性落地的，因此在sstable写入完成之后，将进行更为复杂的leveldb的版本更新，将在接下来的文章中继续介绍。\n读操作 读操作作为写操作的逆过程，充分理解了写操作，将会帮助理解读操作。\n下图为在一个sstable中查找某个数据项的流程图： 大致流程为：\n首先判断“文件句柄”cache中是否有指定sstable文件的文件句柄，若存在，则直接使用cache中的句柄；否则打开该sstable文件，按规则读取该文件的元数据，将新打开的句柄存储至cache中； 利用sstable中的index block进行快速的数据项位置定位，得到该数据项有可能存在的两个data block； 利用index block中的索引信息，首先打开第一个可能的data block； 利用filter block中的过滤信息，判断指定的数据项是否存在于该data block中，若存在，则创建一个迭代器对data block中的数据进行迭代遍历，寻找数据项；若不存在，则结束该data block的查找； 若在第一个data block中找到了目标数据，则返回结果；若未查找成功，则打开第二个data block，重复步骤4； 若在第二个data block中找到了目标数据，则返回结果；若未查找成功，则返回Not Found错误信息； 缓存 在leveldb中，使用cache来缓存两类数据：\nsstable文件句柄及其元数据； data block中的数据； 因此在打开文件之前，首先判断能够在cache中命中sstable的文件句柄，避免重复读取的开销。 元数据读取 由于sstable复杂的文件组织格式，因此在打开文件后，需要读取必要的元数据，才能访问sstable中的数据。\n元数据读取的过程可以分为以下几个步骤：\n读取文件的最后48字节的利用，即Footer数据； 读取Footer数据中维护的(1) Meta Index Block(2) Index Block两个部分的索引信息并记录，以提高整体的查询效率； 利用meta index block的索引信息读取该部分的内容； 遍历meta index block，查看是否存在“有用”的filter block的索引信息，若有，则记录该索引信息；若没有，则表示当前sstable中不存在任何过滤信息来提高查询效率； 数据项的快速定位 sstable中存在多个data block，倘若依次进行“遍历”显然是不可取的。但是由于一个sstable中所有的数据项都是按序排列的，因此可以利用有序性已经index block中维护的索引信息快速定位目标数据项可能存在的data block。\n一个index block的文件结构示意图如下： index block是由一系列的键值对组成，每一个键值对表示一个data block的索引信息。\n键值对的key为该data block中数据项key的最大值，value为该data block的索引信息（offset, length）。\n因此若需要查找目标数据项，仅仅需要依次比较index block中的这些索引信息，倘若目标数据项的key大于某个data block中最大的key值，则该data block中必然不存在目标数据项。故通过这个步骤的优化，可以直接确定目标数据项落在哪个data block的范围区间内。\n值得注意的是，与data block一样，index block中的索引信息同样也进行了key值截取，即第二个索引信息的key并不是存储完整的key，而是存储与前一个索引信息的key不共享的部分，区别在于data block中这种范围的划分粒度为16，而index block中为2 。 也就是说，index block连续两条索引信息会被作为一个最小的“比较单元“，在查找的过程中，若第一个索引信息的key小于目标数据项的key，则紧接着会比较第三条索引信息的key。 这就导致最终目标数据项的范围区间为某”两个“data block。\n过滤data block 若sstable存有每一个data block的过滤数据，则可以利用这些过滤数据对data block中的内容进行判断，“确定”目标数据是否存在于data block中。\n过滤的原理为：\n若过滤数据显示目标数据不存在于data block中，则目标数据一定不存在于data block中； 若过滤数据显示目标数据存在于data block中，则目标数据可能存在于data block中； 具体的原理可能参见《布隆过滤器》。 因此利用过滤数据可以过滤掉部分data block，避免发生无谓的查找。\n查找data block 在data block中查找目标数据项是一个简单的迭代遍历过程。虽然data block中所有数据项都是按序排序的，但是作者并没有采用“二分查找”来提高查找的效率，而是使用了更大的查找单元进行快速定位。\n与index block的查找类似，data block中，以16条记录为一个查找单元，若entry 1的key小于目标数据项的key，则下一条比较的是entry 17。\n因此查找的过程中，利用更大的查找单元快速定位目标数据项可能存在于哪个区间内，之后依次比较判断其是否存在与data block中。\n可以看到，sstable很多文件格式设计（例如restart point， index block，filter block，max key）在查找的过程中，都极大地提升了整体的查找效率。\n文件特点 只读性 sstable文件为compaction的结果原子性的产生，在其余时间是只读的。\n完整性 一个sstable文件，其辅助数据：\n索引数据 过滤数据 都直接存储于同一个文件中。当读取是需要使用这些辅助数据时，无须额外的磁盘读取；当sstable文件需要删除时，无须额外的数据删除。简要地说，辅助数据随着文件一起创建和销毁。\n并发访问友好性 由于sstable文件具有只读性，因此不存在同一个文件的读写冲突。\nleveldb采用引用计数维护每个文件的引用情况，当一个文件的计数值大于0时，对此文件的删除动作会等到该文件被释放时才进行，因此实现了无锁情况下的并发访问。\nCache一致性 sstable文件为只读的，因此cache中的数据永远于sstable文件中的数据保持一致。\n参考: https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html\n","wordCount":"528","inLanguage":"en","datePublished":"2023-03-16T19:35:09+08:00","dateModified":"2023-03-16T19:35:09+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/posts/storage/rocksdb-sstable/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/posts/>未分类文章</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/posts/storage/>存储, 分布式相关的文章</a></div><h1 class=post-title>RocksDB Sstable</h1><div class=post-description>RocksDB Sstable</div><div class=post-meta><span title='2023-03-16 19:35:09 +0800 +0800'>2023-03-16</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#sstable%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f aria-label=SStable文件格式>SStable文件格式</a><ul><li><a href=#%e7%89%a9%e7%90%86%e7%bb%93%e6%9e%84 aria-label=物理结构>物理结构</a></li><li><a href=#%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84 aria-label=逻辑结构>逻辑结构</a></li><li><a href=#data-block%e7%bb%93%e6%9e%84 aria-label="data block结构">data block结构</a></li><li><a href=#filter-block%e7%bb%93%e6%9e%84 aria-label="filter block结构">filter block结构</a></li><li><a href=#meta-index-block%e7%bb%93%e6%9e%84 aria-label="meta index block结构">meta index block结构</a></li><li><a href=#index-block%e7%bb%93%e6%9e%84 aria-label="index block结构">index block结构</a></li><li><a href=#footer%e7%bb%93%e6%9e%84 aria-label=footer结构>footer结构</a></li></ul></li><li><a href=#%e8%af%bb%e5%86%99%e6%93%8d%e4%bd%9c aria-label=读写操作>读写操作</a><ul><li><a href=#%e5%86%99%e6%93%8d%e4%bd%9c aria-label=写操作>写操作</a></li><li><a href=#tablewriter aria-label=tableWriter>tableWriter</a></li><li><a href=#append aria-label=Append>Append</a></li><li><a href=#datablockappend aria-label=dataBlock.append>dataBlock.append</a></li><li><a href=#filterblockappend aria-label=filterBlock.append>filterBlock.append</a></li><li><a href=#finishblock aria-label=finishBlock>finishBlock</a></li><li><a href=#close aria-label=Close>Close</a></li><li><a href=#%e8%af%bb%e6%93%8d%e4%bd%9c aria-label=读操作>读操作</a></li><li><a href=#%e7%bc%93%e5%ad%98 aria-label=缓存>缓存</a></li><li><a href=#%e5%85%83%e6%95%b0%e6%8d%ae%e8%af%bb%e5%8f%96 aria-label=元数据读取>元数据读取</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e9%a1%b9%e7%9a%84%e5%bf%ab%e9%80%9f%e5%ae%9a%e4%bd%8d aria-label=数据项的快速定位>数据项的快速定位</a></li><li><a href=#%e8%bf%87%e6%bb%a4data-block aria-label="过滤data block">过滤data block</a></li><li><a href=#%e6%9f%a5%e6%89%bedata-block aria-label="查找data block">查找data block</a></li></ul></li><li><a href=#%e6%96%87%e4%bb%b6%e7%89%b9%e7%82%b9 aria-label=文件特点>文件特点</a><ul><li><a href=#%e5%8f%aa%e8%af%bb%e6%80%a7 aria-label=只读性>只读性</a></li><li><a href=#%e5%ae%8c%e6%95%b4%e6%80%a7 aria-label=完整性>完整性</a></li><li><a href=#%e5%b9%b6%e5%8f%91%e8%ae%bf%e9%97%ae%e5%8f%8b%e5%a5%bd%e6%80%a7 aria-label=并发访问友好性>并发访问友好性</a></li><li><a href=#cache%e4%b8%80%e8%87%b4%e6%80%a7 aria-label=Cache一致性>Cache一致性</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h2><p>如我们之前提到的，leveldb是典型的LSM树(Log Structured-Merge Tree)实现，即一次leveldb的写入过程并不是直接将数据持久化到磁盘文件中，而是将写操作首先写入日志文件中，其次将写操作应用在memtable上。</p><p>当leveldb达到checkpoint点（memtable中的数据量超过了预设的阈值），会将当前memtable冻结成一个不可更改的内存数据库（immutable memory db），并且创建一个新的memtable供系统继续使用。</p><p>immutable memory db会在后台进行一次minor compaction，即将内存数据库中的数据持久化到磁盘文件中。</p><blockquote><p>在这里我们暂时不展开讨论minor compaction相关的内容，读者可以简单地理解为将内存中的数据持久化到文件</p></blockquote><p>leveldb（或者说LSM树）设计Minor Compaction的目的是为了：</p><ol><li>有效地降低内存的使用率；</li><li>避免日志文件过大，系统恢复时间过长；</li></ol><p>当memory db的数据被持久化到文件中时，leveldb将以一定规则进行文件组织，这种文件格式成为sstable。在本文中将详细地介绍sstable的文件格式以及相关读写操作。</p><h2 id=sstable文件格式>SStable文件格式<a hidden class=anchor aria-hidden=true href=#sstable文件格式>#</a></h2><h3 id=物理结构>物理结构<a hidden class=anchor aria-hidden=true href=#物理结构>#</a></h3><p>为了提高整体的读写效率，一个sstable文件按照固定大小进行块划分，默认每个块的大小为4KiB。每个Block中，除了存储数据以外，还会存储两个额外的辅助字段：</p><ol><li>压缩类型</li><li>CRC校验码
压缩类型说明了Block中存储的数据是否进行了数据压缩，若是，采用了哪种算法进行压缩。leveldb中默认采用Snappy算法进行压缩。</li></ol><p>CRC校验码是循环冗余校验校验码，校验范围包括数据以及压缩类型。
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.3ld9jnc86t00.webp alt=physicalblock></p><h3 id=逻辑结构>逻辑结构<a hidden class=anchor aria-hidden=true href=#逻辑结构>#</a></h3><p>在逻辑上，根据功能不同，leveldb在逻辑上又将sstable分为：</p><ol><li>data block: 用来存储key value数据对；</li><li>filter block: 用来存储一些过滤器相关的数据（布隆过滤器），但是若用户不指定leveldb使用过滤器，leveldb在该block中不会存储任何内容；</li><li>meta Index block: 用来存储filter block的索引信息（索引信息指在该sstable文件中的偏移量以及数据长度）；</li><li>index block：index block中用来存储每个data block的索引信息；</li><li>footer: 用来存储meta index block及index block的索引信息；</li></ol><p><img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.bb2e2v509e0.webp alt=logicblock>
注意，1-4类型的区块，其物理结构都是如1.1节所示，每个区块都会有自己的压缩信息以及CRC校验码信息。</p><h3 id=data-block结构>data block结构<a hidden class=anchor aria-hidden=true href=#data-block结构>#</a></h3><p>data block中存储的数据是leveldb中的keyvalue键值对。其中一个data block中的数据部分（不包括压缩类型、CRC校验码）按逻辑又以下图进行划分：
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.30rc777jqgo0.webp alt=datablock></p><p>第一部分用来存储keyvalue数据。由于sstable中所有的keyvalue对都是严格按序存储的，为了节省存储空间，leveldb并不会为每一对keyvalue对都存储完整的key值，而是<strong>存储与上一个key非共享的部分</strong>，避免了key重复内容的存储。</p><p>每间隔若干个keyvalue对，将为该条记录重新存储一个完整的key。重复该过程（默认间隔值为16），每个重新存储完整key的点称之为Restart point。</p><blockquote><p>每间隔若干个keyvalue对，将为该条记录重新存储一个完整的key。重复该过程（默认间隔值为16），每个重新存储完整key的点称之为Restart point。</p></blockquote><p>每个数据项的格式如下图所示：
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.3f2ztd32lbi0.webp alt=data></p><p>一个entry分为5部分内容：</p><ol><li>与前一条记录key共享部分的长度；</li><li>与前一条记录key不共享部分的长度；</li><li>value长度；</li><li>与前一条记录key非共享的内容；</li><li>value内容；</li></ol><p>例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>restart_interval</span><span class=o>=</span><span class=m>2</span>
</span></span><span class=line><span class=cl>entry one  : <span class=nv>key</span><span class=o>=</span>deck,value<span class=o>=</span>v1
</span></span><span class=line><span class=cl>entry two  : <span class=nv>key</span><span class=o>=</span>dock,value<span class=o>=</span>v2
</span></span><span class=line><span class=cl>entry three: <span class=nv>key</span><span class=o>=</span>duck,value<span class=o>=</span>v3
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.3f2ztd32lbi0.webp alt=example>
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.4d5d3t6syoe0.webp alt=example>
三组entry按上图的格式进行存储。值得注意的是restart_interval为2，因此每隔两个entry都会有一条数据作为restart point点的数据项，存储完整key值。因此entry3存储了完整的key。</p><p>此外，第一个restart point为0（偏移量），第二个restart point为16，restart point共有两个，因此一个datablock数据段的末尾添加了下图所示的数据：
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.2uwx60qt2t00.webp alt=dataBlockEnd>
尾部数据记录了每一个restart point的值，以及所有restart point的个数。</p><h3 id=filter-block结构>filter block结构<a hidden class=anchor aria-hidden=true href=#filter-block结构>#</a></h3><p>讲完了data block，在这一章节将展开讲述filter block的结构。</p><p>为了加快sstable中数据查询的效率，在直接查询datablock中的内容之前，leveldb首先根据filter block中的过滤数据判断指定的datablock中是否有需要查询的数据，若判断不存在，则无需对这个datablock进行数据查找。</p><p>filter block存储的是data block数据的一些过滤信息。这些过滤数据一般指代布隆过滤器的数据，用于加快查询的速度，关于布隆过滤器的详细内容，可以见《Leveldb源码分析 - 布隆过滤器》。
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.g4uskxodho8.webp alt=filterBlock></p><p>filter block存储的数据主要可以分为两部分：（1）过滤数据（2）索引数据。</p><p>其中索引数据中，filter i offset表示第i个filter data在整个filter block中的起始偏移量，filter offset&rsquo;s offset表示filter block的索引数据在filter block中的偏移量。</p><p>在读取filter block中的内容时，可以首先读出filter offset&rsquo;s offset的值，然后依次读取filter i offset，根据这些offset分别读出filter data。</p><p>Base Lg默认值为11，表示每2KB的数据，创建一个新的过滤器来存放过滤数据。</p><p>一个sstable只有一个filter block，其内存储了所有block的filter数据. 具体来说，filter_data_k 包含了所有起始位置处于 [base<em>k, base</em>(k+1)]范围内的block的key的集合的filter数据，按数据大小而非block切分主要是为了尽量均匀，以应对存在一些block的key很多，另一些block的key很少的情况。</p><blockquote><p>leveldb中，特殊的sstable文件格式设计简化了许多操作，例如：
索引和BloomFilter等元数据可随文件一起创建和销毁，即直接存在文件里，不用加载时动态计算，不用维护更新</p></blockquote><h3 id=meta-index-block结构>meta index block结构<a hidden class=anchor aria-hidden=true href=#meta-index-block结构>#</a></h3><p>meta index block用来存储filter block在整个sstable中的索引信息。</p><p>meta index block只存储一条记录：</p><p>该记录的key为：&ldquo;filter.&ldquo;与过滤器名字组成的常量字符串</p><p>该记录的value为：filter block在sstable中的索引信息序列化后的内容，索引信息包括：（1）在sstable中的偏移量（2）数据长度。</p><h3 id=index-block结构>index block结构<a hidden class=anchor aria-hidden=true href=#index-block结构>#</a></h3><p>与meta index block类似，index block用来存储所有data block的相关索引信息。</p><p>indexblock包含若干条记录，每一条记录代表一个data block的索引信息。</p><p>一条索引包括以下内容：</p><ol><li>data block i 中最大的key值；</li><li>该data block起始地址在sstable中的偏移量；</li><li>该data block的大小；
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.6byko8dyeow.webp alt=index></li></ol><blockquote><p>其中，data block i最大的key值还是index block中该条记录的key值。
如此设计的目的是，依次比较index block中记录信息的key值即可实现快速定位目标数据在哪个data block中。</p></blockquote><h3 id=footer结构>footer结构<a hidden class=anchor aria-hidden=true href=#footer结构>#</a></h3><p>footer大小固定，为48字节，用来存储meta index block与index block在sstable中的索引信息，另外尾部还会存储一个magic word，内容为：&ldquo;<a href=http://code.google.com/p/leveldb/%22>http://code.google.com/p/leveldb/"</a>字符串sha1哈希的前8个字节。
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220322/image.2m8ld5wvxlu0.webp alt=footer></p><hr><h2 id=读写操作>读写操作<a hidden class=anchor aria-hidden=true href=#读写操作>#</a></h2><p>在介绍完sstable文件具体的组织方式之后，我们再来介绍一下相关的读写操作。为了便于读者理解，将首先介绍写操作。</p><h3 id=写操作>写操作<a hidden class=anchor aria-hidden=true href=#写操作>#</a></h3><p>sstable的写操作通常发生在：</p><ul><li>memory db将内容持久化到磁盘文件中时，会创建一个sstable进行写入；</li><li>leveldb后台进行文件compaction时，会将若干个sstable文件的内容重新组织，输出到若干个新的sstable文件中；</li></ul><p>对sstable进行写操作的数据结构为tWriter，具体定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// tWriter wraps the table writer. It keep track of file descriptor
</span></span></span><span class=line><span class=cl><span class=c1>// and added key range.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>tWriter</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>t</span> <span class=o>*</span><span class=nx>tOps</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fd</span> <span class=nx>storage</span><span class=p>.</span><span class=nx>FileDesc</span> <span class=c1>// 文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>w</span>  <span class=nx>storage</span><span class=p>.</span><span class=nx>Writer</span>   <span class=c1>// 文件系统writer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>tw</span> <span class=o>*</span><span class=nx>table</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>first</span><span class=p>,</span> <span class=nx>last</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>主要包括了一个sstable的文件描述符，底层文件系统的writer，该sstable中所有数据项最大最小的key值以及一个内嵌的tableWriter。</p><p>一次sstable的写入为一次不断利用迭代器读取需要写入的数据，并不断调用tableWriter的Append函数，直至所有有效数据读取完毕，为该sstable文件附上元数据的过程。</p><p>该迭代器可以是一个内存数据库的迭代器，写入情景对应着上述的第一种情况；</p><p>该迭代器也可以是一个sstable文件的迭代器，写入情景对应着上述的第二种情况；</p><blockquote><p>sstable的元数据包括：（1）文件编码（2）大小（3）最大key值（4）最小key值</p></blockquote><p>故，理解tableWriter的Append函数是理解整个写入过程的关键。</p><h3 id=tablewriter>tableWriter<a hidden class=anchor aria-hidden=true href=#tablewriter>#</a></h3><p>在介绍append函数之前，首先介绍一下tableWriter这个数据结构。主要的定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Writer is a table writer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Writer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>writer</span> <span class=nx>io</span><span class=p>.</span><span class=nx>Writer</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Options
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>blockSize</span>   <span class=kt>int</span> <span class=c1>// 默认是4KiB
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nx>dataBlock</span>   <span class=nx>blockWriter</span> <span class=c1>// data块Writer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>indexBlock</span>  <span class=nx>blockWriter</span> <span class=c1>// indexBlock块Writer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>filterBlock</span> <span class=nx>filterWriter</span> <span class=c1>// filter块Writer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>pendingBH</span>   <span class=nx>blockHandle</span>
</span></span><span class=line><span class=cl>    <span class=nx>offset</span>      <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>    <span class=nx>nEntries</span>    <span class=kt>int</span> <span class=c1>// key-value键值对个数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其中blockWriter与filterWriter表示底层的两种不同的writer，blockWriter负责写入data数据的写入，而filterWriter负责写入过滤数据。</p><p>pendingBH记录了上一个dataBlock的索引信息，当下一个dataBlock的数据开始写入时，将该索引信息写入indexBlock中。</p><h3 id=append>Append<a hidden class=anchor aria-hidden=true href=#append>#</a></h3><p>一次append函数的主要逻辑如下：</p><ul><li>若本次写入为新dataBlock的第一次写入，则将上一个dataBlock的索引信息写入；</li><li>将keyvalue数据写入datablock;</li><li>将过滤信息写入filterBlock；</li><li>若datablock中的数据超过预定上限，则标志着本次datablock写入结束，将内容刷新到磁盘文件中；</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>w</span> <span class=o>*</span><span class=nx>Writer</span><span class=p>)</span> <span class=nf>Append</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nf>flushPendingBH</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Append key/value pair to the data block.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>w</span><span class=p>.</span><span class=nx>dataBlock</span><span class=p>.</span><span class=nb>append</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Add key to the filter block.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>w</span><span class=p>.</span><span class=nx>filterBlock</span><span class=p>.</span><span class=nf>add</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Finish the data block if block size target reached.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>w</span><span class=p>.</span><span class=nx>dataBlock</span><span class=p>.</span><span class=nf>bytesLen</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=nx>w</span><span class=p>.</span><span class=nx>blockSize</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>w</span><span class=p>.</span><span class=nf>finishBlock</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>w</span><span class=p>.</span><span class=nx>err</span> <span class=p>=</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nx>w</span><span class=p>.</span><span class=nx>err</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>w</span><span class=p>.</span><span class=nx>nEntries</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=datablockappend>dataBlock.append<a hidden class=anchor aria-hidden=true href=#datablockappend>#</a></h3><p>该函数将编码后的kv数据写入到dataBlock对应的buffer中，编码的格式如上文中提到的数据项的格式。此外，在写入的过程中，若该数据项为restart点，则会添加相应的restart point信息。</p><h3 id=filterblockappend>filterBlock.append<a hidden class=anchor aria-hidden=true href=#filterblockappend>#</a></h3><p>该函数将kv数据项的key值加入到过滤信息中，具体可见《Leveldb源码解析 - 布隆过滤器》</p><h3 id=finishblock>finishBlock<a hidden class=anchor aria-hidden=true href=#finishblock>#</a></h3><p>若一个datablock中的数据超过了固定上限，则需要将相关数据写入到磁盘文件中。</p><p>在写入时，需要做以下工作：</p><ol><li>封装dataBlock，记录restart point的个数；</li><li>若dataBlock的数据需要进行压缩（例如snappy压缩算法），则对dataBlock中的数据进行压缩；</li><li>计算checksum；</li><li>封装dataBlock索引信息（offset，length）；</li><li>将datablock的buffer中的数据写入磁盘文件；</li><li>利用这段时间里维护的过滤信息生成过滤数据，放入filterBlock对用的buffer中；</li></ol><h3 id=close>Close<a hidden class=anchor aria-hidden=true href=#close>#</a></h3><p>当迭代器取出所有数据并完成写入后，调用tableWriter的Close函数完成最后的收尾工作：</p><ol><li>若buffer中仍有未写入的数据，封装成一个datablock写入；</li><li>将filterBlock的内容写入磁盘文件；</li><li>将filterBlock的索引信息写入metaIndexBlock中，写入到磁盘文件；</li><li>写入indexBlock的数据；</li><li>写入footer数据；</li></ol><p>至此为止，所有的数据已经被写入到一个sstable中了，由于一个sstable是作为一个memory db或者Compaction的结果原子性落地的，因此在sstable写入完成之后，将进行更为复杂的leveldb的版本更新，将在接下来的文章中继续介绍。</p><h3 id=读操作>读操作<a hidden class=anchor aria-hidden=true href=#读操作>#</a></h3><p>读操作作为写操作的逆过程，充分理解了写操作，将会帮助理解读操作。</p><p>下图为在一个sstable中查找某个数据项的流程图：
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220323/image.4tpfx7gq60c.webp alt=readAction></p><p>大致流程为：</p><ol><li>首先判断“文件句柄”cache中是否有指定sstable文件的文件句柄，若存在，则直接使用cache中的句柄；否则打开该sstable文件，按规则读取该文件的元数据，将新打开的句柄存储至cache中；</li><li>利用sstable中的index block进行快速的数据项位置定位，得到该数据项有可能存在的两个data block；</li><li>利用index block中的索引信息，首先打开第一个可能的data block；</li><li>利用filter block中的过滤信息，判断指定的数据项是否存在于该data block中，若存在，则创建一个迭代器对data block中的数据进行迭代遍历，寻找数据项；若不存在，则结束该data block的查找；</li><li>若在第一个data block中找到了目标数据，则返回结果；若未查找成功，则打开第二个data block，重复步骤4；</li><li>若在第二个data block中找到了目标数据，则返回结果；若未查找成功，则返回Not Found错误信息；</li></ol><h3 id=缓存>缓存<a hidden class=anchor aria-hidden=true href=#缓存>#</a></h3><p>在leveldb中，使用cache来缓存两类数据：</p><ul><li>sstable文件句柄及其元数据；</li><li>data block中的数据；
因此在打开文件之前，首先判断能够在cache中命中sstable的文件句柄，避免重复读取的开销。</li></ul><h3 id=元数据读取>元数据读取<a hidden class=anchor aria-hidden=true href=#元数据读取>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220323/image.6mio1yh24m80.webp alt=metaImg></p><p>由于sstable复杂的文件组织格式，因此在打开文件后，需要读取必要的元数据，才能访问sstable中的数据。</p><p>元数据读取的过程可以分为以下几个步骤：</p><ol><li>读取文件的最后48字节的利用，即Footer数据；</li><li>读取Footer数据中维护的(1) Meta Index Block(2) Index Block两个部分的索引信息并记录，以提高整体的查询效率；</li><li>利用meta index block的索引信息读取该部分的内容；</li><li>遍历meta index block，查看是否存在“有用”的filter block的索引信息，若有，则记录该索引信息；若没有，则表示当前sstable中不存在任何过滤信息来提高查询效率；</li></ol><h3 id=数据项的快速定位>数据项的快速定位<a hidden class=anchor aria-hidden=true href=#数据项的快速定位>#</a></h3><p>sstable中存在多个data block，倘若依次进行“遍历”显然是不可取的。但是由于一个sstable中所有的数据项都是按序排列的，因此可以利用有序性已经index block中维护的索引信息快速定位目标数据项可能存在的data block。</p><p>一个index block的文件结构示意图如下：
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220323/image.7fxq2iis1t0.webp alt=indexBlock></p><p>index block是由一系列的键值对组成，每一个键值对表示一个data block的索引信息。</p><p>键值对的key为该data block中数据项key的最大值，value为该data block的索引信息（offset, length）。</p><p>因此若需要查找目标数据项，仅仅需要依次比较index block中的这些索引信息，倘若目标数据项的key大于某个data block中最大的key值，则该data block中必然不存在目标数据项。故通过这个步骤的优化，可以直接确定目标数据项落在哪个data block的范围区间内。</p><blockquote><p>值得注意的是，与data block一样，index block中的索引信息同样也进行了key值截取，即第二个索引信息的key并不是存储完整的key，而是存储与前一个索引信息的key不共享的部分，区别在于data block中这种范围的划分粒度为16，而index block中为2 。
也就是说，index block连续两条索引信息会被作为一个最小的“比较单元“，在查找的过程中，若第一个索引信息的key小于目标数据项的key，则紧接着会比较第三条索引信息的key。
这就导致最终目标数据项的范围区间为某”两个“data block。</p></blockquote><p><img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220323/image.5rcdilc2nj40.webp alt=findIndexBlock></p><h3 id=过滤data-block>过滤data block<a hidden class=anchor aria-hidden=true href=#过滤data-block>#</a></h3><p>若sstable存有每一个data block的过滤数据，则可以利用这些过滤数据对data block中的内容进行判断，“确定”目标数据是否存在于data block中。</p><p>过滤的原理为：</p><ul><li>若过滤数据显示目标数据不存在于data block中，则目标数据一定不存在于data block中；</li><li>若过滤数据显示目标数据存在于data block中，则目标数据可能存在于data block中；
具体的原理可能参见《布隆过滤器》。</li></ul><p>因此利用过滤数据可以过滤掉部分data block，避免发生无谓的查找。</p><h3 id=查找data-block>查找data block<a hidden class=anchor aria-hidden=true href=#查找data-block>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220323/image.owtqzg8dryo.webp alt=dataBlock>
在data block中查找目标数据项是一个简单的迭代遍历过程。虽然data block中所有数据项都是按序排序的，但是作者并没有采用“二分查找”来提高查找的效率，而是使用了更大的查找单元进行快速定位。</p><p>与index block的查找类似，data block中，以16条记录为一个查找单元，若entry 1的key小于目标数据项的key，则下一条比较的是entry 17。</p><p>因此查找的过程中，利用更大的查找单元快速定位目标数据项可能存在于哪个区间内，之后依次比较判断其是否存在与data block中。</p><p>可以看到，sstable很多文件格式设计（例如restart point， index block，filter block，max key）在查找的过程中，都极大地提升了整体的查找效率。</p><h2 id=文件特点>文件特点<a hidden class=anchor aria-hidden=true href=#文件特点>#</a></h2><h3 id=只读性>只读性<a hidden class=anchor aria-hidden=true href=#只读性>#</a></h3><p>sstable文件为compaction的结果原子性的产生，在其余时间是只读的。</p><h3 id=完整性>完整性<a hidden class=anchor aria-hidden=true href=#完整性>#</a></h3><p>一个sstable文件，其辅助数据：</p><ul><li>索引数据</li><li>过滤数据</li></ul><p>都直接存储于同一个文件中。当读取是需要使用这些辅助数据时，无须额外的磁盘读取；当sstable文件需要删除时，无须额外的数据删除。简要地说，辅助数据随着文件一起创建和销毁。</p><h3 id=并发访问友好性>并发访问友好性<a hidden class=anchor aria-hidden=true href=#并发访问友好性>#</a></h3><p>由于sstable文件具有只读性，因此不存在同一个文件的读写冲突。</p><p>leveldb采用引用计数维护每个文件的引用情况，当一个文件的计数值大于0时，对此文件的删除动作会等到该文件被释放时才进行，因此实现了无锁情况下的并发访问。</p><h3 id=cache一致性>Cache一致性<a hidden class=anchor aria-hidden=true href=#cache一致性>#</a></h3><p>sstable文件为只读的，因此cache中的数据永远于sstable文件中的数据保持一致。</p><hr><p>参考: <a href=https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html>https://leveldb-handbook.readthedocs.io/zh/latest/sstable.html</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/tags/sst/>SST</a></li><li><a href=https://reid00.github.io/tags/rocksdb/>RocksDB</a></li><li><a href=https://reid00.github.io/tags/leveldb/>LevelDB</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/posts/langs_linux/unicode%E7%BC%96%E7%A0%81%E4%B8%8Epython/><span class=title>« Prev</span><br><span>Unicode编码与Python</span></a>
<a class=next href=https://reid00.github.io/posts/os_network/tcp-ip%E5%8D%8F%E8%AE%AE/><span class=title>Next »</span><br><span>TCP IP协议</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://reid00.github.io/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>