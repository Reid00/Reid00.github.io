<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MIT6.824 2022 Lab3 RaftKV | Reid's Blog</title><meta name=keywords content="Raft,MIT6.824,Consensus,共识算法"><meta name=description content="MIT6.824 2022 Lab3 RaftKV"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/posts/storage/mit6.824-2022-lab3-raftkv/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK",{anonymize_ip:!1})}</script><meta property="og:title" content="MIT6.824 2022 Lab3 RaftKV"><meta property="og:description" content="MIT6.824 2022 Lab3 RaftKV"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/posts/storage/mit6.824-2022-lab3-raftkv/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:34:58+08:00"><meta property="article:modified_time" content="2023-03-16T19:34:58+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="MIT6.824 2022 Lab3 RaftKV"><meta name=twitter:description content="MIT6.824 2022 Lab3 RaftKV"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/posts/"},{"@type":"ListItem","position":2,"name":"MIT6.824 2022 Lab3 RaftKV","item":"https://reid00.github.io/posts/storage/mit6.824-2022-lab3-raftkv/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MIT6.824 2022 Lab3 RaftKV","name":"MIT6.824 2022 Lab3 RaftKV","description":"MIT6.824 2022 Lab3 RaftKV","keywords":["Raft","MIT6.824","Consensus","共识算法"],"articleBody":"介绍 在lab2的Raft函数库之上，搭建一个能够容错的key/value存储服务，需要提供强一致性保证。\n强一致性介绍 对于单个请求，整个服务需要表现得像个单机服务，并且对状态机的修改基于之前所有的请求。对于并发的请求，返回的值和最终的状态必须相同，就好像所有请求都是串行的一样。即使有些请求发生在了同一时间，那么也应当一个一个响应。此外，在一个请求被执行之前，这之前的请求都必须已经被完成（在技术上我们也叫着线性化（linearizability））。 kv服务支持三种操作：Put, Append, Get。通过在内存维护一个简单的键/值对数据库，键和值都是字符串；\n整体架构 简化来看 在正式开始前，要了解论文-extend-version中section 7和8的内容。\n相关的RPC 在Raft 作者的博士论文中的6.3- Implementing linearizable semantics 小结有很详细的介绍，建议先阅读。\nRPC Lab3A - 不需要日志压缩的Key/Value服务 考虑这样一个场景，客户端向服务端提交了一条日志，服务端将其在 raft 组中进行了同步并成功 commit，接着在 apply 后返回给客户端执行结果。然而不幸的是，该 rpc 在传输中发生了丢失，客户端并没有收到写入成功的回复。因此，客户端只能进行重试直到明确地写入成功或失败为止，这就可能会导致相同地命令被执行多次，从而违背线性一致性。\n有人可能认为，只要写请求是幂等的，那重复执行多次也是可以满足线性一致性的，实际上则不然。考虑这样一个例子：对于一个仅支持 put 和 get 接口的 raftKV 系统，其每个请求都具有幂等性。设 x 的初始值为 0，此时有两个并发客户端，客户端 1 执行 put(x,1)，客户端 2 执行 get(x) 再执行 put(x,2)，问（客户端 2 读到的值，x 的最终值）是多少。对于线性一致的系统，答案可以是 (0,1)，(0,2) 或 (1,2)。然而，如果客户端 1 执行 put 请求时发生了上段描述的情况，然后客户端 2 读到 x 的值为 1 并将 x 置为了 2，最后客户端 1 超时重试且再次将 x 置为 1。对于这种场景，答案是 (1,1)，这就违背了线性一致性。归根究底还是由于幂等的 put(x,1) 请求在状态机上执行了两次，有两个 LZ 点。因此，即使写请求的业务语义能够保证幂等，不进行额外的处理让其重复执行多次也会破坏线性一致性。当然，读请求由于不改变系统的状态，重复执行多次是没问题的。\n对于这个问题，raft 作者介绍了想要实现线性化语义，就需要保证日志仅被执行一次，即它可以被 commit 多次，但一定只能 apply 一次。其解决方案原文如下：\nThe solution is for clients to assign unique serial numbers to every command. Then, the state machine tracks the latest serial number processed for each client, along with the associated response. If it receives a command whose serial number has already been executed, it responds immediately without re-executing the request.\n思路可以是：\n每个 client 都需要一个唯一的标识符，它的每个不同命令需要有一个顺序递增的 commandId，clientId 和这个 commandId，clientId 可以唯一确定一个不同的命令，从而使得各个 raft 节点可以记录保存各命令是否已应用以及应用以后的结果。 也可以参考此处dragonboat 作者讨论\n为什么要记录应用的结果？因为通过这种方式同一个命令的多次 apply 最终只会实际应用到状态机上一次，之后相同命令 apply 的时候实际上是不应用到状态机上的而是直接从保存的结果中返回的。\n如果默认一个客户端只能串行执行请求的话，服务端这边只需要记录一个 map，其 key 是 clientId，其 value 是该 clientId 执行的最后一条日志的 commandId 和状态机的输出即可CommandResponse。\n客户端 一个 client 可以通过为其处理的每条命令递增 commandId 的方式来确保不同的命令一定有不同的 commandId，当然，同一条命令的 commandId 在没有处理完毕之前，即明确收到服务端的写入成功或失败之前是不能改变的。\n代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 package kvraft import ( \"crypto/rand\" \"math/big\" \"6.824/labrpc\" ) type Clerk struct { servers []*labrpc.ClientEnd // You will have to modify this struct. leaderId int64 // generated by nrand(), it would be better to use some distributed ID // generation algorithm that guarantees no conflicts clientId int64 commandId int64 // (clientId, commandId) defines a operation uniquely } func nrand() int64 { max := big.NewInt(int64(1) \u003c\u003c 62) bigx, _ := rand.Int(rand.Reader, max) x := bigx.Int64() return x } func MakeClerk(servers []*labrpc.ClientEnd) *Clerk { return \u0026Clerk{ servers: servers, leaderId: 0, clientId: nrand(), commandId: 0, } } // fetch the current value for a key. // returns \"\" if the key does not exist. // keeps trying forever in the face of all other errors. // // you can send an RPC with code like this: // ok := ck.servers[i].Call(\"KVServer.Get\", \u0026args, \u0026reply) // // the types of args and reply (including whether they are pointers) // must match the declared types of the RPC handler function's // arguments. and reply must be passed as a pointer. func (ck *Clerk) Get(key string) string { // You will have to modify this function. return ck.Command(\u0026CommandRequest{ Key: key, Op: OpGet, ClientId: ck.clientId, CommandId: ck.commandId, }) } func (ck *Clerk) Put(key string, value string) { ck.Command(\u0026CommandRequest{ Key: key, Value: value, Op: OpPut, ClientId: ck.clientId, CommandId: ck.commandId, }) } func (ck *Clerk) Append(key string, value string) { ck.Command(\u0026CommandRequest{ Key: key, Value: value, Op: OpAppend, ClientId: ck.clientId, CommandId: ck.commandId, }) } func (ck *Clerk) Command(req *CommandRequest) string { // req.ClientId, req.CommandId = ck.clientId, ck.commandId for { var resp CommandResponse if !ck.servers[ck.leaderId].Call(\"KVServer.Command\", req, \u0026resp) || resp.Err == ErrWrongLeader || resp.Err == ErrTimeout { // 不知leader 轮询所有的server 尝试发出请求 ck.leaderId = (ck.leaderId + 1) % int64(len(ck.servers)) continue } ck.commandId++ return resp.Value } } 服务端 整体请求逻辑如下： Server结构体与初始化代码实现：\n一个存储kv的map，即状态机，但这里实现一个基于内存版本KV即可的，但实际生产环境下必然不可能把数据全部存在内存当中，系统往往采用的是 LSM 的架构，例如 RocksDB 等，抽象成KVStateMachine 的接口。 一个能记录某一个客户端最后一次操作序号和应用结果的map lastOperations (类比Nebula 中的session 作用) 一个能记录每个raft同步操作结果的map notifyChans 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 type KVServer struct { mu sync.RWMutex me int rf *raft.Raft applyCh chan raft.ApplyMsg dead int32 // set by Kill() maxRaftState int // snapshot if log grows this big // Your definitions here. lastApplied int // record the lastApplied index to prevent stateMachine from rollback stateMachine KVStateMachine // KV stateMachine // 客户端id最后的命令id和回复内容 （clientId，{最后的commdId，最后的LastReply}） lastOperations map[int64]OperationContext // Leader回复给客户端的响应（LogIndex， CommandResponse notifyChans map[int]chan *CommandResponse } 应用到状态机的流程 kv.applier协程：单独开一个goroutine来远程监听 Raft 的apply channel，一旦底层的Raft commit一个到apply channel，状态机就立马执行且通过 commandIndex(即raft 中的CommitIndex) 通知到该客户端的NotifyChan, Command函数取消阻塞返回给客户端。\n要点:\nraft同步完成后，也需要判断请求是否为重复请求。因为同一请求可能由于重试会被同步多次。 对于客户端的请求，rpc 框架也会生成一个协程去处理逻辑。因此，需要考虑清楚这些协程之间的通信关系。为此，我的实现是客户端协程将日志放入 raft 层去同步后即注册一个 channel 去阻塞等待，接着 apply 协程监控 applyCh，在得到 raft 层已经 commit 的日志后，apply 协程首先将其 apply 到状态机中，接着根据 index 得到对应的 channel ，最后将状态机执行的结果 push 到 channel 中，这使得客户端协程能够解除阻塞并回复结果给客户端 为了保证强一致性，仅对当前 term 日志的 notifyChan 进行通知，让之前 term 的客户端协程都超时重试。避免leader 降级为 follower 后又迅速重新当选了 leader，而此时依然有客户端协程未超时在阻塞等待，那么此时 apply 日志后，根据 index 获得 channel 并向其中 push 执行结果就可能出错，因为可能并不对应。 在目前的实现中，读（Get）请求也会生成一条 raft 日志去同步，最简单粗暴的方式保证线性一致性，即LogRead方法。但是，这样子实现的读性能会相当的差，实际生产级别的 raft 读请求实现一般都采用了 Read Index 或者 Lease Read 的方式，具体原理可以参考此线性一致性博客，具体实现可以参照 SOFAJRaft 的实现博客。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 func (kv *KVServer) applier() { for !kv.killed() { for msg := range kv.applyCh { DPrintf(\"[applier] - {Node: %v} tries to apply message %v\", kv.rf.Me(), msg) if msg.CommandValid { kv.mu.Lock() if msg.CommandIndex \u003c= kv.lastApplied { DPrintf(\"[applier] - {Node: %v} discards outdated message %v since a newer snapshot which lastapplied is %v has been restored\", kv.rf.Me(), msg, kv.lastApplied) kv.mu.Unlock() continue } kv.lastApplied = msg.CommandIndex var resp = new(CommandResponse) command := msg.Command.(Command) if command.Op != OpGet \u0026\u0026 kv.isDuplicatedReq(command.ClientId, command.CommandId) { DPrintf(\"[applier] - {Node: %v} doesn't apply duplicated message %v to state machine since maxAppliedCommandId is %v for client %v\", kv.rf.Me(), msg, kv.lastOperations[command.ClientId], command.ClientId) resp = kv.lastOperations[command.ClientId].LastResponse } else { resp = kv.applyLogToStateMachine(command) if command.Op != OpGet { kv.lastOperations[command.ClientId] = OperationContext{ MaxAppliedCommandId: command.CommandId, LastResponse: resp, } } } // 记录每个idx apply 到state machine 的 CommandResponse // 为了保证强一致性，仅对当前 term 日志的 notifyChan 进行通知， // 让之前 term 的客户端协程都超时重试。避免leader 降级为 follower // 后又迅速重新当选了 leader，而此时依然有客户端协程未超时在阻塞等待， // 那么此时 apply 日志后，根据 index 获得 channel 并向其中 push 执行结果就可能出错，因为可能并不对应 if currentTerm, isLeader := kv.rf.GetState(); isLeader \u0026\u0026 msg.CommandTerm == currentTerm { ch := kv.getNotifyChan(msg.CommandIndex) ch \u003c- resp } // part 2 needSnapshot := kv.needSnapshot() if needSnapshot { kv.takeSnapshot(msg.CommandIndex) } kv.mu.Unlock() } else if msg.SnapshotValid { kv.mu.Lock() if kv.rf.CondInstallSnapshot(msg.SnapshotTerm, msg.SnapshotIndex, msg.Snapshot) { kv.restoreSnapshot(msg.Snapshot) kv.lastApplied = msg.SnapshotIndex } kv.mu.Unlock() } else { panic(fmt.Sprintf(\"unexpected Message: %v\", msg)) } } } } leader 比 follower 多出一个 notifyChan 环节，是因为 leader 需要处理 rpc 请求响应，而 follower 不用，一个很简单的流程其实就是 client -\u003e kvservice -\u003e Start() -\u003e applyCh -\u003e kvservice -\u003e client，但是applyCh是逐个 commit 一个一个返回，所以需要明确返回的 commit 对应的是哪一个请求，即通过 commitIndex唯一确定一个请求，然后通知该请求执行流程可以返回了。\n对于读请求，由于其不影响系统状态，所以直接去状态机执行即可，当然，其结果也不需要再记录到去重的数据结构中。\nCommandRPC 逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Command 客户端调用的RPC方法 func (kv *KVServer) Command(req *CommandRequest, resp *CommandResponse) { defer DPrintf(\"[Command]- {Node: %v} processes CommandReq %v with CommandResp %v\", kv.rf.Me(), req, resp) // 如果请求是重复的，直接在 OperationContext 中拿到之前的结果返回 kv.mu.RLock() if req.Op != OpGet \u0026\u0026 kv.isDuplicatedReq(req.ClientId, req.CommandId) { lastResp := kv.lastOperations[req.ClientId].LastResponse resp.Value, resp.Err = lastResp.Value, lastResp.Err kv.mu.RUnlock() return } kv.mu.RUnlock() idx, _, isLeader := kv.rf.Start(Command{req}) if !isLeader { resp.Err = ErrWrongLeader return } kv.mu.Lock() ch := kv.getNotifyChan(idx) kv.mu.Unlock() select { case result := \u003c-ch: resp.Value, resp.Err = result.Value, result.Err case \u003c-time.After(ExecuteTimeOut): resp.Err = ErrTimeout } go func() { kv.mu.Lock() kv.removeOutdatedNotifyChan(idx) kv.mu.Unlock() }() } Lab3B - 日志压缩 首先，日志的 snapshot 不仅需要包含状态机的状态，还需要包含用来去重的 lastOperations 哈希表。\n其次，apply 协程负责持锁阻塞式的去生成 snapshot，幸运的是，此时 raft 框架是不阻塞的，依然可以同步并提交日志，只是不 apply 而已。如果这里还想进一步优化的话，可以将状态机搞成 MVCC 等能够 COW 的机制，这样应该就可以不阻塞状态机的更新了\n优化: 项目中 LastOperations 和 NotifyChan 都是使用map 不能并发安全，用了一张大锁保平安。 实际上可以使用Sync.Map 然后将锁的粒度细化来优化这块\n","wordCount":"1185","inLanguage":"en","datePublished":"2023-03-16T19:34:58+08:00","dateModified":"2023-03-16T19:34:58+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/posts/storage/mit6.824-2022-lab3-raftkv/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/posts/>Posts</a></div><h1 class=post-title>MIT6.824 2022 Lab3 RaftKV</h1><div class=post-description>MIT6.824 2022 Lab3 RaftKV</div><div class=post-meta><span title='2023-03-16 19:34:58 +0800 +0800'>2023-03-16</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a><ul><li><a href=#rpc aria-label=RPC>RPC</a></li></ul></li><li><a href=#lab3a---%e4%b8%8d%e9%9c%80%e8%a6%81%e6%97%a5%e5%bf%97%e5%8e%8b%e7%bc%a9%e7%9a%84keyvalue%e6%9c%8d%e5%8a%a1 aria-label="Lab3A - 不需要日志压缩的Key/Value服务">Lab3A - 不需要日志压缩的Key/Value服务</a><ul><li><a href=#%e5%ae%a2%e6%88%b7%e7%ab%af aria-label=客户端>客户端</a></li><li><a href=#%e6%9c%8d%e5%8a%a1%e7%ab%af aria-label=服务端>服务端</a><ul><li><a href=#%e5%ba%94%e7%94%a8%e5%88%b0%e7%8a%b6%e6%80%81%e6%9c%ba%e7%9a%84%e6%b5%81%e7%a8%8b aria-label=应用到状态机的流程>应用到状态机的流程</a></li><li><a href=#commandrpc-%e9%80%bb%e8%be%91 aria-label="CommandRPC 逻辑">CommandRPC 逻辑</a></li></ul></li></ul></li><li><a href=#lab3b---%e6%97%a5%e5%bf%97%e5%8e%8b%e7%bc%a9 aria-label="Lab3B - 日志压缩">Lab3B - 日志压缩</a></li></ul></div></details></div><div class=post-content><h1 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h1><p>在lab2的Raft函数库之上，搭建一个能够容错的key/value存储服务，需要提供强一致性保证。</p><ul><li>强一致性介绍
对于单个请求，整个服务需要表现得像个单机服务，并且对状态机的修改基于之前所有的请求。对于并发的请求，返回的值和最终的状态必须相同，就好像所有请求都是串行的一样。即使有些请求发生在了同一时间，那么也应当一个一个响应。此外，在一个请求被执行之前，这之前的请求都必须已经被完成（在技术上我们也叫着线性化（linearizability））。</li></ul><p>kv服务支持三种操作：Put, Append, Get。通过在内存维护一个简单的键/值对数据库，键和值都是字符串；</p><p>整体架构
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230214/image.1jxepdafa38g.webp alt=skeleton></p><p>简化来看
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230214/image.3mvf55imrq00.webp alt=skeleton-simple></p><p>在正式开始前，要了解<a href=https://raft.github.io/raft.pdf>论文-extend-version</a>中section 7和8的内容。</p><p>相关的RPC 在<code>Raft</code> 作者的<a href=https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf>博士论文</a>中的6.3- Implementing linearizable semantics 小结有很详细的介绍，建议先阅读。</p><h2 id=rpc>RPC<a hidden class=anchor aria-hidden=true href=#rpc>#</a></h2><p><img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230214/image.1ty2yezd7bds.webp alt=RPC></p><h1 id=lab3a---不需要日志压缩的keyvalue服务>Lab3A - 不需要日志压缩的Key/Value服务<a hidden class=anchor aria-hidden=true href=#lab3a---不需要日志压缩的keyvalue服务>#</a></h1><p>考虑这样一个场景，客户端向服务端提交了一条日志，服务端将其在 <code>raft</code> 组中进行了同步并成功 commit，接着在 apply 后返回给客户端执行结果。然而不幸的是，该 rpc 在传输中发生了丢失，客户端并没有收到写入成功的回复。因此，客户端只能进行重试直到明确地写入成功或失败为止，这就可能会导致相同地命令被执行多次，从而违背线性一致性。</p><p>有人可能认为，只要写请求是幂等的，那重复执行多次也是可以满足线性一致性的，实际上则不然。考虑这样一个例子：对于一个仅支持 put 和 get 接口的 raftKV 系统，其每个请求都具有幂等性。设 x 的初始值为 0，此时有两个并发客户端，客户端 1 执行 put(x,1)，客户端 2 执行 get(x) 再执行 put(x,2)，问（客户端 2 读到的值，x 的最终值）是多少。对于线性一致的系统，答案可以是 (0,1)，(0,2) 或 (1,2)。然而，如果客户端 1 执行 put 请求时发生了上段描述的情况，然后客户端 2 读到 x 的值为 1 并将 x 置为了 2，最后客户端 1 超时重试且再次将 x 置为 1。对于这种场景，答案是 (1,1)，这就违背了线性一致性。归根究底还是由于幂等的 put(x,1) 请求在状态机上执行了两次，有两个 LZ 点。因此，即使写请求的业务语义能够保证幂等，不进行额外的处理让其重复执行多次也会破坏线性一致性。当然，读请求由于不改变系统的状态，重复执行多次是没问题的。</p><p>对于这个问题，raft 作者介绍了想要实现线性化语义，就需要保证日志仅被执行一次，即它可以被 commit 多次，但一定只能 apply 一次。其解决方案原文如下：</p><blockquote><p>The solution is for clients to assign unique serial numbers to every command. Then, the state machine tracks the latest serial number processed for each client, along with the associated response. If it receives a command whose serial number has already been executed, it responds immediately without re-executing the request.</p></blockquote><p>思路可以是：</p><ul><li>每个 client 都需要一个唯一的标识符，它的每个不同命令需要有一个顺序递增的 commandId，clientId 和这个 commandId，clientId 可以唯一确定一个不同的命令，从而使得各个 raft 节点可以记录保存各命令是否已应用以及应用以后的结果。</li></ul><p>也可以参考此处dragonboat 作者<a href=https://www.zhihu.com/question/278551592>讨论</a></p><p>为什么要记录应用的结果？因为通过这种方式同一个命令的多次 apply 最终只会实际应用到状态机上一次，之后相同命令 apply 的时候实际上是不应用到状态机上的而是直接从保存的结果中返回的。</p><p>如果默认一个客户端只能串行执行请求的话，服务端这边只需要记录一个 map，其 key 是 clientId，其 value 是该 clientId 执行的最后一条日志的 commandId 和状态机的输出即可CommandResponse。</p><h2 id=客户端>客户端<a hidden class=anchor aria-hidden=true href=#客户端>#</a></h2><p>一个 client 可以通过为其处理的每条命令递增 commandId 的方式来确保不同的命令一定有不同的 commandId，当然，同一条命令的 commandId 在没有处理完毕之前，即明确收到服务端的写入成功或失败之前是不能改变的。</p><p>代码如下:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>package</span> <span class=nx>kvraft</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;crypto/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/big&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=s>&#34;6.824/labrpc&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Clerk</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>servers</span> <span class=p>[]</span><span class=o>*</span><span class=nx>labrpc</span><span class=p>.</span><span class=nx>ClientEnd</span>
</span></span><span class=line><span class=cl>	<span class=c1>// You will have to modify this struct.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>leaderId</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=c1>// generated by nrand(), it would be better to use some distributed ID
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// generation algorithm that guarantees no conflicts
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>clientId</span>  <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=nx>commandId</span> <span class=kt>int64</span> <span class=c1>// (clientId, commandId) defines a operation uniquely
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>nrand</span><span class=p>()</span> <span class=kt>int64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>max</span> <span class=o>:=</span> <span class=nx>big</span><span class=p>.</span><span class=nf>NewInt</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>62</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>bigx</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Int</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nx>Reader</span><span class=p>,</span> <span class=nx>max</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>x</span> <span class=o>:=</span> <span class=nx>bigx</span><span class=p>.</span><span class=nf>Int64</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>MakeClerk</span><span class=p>(</span><span class=nx>servers</span> <span class=p>[]</span><span class=o>*</span><span class=nx>labrpc</span><span class=p>.</span><span class=nx>ClientEnd</span><span class=p>)</span> <span class=o>*</span><span class=nx>Clerk</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>Clerk</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>servers</span><span class=p>:</span>   <span class=nx>servers</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>leaderId</span><span class=p>:</span>  <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>clientId</span><span class=p>:</span>  <span class=nf>nrand</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>		<span class=nx>commandId</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fetch the current value for a key.
</span></span></span><span class=line><span class=cl><span class=c1>// returns &#34;&#34; if the key does not exist.
</span></span></span><span class=line><span class=cl><span class=c1>// keeps trying forever in the face of all other errors.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// you can send an RPC with code like this:
</span></span></span><span class=line><span class=cl><span class=c1>// ok := ck.servers[i].Call(&#34;KVServer.Get&#34;, &amp;args, &amp;reply)
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// the types of args and reply (including whether they are pointers)
</span></span></span><span class=line><span class=cl><span class=c1>// must match the declared types of the RPC handler function&#39;s
</span></span></span><span class=line><span class=cl><span class=c1>// arguments. and reply must be passed as a pointer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>Get</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// You will have to modify this function.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=nx>ck</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>CommandRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Key</span><span class=p>:</span>       <span class=nx>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Op</span><span class=p>:</span>        <span class=nx>OpGet</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>ClientId</span><span class=p>:</span>  <span class=nx>ck</span><span class=p>.</span><span class=nx>clientId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>CommandId</span><span class=p>:</span> <span class=nx>ck</span><span class=p>.</span><span class=nx>commandId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>Put</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>value</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ck</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>CommandRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Key</span><span class=p>:</span>       <span class=nx>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Value</span><span class=p>:</span>     <span class=nx>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Op</span><span class=p>:</span>        <span class=nx>OpPut</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>ClientId</span><span class=p>:</span>  <span class=nx>ck</span><span class=p>.</span><span class=nx>clientId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>CommandId</span><span class=p>:</span> <span class=nx>ck</span><span class=p>.</span><span class=nx>commandId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>Append</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>value</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>ck</span><span class=p>.</span><span class=nf>Command</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>CommandRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Key</span><span class=p>:</span>       <span class=nx>key</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Value</span><span class=p>:</span>     <span class=nx>value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>Op</span><span class=p>:</span>        <span class=nx>OpAppend</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>ClientId</span><span class=p>:</span>  <span class=nx>ck</span><span class=p>.</span><span class=nx>clientId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>CommandId</span><span class=p>:</span> <span class=nx>ck</span><span class=p>.</span><span class=nx>commandId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>ck</span> <span class=o>*</span><span class=nx>Clerk</span><span class=p>)</span> <span class=nf>Command</span><span class=p>(</span><span class=nx>req</span> <span class=o>*</span><span class=nx>CommandRequest</span><span class=p>)</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// req.ClientId, req.CommandId = ck.clientId, ck.commandId
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=nx>resp</span> <span class=nx>CommandResponse</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>!</span><span class=nx>ck</span><span class=p>.</span><span class=nx>servers</span><span class=p>[</span><span class=nx>ck</span><span class=p>.</span><span class=nx>leaderId</span><span class=p>].</span><span class=nf>Call</span><span class=p>(</span><span class=s>&#34;KVServer.Command&#34;</span><span class=p>,</span> <span class=nx>req</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>resp</span><span class=p>)</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>			<span class=nx>resp</span><span class=p>.</span><span class=nx>Err</span> <span class=o>==</span> <span class=nx>ErrWrongLeader</span> <span class=o>||</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Err</span> <span class=o>==</span> <span class=nx>ErrTimeout</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// 不知leader 轮询所有的server 尝试发出请求
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nx>ck</span><span class=p>.</span><span class=nx>leaderId</span> <span class=p>=</span> <span class=p>(</span><span class=nx>ck</span><span class=p>.</span><span class=nx>leaderId</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=nb>int64</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>ck</span><span class=p>.</span><span class=nx>servers</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>ck</span><span class=p>.</span><span class=nx>commandId</span><span class=o>++</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Value</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=服务端>服务端<a hidden class=anchor aria-hidden=true href=#服务端>#</a></h2><p>整体请求逻辑如下：
<img loading=lazy src=https://cdn.staticaly.com/gh/Reid00/image-host@main/20230214/image.3mvf55imrq00.webp alt=logic></p><p><code>Server</code>结构体与初始化代码实现：</p><ol><li>一个存储kv的map，即状态机，但这里实现一个基于内存版本KV即可的，但实际生产环境下必然不可能把数据全部存在内存当中，系统往往采用的是 LSM 的架构，例如 RocksDB 等，抽象成KVStateMachine 的接口。</li><li>一个能记录某一个客户端最后一次操作序号和应用结果的map <code>lastOperations</code> (类比Nebula 中的session 作用)</li><li>一个能记录每个raft同步操作结果的map <code>notifyChans</code></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>KVServer</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mu</span>      <span class=nx>sync</span><span class=p>.</span><span class=nx>RWMutex</span>
</span></span><span class=line><span class=cl>	<span class=nx>me</span>      <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>rf</span>      <span class=o>*</span><span class=nx>raft</span><span class=p>.</span><span class=nx>Raft</span>
</span></span><span class=line><span class=cl>	<span class=nx>applyCh</span> <span class=kd>chan</span> <span class=nx>raft</span><span class=p>.</span><span class=nx>ApplyMsg</span>
</span></span><span class=line><span class=cl>	<span class=nx>dead</span>    <span class=kt>int32</span> <span class=c1>// set by Kill()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>maxRaftState</span> <span class=kt>int</span> <span class=c1>// snapshot if log grows this big
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// Your definitions here.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>lastApplied</span>  <span class=kt>int</span>            <span class=c1>// record the lastApplied index to prevent stateMachine from rollback
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>stateMachine</span> <span class=nx>KVStateMachine</span> <span class=c1>// KV stateMachine
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// 客户端id最后的命令id和回复内容 （clientId，{最后的commdId，最后的LastReply}）
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>lastOperations</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int64</span><span class=p>]</span><span class=nx>OperationContext</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Leader回复给客户端的响应（LogIndex， CommandResponse
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>notifyChans</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kd>chan</span> <span class=o>*</span><span class=nx>CommandResponse</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=应用到状态机的流程>应用到状态机的流程<a hidden class=anchor aria-hidden=true href=#应用到状态机的流程>#</a></h3><p>kv.applier协程：单独开一个goroutine来远程监听 Raft 的apply channel，一旦底层的Raft commit一个到apply channel，状态机就立马执行且通过 commandIndex(即raft 中的CommitIndex) 通知到该客户端的NotifyChan, Command函数取消阻塞返回给客户端。</p><p>要点:</p><ul><li>raft同步完成后，也需要判断请求是否为重复请求。因为同一请求可能由于重试会被同步多次。</li><li>对于客户端的请求，rpc 框架也会生成一个协程去处理逻辑。因此，需要考虑清楚这些协程之间的通信关系。为此，我的实现是客户端协程将日志放入 raft 层去同步后即注册一个 channel 去阻塞等待，接着 apply 协程监控 applyCh，在得到 raft 层已经 commit 的日志后，apply 协程首先将其 apply 到状态机中，接着根据 index 得到对应的 channel ，最后将状态机执行的结果 push 到 channel 中，这使得客户端协程能够解除阻塞并回复结果给客户端</li><li>为了保证强一致性，仅对当前 term 日志的 notifyChan 进行通知，让之前 term 的客户端协程都超时重试。避免leader 降级为 follower 后又迅速重新当选了 leader，而此时依然有客户端协程未超时在阻塞等待，那么此时 apply 日志后，根据 index 获得 channel 并向其中 push 执行结果就可能出错，因为可能并不对应。</li><li>在目前的实现中，读（Get）请求也会生成一条 raft 日志去同步，最简单粗暴的方式保证线性一致性，即LogRead方法。但是，这样子实现的读性能会相当的差，实际生产级别的 raft 读请求实现一般都采用了 Read Index 或者 Lease Read 的方式，具体原理可以参考此线性一致性<a href=https://tanxinyu.work/consistency-and-consensus/#etcd-%E7%9A%84-Raft>博客</a>，具体实现可以参照 SOFAJRaft 的实现<a href=https://www.sofastack.tech/blog/sofa-jraft-linear-consistent-read-implementation/>博客</a>。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>kv</span> <span class=o>*</span><span class=nx>KVServer</span><span class=p>)</span> <span class=nf>applier</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>!</span><span class=nx>kv</span><span class=p>.</span><span class=nf>killed</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>msg</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>applyCh</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>DPrintf</span><span class=p>(</span><span class=s>&#34;[applier] - {Node: %v} tries to apply message %v&#34;</span><span class=p>,</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>rf</span><span class=p>.</span><span class=nf>Me</span><span class=p>(),</span> <span class=nx>msg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>CommandValid</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>CommandIndex</span> <span class=o>&lt;=</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>lastApplied</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nf>DPrintf</span><span class=p>(</span><span class=s>&#34;[applier] - {Node: %v} discards outdated message %v since a newer snapshot which lastapplied is %v has been restored&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>						<span class=nx>kv</span><span class=p>.</span><span class=nx>rf</span><span class=p>.</span><span class=nf>Me</span><span class=p>(),</span> <span class=nx>msg</span><span class=p>,</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>lastApplied</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>					<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>					<span class=k>continue</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=nx>kv</span><span class=p>.</span><span class=nx>lastApplied</span> <span class=p>=</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>CommandIndex</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=nx>resp</span> <span class=p>=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>CommandResponse</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>command</span> <span class=o>:=</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>Command</span><span class=p>.(</span><span class=nx>Command</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>command</span><span class=p>.</span><span class=nx>Op</span> <span class=o>!=</span> <span class=nx>OpGet</span> <span class=o>&amp;&amp;</span> <span class=nx>kv</span><span class=p>.</span><span class=nf>isDuplicatedReq</span><span class=p>(</span><span class=nx>command</span><span class=p>.</span><span class=nx>ClientId</span><span class=p>,</span> <span class=nx>command</span><span class=p>.</span><span class=nx>CommandId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nf>DPrintf</span><span class=p>(</span><span class=s>&#34;[applier] - {Node: %v} doesn&#39;t apply duplicated message %v to state machine since maxAppliedCommandId is %v for client %v&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>						<span class=nx>kv</span><span class=p>.</span><span class=nx>rf</span><span class=p>.</span><span class=nf>Me</span><span class=p>(),</span> <span class=nx>msg</span><span class=p>,</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>lastOperations</span><span class=p>[</span><span class=nx>command</span><span class=p>.</span><span class=nx>ClientId</span><span class=p>],</span> <span class=nx>command</span><span class=p>.</span><span class=nx>ClientId</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>					<span class=nx>resp</span> <span class=p>=</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>lastOperations</span><span class=p>[</span><span class=nx>command</span><span class=p>.</span><span class=nx>ClientId</span><span class=p>].</span><span class=nx>LastResponse</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>resp</span> <span class=p>=</span> <span class=nx>kv</span><span class=p>.</span><span class=nf>applyLogToStateMachine</span><span class=p>(</span><span class=nx>command</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=nx>command</span><span class=p>.</span><span class=nx>Op</span> <span class=o>!=</span> <span class=nx>OpGet</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>						<span class=nx>kv</span><span class=p>.</span><span class=nx>lastOperations</span><span class=p>[</span><span class=nx>command</span><span class=p>.</span><span class=nx>ClientId</span><span class=p>]</span> <span class=p>=</span> <span class=nx>OperationContext</span><span class=p>{</span>
</span></span><span class=line><span class=cl>							<span class=nx>MaxAppliedCommandId</span><span class=p>:</span> <span class=nx>command</span><span class=p>.</span><span class=nx>CommandId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>							<span class=nx>LastResponse</span><span class=p>:</span>        <span class=nx>resp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>						<span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=c1>// 记录每个idx apply 到state machine 的 CommandResponse
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 为了保证强一致性，仅对当前 term 日志的 notifyChan 进行通知，
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 让之前 term 的客户端协程都超时重试。避免leader 降级为 follower
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 后又迅速重新当选了 leader，而此时依然有客户端协程未超时在阻塞等待，
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// 那么此时 apply 日志后，根据 index 获得 channel 并向其中 push 执行结果就可能出错，因为可能并不对应
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=k>if</span> <span class=nx>currentTerm</span><span class=p>,</span> <span class=nx>isLeader</span> <span class=o>:=</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>rf</span><span class=p>.</span><span class=nf>GetState</span><span class=p>();</span> <span class=nx>isLeader</span> <span class=o>&amp;&amp;</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>CommandTerm</span> <span class=o>==</span> <span class=nx>currentTerm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>ch</span> <span class=o>:=</span> <span class=nx>kv</span><span class=p>.</span><span class=nf>getNotifyChan</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>CommandIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>resp</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=c1>// part 2
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nx>needSnapshot</span> <span class=o>:=</span> <span class=nx>kv</span><span class=p>.</span><span class=nf>needSnapshot</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>needSnapshot</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>kv</span><span class=p>.</span><span class=nf>takeSnapshot</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>CommandIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>SnapshotValid</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>rf</span><span class=p>.</span><span class=nf>CondInstallSnapshot</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>SnapshotTerm</span><span class=p>,</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>SnapshotIndex</span><span class=p>,</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>Snapshot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=nx>kv</span><span class=p>.</span><span class=nf>restoreSnapshot</span><span class=p>(</span><span class=nx>msg</span><span class=p>.</span><span class=nx>Snapshot</span><span class=p>)</span>
</span></span><span class=line><span class=cl>					<span class=nx>kv</span><span class=p>.</span><span class=nx>lastApplied</span> <span class=p>=</span> <span class=nx>msg</span><span class=p>.</span><span class=nx>SnapshotIndex</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nb>panic</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;unexpected Message: %v&#34;</span><span class=p>,</span> <span class=nx>msg</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>leader 比 follower 多出一个 notifyChan 环节，是因为 leader 需要处理 rpc 请求响应，而 follower 不用，一个很简单的流程其实就是 client -> kvservice -> Start() -> applyCh -> kvservice -> client，但是applyCh是逐个 commit 一个一个返回，所以需要明确返回的 commit 对应的是哪一个请求，即通过 commitIndex唯一确定一个请求，然后通知该请求执行流程可以返回了。</p><p>对于读请求，由于其不影响系统状态，所以直接去状态机执行即可，当然，其结果也不需要再记录到去重的数据结构中。</p><h3 id=commandrpc-逻辑>CommandRPC 逻辑<a hidden class=anchor aria-hidden=true href=#commandrpc-逻辑>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Command 客户端调用的RPC方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>kv</span> <span class=o>*</span><span class=nx>KVServer</span><span class=p>)</span> <span class=nf>Command</span><span class=p>(</span><span class=nx>req</span> <span class=o>*</span><span class=nx>CommandRequest</span><span class=p>,</span> <span class=nx>resp</span> <span class=o>*</span><span class=nx>CommandResponse</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nf>DPrintf</span><span class=p>(</span><span class=s>&#34;[Command]- {Node: %v} processes CommandReq %v with CommandResp %v&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nx>kv</span><span class=p>.</span><span class=nx>rf</span><span class=p>.</span><span class=nf>Me</span><span class=p>(),</span> <span class=nx>req</span><span class=p>,</span> <span class=nx>resp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 如果请求是重复的，直接在 OperationContext 中拿到之前的结果返回
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RLock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>req</span><span class=p>.</span><span class=nx>Op</span> <span class=o>!=</span> <span class=nx>OpGet</span> <span class=o>&amp;&amp;</span> <span class=nx>kv</span><span class=p>.</span><span class=nf>isDuplicatedReq</span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>ClientId</span><span class=p>,</span> <span class=nx>req</span><span class=p>.</span><span class=nx>CommandId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>lastResp</span> <span class=o>:=</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>lastOperations</span><span class=p>[</span><span class=nx>req</span><span class=p>.</span><span class=nx>ClientId</span><span class=p>].</span><span class=nx>LastResponse</span>
</span></span><span class=line><span class=cl>		<span class=nx>resp</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Err</span> <span class=p>=</span> <span class=nx>lastResp</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span> <span class=nx>lastResp</span><span class=p>.</span><span class=nx>Err</span>
</span></span><span class=line><span class=cl>		<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>RUnlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>idx</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>isLeader</span> <span class=o>:=</span> <span class=nx>kv</span><span class=p>.</span><span class=nx>rf</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>Command</span><span class=p>{</span><span class=nx>req</span><span class=p>})</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>isLeader</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>resp</span><span class=p>.</span><span class=nx>Err</span> <span class=p>=</span> <span class=nx>ErrWrongLeader</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>ch</span> <span class=o>:=</span> <span class=nx>kv</span><span class=p>.</span><span class=nf>getNotifyChan</span><span class=p>(</span><span class=nx>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>result</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nx>resp</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span> <span class=nx>resp</span><span class=p>.</span><span class=nx>Err</span> <span class=p>=</span> <span class=nx>result</span><span class=p>.</span><span class=nx>Value</span><span class=p>,</span> <span class=nx>result</span><span class=p>.</span><span class=nx>Err</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>time</span><span class=p>.</span><span class=nf>After</span><span class=p>(</span><span class=nx>ExecuteTimeOut</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=nx>resp</span><span class=p>.</span><span class=nx>Err</span> <span class=p>=</span> <span class=nx>ErrTimeout</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>kv</span><span class=p>.</span><span class=nf>removeOutdatedNotifyChan</span><span class=p>(</span><span class=nx>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>kv</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=lab3b---日志压缩>Lab3B - 日志压缩<a hidden class=anchor aria-hidden=true href=#lab3b---日志压缩>#</a></h1><p>首先，日志的 snapshot 不仅需要包含状态机的状态，还需要包含用来去重的 lastOperations 哈希表。</p><p>其次，apply 协程负责持锁阻塞式的去生成 snapshot，幸运的是，此时 raft 框架是不阻塞的，依然可以同步并提交日志，只是不 apply 而已。如果这里还想进一步优化的话，可以将状态机搞成 MVCC 等能够 COW 的机制，这样应该就可以不阻塞状态机的更新了</p><p>优化:
项目中 <code>LastOperations</code> 和 <code>NotifyChan</code> 都是使用map 不能并发安全，用了一张大锁保平安。
实际上可以使用Sync.Map 然后将锁的粒度细化来优化这块</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/tags/raft/>Raft</a></li><li><a href=https://reid00.github.io/tags/mit6.824/>MIT6.824</a></li><li><a href=https://reid00.github.io/tags/consensus/>Consensus</a></li><li><a href=https://reid00.github.io/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/>共识算法</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/posts/storage/20230214-mit6.824-2022-lab4-shardedkv/><span class=title>« Prev</span><br><span>20230214 MIT6.824 2022 Lab4 ShardedKV</span></a>
<a class=next href=https://reid00.github.io/posts/storage/raft-etcd-%E4%B9%8B-linearizable-read/><span class=title>Next »</span><br><span>Raft Etcd 之 Linearizable Read</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://reid00.github.io/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>