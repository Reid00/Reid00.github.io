<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spark 广播变量 | Reid's Blog</title><meta name=keywords content="spark,广播变量,累加器,driver,executor"><meta name=description content="Spark 广播变量"><meta name=author content="Reid"><link rel=canonical href=https://reid00.github.io/posts/computation/spark-%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://reid00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://reid00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://reid00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://reid00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://reid00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><head><meta name=referrer content="no-referrer"></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-QRR6GRNQGK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QRR6GRNQGK",{anonymize_ip:!1})}</script><meta property="og:title" content="Spark 广播变量"><meta property="og:description" content="Spark 广播变量"><meta property="og:type" content="article"><meta property="og:url" content="https://reid00.github.io/posts/computation/spark-%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/"><meta property="og:image" content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-16T19:34:50+08:00"><meta property="article:modified_time" content="2023-03-16T19:34:50+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.loli.net/2021/09/26/3OMGXylm8HUYJ6p.png"><meta name=twitter:title content="Spark 广播变量"><meta name=twitter:description content="Spark 广播变量"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://reid00.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Spark 广播变量","item":"https://reid00.github.io/posts/computation/spark-%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spark 广播变量","name":"Spark 广播变量","description":"Spark 广播变量","keywords":["spark","广播变量","累加器","driver","executor"],"articleBody":"概述 在spark程序中，当一个传递给Spark操作(例如map和reduce)的函数在远程节点上面运行时，Spark操作实际上操作的是这个函数所用变量的一个独立副本。这些变量会被复制到每台机器上，并且这些变量在远程机器上的所有更新都不会传递回驱动程序。通常跨任务的读写变量是低效的，但是，Spark还是为两种常见的使用模式提供了两种有限的共享变量：广播变（broadcast variable）和累加器（accumulator）\n为什么需要广播变量 如果我们要在分布式计算里面分发大对象，例如：字典，集合，黑白名单等，这个都会由Driver端进行分发，一般来讲，如果这个变量不是广播变量，那么每个task就会分发一份，这在task数目十分多的情况下Driver的带宽会成为系统的瓶颈，而且会大量消耗task服务器上的资源，如果将这个变量声明为广播变量，那么知识每个executor拥有一份，这个executor启动的task会共享这个变量，节省了通信的成本和服务器的资源。\n图解广播变量 不使用广播变量 使用广播变量 可知: 如果使用广播变量，一个executor 只有一个driver 变量的副本，节省资源，而不是用的话，同一个executor 的不同task 都会有这个变量的副本，网络IO就会成为瓶颈。\n如何定义广播变量 1 2 3 4 5 6 7 8 val data = List(1, 2, 3, 4, 5, 6) val bdata = sc.broadcast(data) val rdd = sc.parallelize(1 to 6, 2) val observedSizes = rdd.map(_ =\u003e bdata.value.size) 取 value val c = broadcast.value 注意点 变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改\n1、能不能将一个RDD使用广播变量广播出去？\n不能，因为RDD是不存储数据的。可以将RDD的结果广播出去。 2、 广播变量只能在Driver端定义，不能在Executor端定义。\n3、 在Driver端可以修改广播变量的值，在Executor端无法修改广播变量的值。\n4、如果executor端用到了Driver的变量，如果不使用广播变量在Executor有多少task就有多少Driver端的变量副本。\n5、如果Executor端用到了Driver的变量，如果使用广播变量在每个Executor中只有一份Driver端的变量副本。\n为什么需要累加器 在spark应用程序中，我们经常会有这样的需求，如异常监控，调试，记录符合某特性的数据的数目，这种需求都需要用到计数器，如果一个变量不被声明为一个累加器，那么它将在被改变时不会再driver端进行全局汇总，即在分布式运行时每个task运行的只是原始变量的一个副本，并不能改变原始变量的值，但是当这个变量被声明为累加器后，该变量就会有分布式计数的功能。\n图解累加器 不使用累加器 使用累加器 如何定义一个累加器？ 1 2 3 4 val a = sc.accumulator(0) 取值 val b = a.value 注意点 1、 累加器在Driver端定义赋初始值，累加器只能在Driver端读取最后的值，在Excutor端更新。\n2、累加器不是一个调优的操作，因为如果不这样做，结果是错的\n哪些变量在Drive 端，哪些在Executor 端 driver \u0026 executor driver是运行用户编写Application 的main()函数的地方，具体负责DAG的构建、任务的划分、task的生成与调度等。job，stage，task生成都离不开rdd自身，rdd的相关的操作不能缺少driver端的sparksession/sparkcontext。\nexecutor是真正执行task地方，而task执行离不开具体的数据，这些task运行的结果可以是shuffle中间结果，也可以持久化到外部存储系统。一般都是将结果、状态等汇集到driver。但是，目前executor之间不能互相通信，只能借助第三方来实现数据的共享或者通信。\n那么，编写的Spark程序代码，运行在driver端还是executor端呢？ 通常我们在本地测试程序的时候，要打印RDD中的数据。\n在本地模式下，直接使用rdd.foreach(println)或rdd.map(println)在单台机器上，能够按照预期打印并输出所有RDD的元素。\n但是，在集群模式下，由executor执行输出写入的是executor的stdout，而不是driver上的stdout，所以driver的stdout不会显示这些！\n要想在driver端打印所有元素，可以使用collect()方法先将RDD数据带到driver节点，然后在调用foreach(println)（但需要注意一点，由于会把RDD中所有元素都加载到driver端，可能引起driver端内存不足导致OOM。如果你只是想获取RDD中的部分元素，可以考虑使用take或者top方法）\n总之，在这里RDD中的元素即为具体的数据，对这些数据的操作都是由负责task执行的executor处理的，所以想在driver端输出这些数据就必须先将数据加载到driver端进行处理。\n最后做个总结：所有对RDD具体数据的操作都是在executor上执行的，所有对rdd自身的操作都是在driver上执行的。比如foreach、foreachPartition都是针对rdd内部数据进行处理的，所以我们传递给这些算子的函数都是执行于executor端的。但是像foreachRDD、transform则是对RDD本身进行一列操作，所以它的参数函数是执行在driver端的，那么它内部是可以使用外部变量，比如在Spark Streaming程序中操作offset、动态更新广播变量等。\n","wordCount":"105","inLanguage":"en","datePublished":"2023-03-16T19:34:50+08:00","dateModified":"2023-03-16T19:34:50+08:00","author":[{"@type":"Person","name":"Reid"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://reid00.github.io/posts/computation/spark-%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/"},"publisher":{"@type":"Organization","name":"Reid's Blog","logo":{"@type":"ImageObject","url":"https://reid00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://reid00.github.io/ accesskey=h title="Reid's Blog (Alt + H)">Reid's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://reid00.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://reid00.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://reid00.github.io/categories/ title=Categorys><span>Categorys</span></a></li><li><a href=https://reid00.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://reid00.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://reid00.github.io/posts/>Posts</a></div><h1 class=post-title>Spark 广播变量</h1><div class=post-description>Spark 广播变量</div><div class=post-meta><span title='2023-03-16 19:34:50 +0800 +0800'>2023-03-16</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Reid</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%a6%82%e8%bf%b0 aria-label=概述>概述</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%b9%bf%e6%92%ad%e5%8f%98%e9%87%8f aria-label=为什么需要广播变量>为什么需要广播变量</a><ul><li><a href=#%e5%9b%be%e8%a7%a3%e5%b9%bf%e6%92%ad%e5%8f%98%e9%87%8f aria-label=图解广播变量>图解广播变量</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e5%b9%bf%e6%92%ad%e5%8f%98%e9%87%8f aria-label=如何定义广播变量>如何定义广播变量</a></li><li><a href=#%e6%b3%a8%e6%84%8f%e7%82%b9 aria-label=注意点>注意点</a></li></ul></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%b4%af%e5%8a%a0%e5%99%a8 aria-label=为什么需要累加器>为什么需要累加器</a><ul><li><a href=#%e5%9b%be%e8%a7%a3%e7%b4%af%e5%8a%a0%e5%99%a8 aria-label=图解累加器>图解累加器</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e7%b4%af%e5%8a%a0%e5%99%a8 aria-label=如何定义一个累加器？>如何定义一个累加器？</a></li><li><a href=#%e6%b3%a8%e6%84%8f%e7%82%b9-1 aria-label=注意点>注意点</a></li></ul></li><li><a href=#%e5%93%aa%e4%ba%9b%e5%8f%98%e9%87%8f%e5%9c%a8drive-%e7%ab%af%e5%93%aa%e4%ba%9b%e5%9c%a8executor-%e7%ab%af aria-label="哪些变量在Drive 端，哪些在Executor 端">哪些变量在Drive 端，哪些在Executor 端</a><ul><li><a href=#driver--executor aria-label="driver &amp;amp; executor">driver & executor</a></li><li><a href=#%e9%82%a3%e4%b9%88%e7%bc%96%e5%86%99%e7%9a%84spark%e7%a8%8b%e5%ba%8f%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c%e5%9c%a8driver%e7%ab%af%e8%bf%98%e6%98%afexecutor%e7%ab%af%e5%91%a2 aria-label=那么，编写的Spark程序代码，运行在driver端还是executor端呢？>那么，编写的Spark程序代码，运行在driver端还是executor端呢？</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=概述>概述<a hidden class=anchor aria-hidden=true href=#概述>#</a></h1><p>在spark程序中，当一个传递给Spark操作(例如map和reduce)的函数在远程节点上面运行时，Spark操作实际上操作的是这个函数所用变量的一个独立副本。这些变量会被复制到每台机器上，并且这些变量在远程机器上的所有更新都不会传递回驱动程序。通常跨任务的读写变量是低效的，但是，Spark还是为两种常见的使用模式提供了两种有限的共享变量：广播变（broadcast variable）和累加器（accumulator）</p><h1 id=为什么需要广播变量>为什么需要广播变量<a hidden class=anchor aria-hidden=true href=#为什么需要广播变量>#</a></h1><p>如果我们要在分布式计算里面分发大对象，例如：字典，集合，黑白名单等，这个都会由Driver端进行分发，一般来讲，如果这个变量不是广播变量，那么每个task就会分发一份，这在task数目十分多的情况下Driver的带宽会成为系统的瓶颈，而且会大量消耗task服务器上的资源，如果将这个变量声明为广播变量，那么知识每个executor拥有一份，这个executor启动的task会共享这个变量，节省了通信的成本和服务器的资源。</p><h2 id=图解广播变量>图解广播变量<a hidden class=anchor aria-hidden=true href=#图解广播变量>#</a></h2><p>不使用广播变量
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.3oek64ejio20.webp alt=not-use>
使用广播变量
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.5nmd6d2n5cg0.webp alt=use>
可知: 如果使用广播变量，一个executor 只有一个driver 变量的副本，节省资源，而不是用的话，同一个executor 的不同task 都会有这个变量的副本，网络IO就会成为瓶颈。</p><h2 id=如何定义广播变量>如何定义广播变量<a hidden class=anchor aria-hidden=true href=#如何定义广播变量>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>val <span class=nv>data</span> <span class=o>=</span> List<span class=o>(</span>1, 2, 3, 4, 5, 6<span class=o>)</span>
</span></span><span class=line><span class=cl>val <span class=nv>bdata</span> <span class=o>=</span> sc.broadcast<span class=o>(</span>data<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>val <span class=nv>rdd</span> <span class=o>=</span> sc.parallelize<span class=o>(</span><span class=m>1</span> to 6, 2<span class=o>)</span>
</span></span><span class=line><span class=cl>val <span class=nv>observedSizes</span> <span class=o>=</span> rdd.map<span class=o>(</span><span class=nv>_</span> <span class=o>=</span>&gt; bdata.value.size<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>取 value
</span></span><span class=line><span class=cl>val <span class=nv>c</span> <span class=o>=</span> broadcast.value
</span></span></code></pre></td></tr></table></div></div><h2 id=注意点>注意点<a hidden class=anchor aria-hidden=true href=#注意点>#</a></h2><p>变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改</p><p>1、能不能将一个RDD使用广播变量广播出去？</p><ul><li>不能，因为RDD是不存储数据的。可以将RDD的结果广播出去。</li></ul><p>2、 广播变量只能在Driver端定义，不能在Executor端定义。</p><p>3、 在Driver端可以修改广播变量的值，在Executor端无法修改广播变量的值。</p><p>4、如果executor端用到了Driver的变量，如果不使用广播变量在Executor有多少task就有多少Driver端的变量副本。</p><p>5、如果Executor端用到了Driver的变量，如果使用广播变量在每个Executor中只有一份Driver端的变量副本。</p><h1 id=为什么需要累加器>为什么需要累加器<a hidden class=anchor aria-hidden=true href=#为什么需要累加器>#</a></h1><p>在spark应用程序中，我们经常会有这样的需求，如异常监控，调试，记录符合某特性的数据的数目，这种需求都需要用到计数器，如果一个变量不被声明为一个累加器，那么它将在被改变时不会再driver端进行全局汇总，即在分布式运行时每个task运行的只是原始变量的一个副本，并不能改变原始变量的值，但是当这个变量被声明为累加器后，该变量就会有分布式计数的功能。</p><h2 id=图解累加器>图解累加器<a hidden class=anchor aria-hidden=true href=#图解累加器>#</a></h2><p>不使用累加器
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.23g59129ajds.webp alt></p><p>使用累加器
<img loading=lazy src=https://raw.githubusercontent.com/Reid00/image-host/main/20220617/image.3gn7uebrisu0.webp alt></p><h2 id=如何定义一个累加器>如何定义一个累加器？<a hidden class=anchor aria-hidden=true href=#如何定义一个累加器>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>val <span class=nv>a</span> <span class=o>=</span> sc.accumulator<span class=o>(</span>0<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>取值
</span></span><span class=line><span class=cl>val <span class=nv>b</span> <span class=o>=</span> a.value
</span></span></code></pre></td></tr></table></div></div><h2 id=注意点-1>注意点<a hidden class=anchor aria-hidden=true href=#注意点-1>#</a></h2><p>1、 累加器在Driver端定义赋初始值，累加器只能在Driver端读取最后的值，在Excutor端更新。</p><p>2、累加器不是一个调优的操作，因为如果不这样做，结果是错的</p><h1 id=哪些变量在drive-端哪些在executor-端>哪些变量在Drive 端，哪些在Executor 端<a hidden class=anchor aria-hidden=true href=#哪些变量在drive-端哪些在executor-端>#</a></h1><h2 id=driver--executor>driver & executor<a hidden class=anchor aria-hidden=true href=#driver--executor>#</a></h2><p>driver是运行用户编写Application 的main()函数的地方，具体负责DAG的构建、任务的划分、task的生成与调度等。job，stage，task生成都离不开rdd自身，rdd的相关的操作不能缺少driver端的sparksession/sparkcontext。</p><p>executor是真正执行task地方，而task执行离不开具体的数据，这些task运行的结果可以是shuffle中间结果，也可以持久化到外部存储系统。一般都是将结果、状态等汇集到driver。但是，目前executor之间不能互相通信，只能借助第三方来实现数据的共享或者通信。</p><h2 id=那么编写的spark程序代码运行在driver端还是executor端呢>那么，编写的Spark程序代码，运行在driver端还是executor端呢？<a hidden class=anchor aria-hidden=true href=#那么编写的spark程序代码运行在driver端还是executor端呢>#</a></h2><p>通常我们在本地测试程序的时候，要打印RDD中的数据。</p><p>在本地模式下，直接使用rdd.foreach(println)或rdd.map(println)在单台机器上，能够按照预期打印并输出所有RDD的元素。</p><p>但是，在集群模式下，由executor执行输出写入的是executor的stdout，而不是driver上的stdout，所以driver的stdout不会显示这些！</p><p>要想在driver端打印所有元素，可以使用collect()方法先将RDD数据带到driver节点，然后在调用foreach(println)（但需要注意一点，由于会把RDD中所有元素都加载到driver端，可能引起driver端内存不足导致OOM。如果你只是想获取RDD中的部分元素，可以考虑使用take或者top方法）</p><p>总之，在这里RDD中的元素即为具体的数据，对这些数据的操作都是由负责task执行的executor处理的，所以想在driver端输出这些数据就必须先将数据加载到driver端进行处理。</p><p>最后做个总结：所有对RDD具体数据的操作都是在executor上执行的，所有对rdd自身的操作都是在driver上执行的。比如foreach、foreachPartition都是针对rdd内部数据进行处理的，所以我们传递给这些算子的函数都是执行于executor端的。但是像foreachRDD、transform则是对RDD本身进行一列操作，所以它的参数函数是执行在driver端的，那么它内部是可以使用外部变量，比如在Spark Streaming程序中操作offset、动态更新广播变量等。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://reid00.github.io/tags/spark/>Spark</a></li><li><a href=https://reid00.github.io/tags/%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/>广播变量</a></li><li><a href=https://reid00.github.io/tags/%E7%B4%AF%E5%8A%A0%E5%99%A8/>累加器</a></li><li><a href=https://reid00.github.io/tags/driver/>driver</a></li><li><a href=https://reid00.github.io/tags/executor/>executor</a></li></ul><nav class=paginav><a class=prev href=https://reid00.github.io/posts/computation/spark-on-yarn-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/><span class=title>« Prev</span><br><span>Spark on Yarn 执行流程解析</span></a>
<a class=next href=https://reid00.github.io/posts/other/slidev-markdown-%E8%BD%ACppt/><span class=title>Next »</span><br><span>Slidev Markdown 转PPT</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Reid00/hugo-blog-talks issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://reid00.github.io/>Reid's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>